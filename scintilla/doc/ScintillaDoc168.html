<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0050)http://scintilla.sourceforge.net/ScintillaDoc.html -->
<?xml version="1.0"?><HTML xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>Scintilla and SciTE</TITLE>
<META content="MSHTML 6.00.2900.2873" name=GENERATOR>
<META content=SciTE name=generator>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<STYLE type=text/css>CODE {
	FONT-FAMILY: "Courier New", monospace
}
A:visited {
	COLOR: blue
}
A:hover {
	TEXT-DECORATION: underline! important
}
A.message {
	FONT-FAMILY: "Courier New", monospace; TEXT-DECORATION: none
}
A.toc {
	TEXT-DECORATION: none
}
A.jump {
	TEXT-DECORATION: none
}
</STYLE>
</HEAD>
<BODY text=#000000 bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" bgColor=#000000 summary=Banner 
border=0>
  <TBODY>
  <TR>
    <TD><IMG height=64 alt="Scintilla icon" 
      src="ScintillaDoc168.files/SciTEIco.png" width=64 border=3></TD>
    <TD><A style="FONT-SIZE: 200%; COLOR: white; TEXT-DECORATION: none" 
      href="http://scintilla.sourceforge.net/index.html">Scintilla</A></TD></TR></TBODY></TABLE>
<H1>Scintilla Documentation</H1>
<P>Last edited 4/February/2006 NH</P>
<P>There is <A class=jump href="http://scintilla.sourceforge.net/Design.html">an 
overview of the internal design of Scintilla</A>.<BR><A class=jump 
href="http://scintilla.sourceforge.net/ScintillaUsage.html">Some notes on using 
Scintilla</A>.<BR><A class=jump 
href="http://scintilla.sourceforge.net/Steps.html">How to use the Scintilla Edit 
Control on Windows</A>.<BR><A class=jump 
href="http://www.scintilla.org/dmapp.zip">A simple sample using Scintilla from 
C++ on Windows</A>.<BR><A class=jump href="http://www.scintilla.org/SciTry.vb">A 
simple sample using Scintilla from Visual Basic</A>.<BR><A class=jump 
href="http://www.scintilla.org/bait.zip">Bait is a tiny sample using Scintilla 
on GTK+</A>.<BR><A class=jump 
href="http://scintilla.sourceforge.net/Lexer.txt">A detailed description of how 
to write a lexer, including a discussion of folding</A>.<BR><A class=jump 
href="http://sphere.sourceforge.net/flik/docs/scintilla-container_lexer.html">How 
to implement a lexer in the container</A>.<BR><A class=jump 
href="http://sphere.sourceforge.net/flik/docs/scintilla-folding.html">How to 
implement folding</A>.<BR>The <A class=jump 
href="http://scintilla.sourceforge.net/SciCoding.html">coding style</A> used in 
Scintilla and SciTE is worth following if you want to contribute code to 
Scintilla but is not compulsory.</P>
<H2>Introduction</H2>
<P>The Windows version of Scintilla is a Windows Control. As such, its primary 
programming interface is through Windows messages. Early versions of Scintilla 
emulated much of the API defined by the standard Windows Edit and RichEdit 
controls but those APIs are now deprecated in favour of Scintilla's own, more 
consistent API. In addition to messages performing the actions of a normal Edit 
control, Scintilla allows control of syntax styling, folding, markers, 
autocompletion and call tips.</P>
<P>The GTK+ version also uses messages in a similar way to the Windows version. 
This is different to normal GTK+ practice but made it easier to implement 
rapidly.</P>
<P>This documentation describes the individual messages and notifications used 
by Scintilla. It does not describe how to link them together to form a useful 
editor. For now, the best way to work out how to develop using Scintilla is to 
see how SciTE uses it. SciTE exercises most of Scintilla's facilities.</P>
<P>In the descriptions that follow, the messages are described as function calls 
with zero, one or two arguments. These two arguments are the standard 
<CODE>wParam</CODE> and <CODE>lParam</CODE> familiar to Windows programmers. 
These parameters are integers that are large enough to hold pointers, and the 
return value is also an integer large enough to contain a pointer. Although the 
commands only use the arguments described, because all messages have two 
arguments whether Scintilla uses them or not, it is strongly recommended that 
any unused arguments are set to 0. This allows future enhancement of messages 
without the risk of breaking existing code. Common argument types are:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Common argument types" border=0>
  <TBODY vAlign=top>
  <TR>
    <TH align=left>bool</TH>
    <TD>Arguments expect the values 0 for <CODE>false</CODE> and 1 for 
      <CODE>true</CODE>.</TD></TR>
  <TR>
    <TH align=left>int</TH>
    <TD>Arguments are 32-bit signed integers.</TD></TR>
  <TR>
    <TH align=left>const&nbsp;char&nbsp;*</TH>
    <TD>Arguments point at text that is being passed to Scintilla but not 
      modified. The text may be zero terminated or another argument may specify 
      the character count, the description will make this clear.</TD></TR>
  <TR>
    <TH align=left>char *</TH>
    <TD>Arguments point at text buffers that Scintilla will fill with text. In 
      some cases, another argument will tell Scintilla the buffer size. In 
      others, you must make sure that the buffer is big enough to hold the 
      requested text. If a NULL pointer (0) is passed then, for SCI_* calls, the 
      length that should be allocated is returned.</TD></TR>
  <TR>
    <TH id=colour align=left>colour</TH>
    <TD>Colours are set using the RGB format (Red, Green, Blue). The intensity 
      of each colour is set in the range 0 to 255. If you have three such 
      intensities, they are combined as: red | (green &lt;&lt; 8) | (blue 
      &lt;&lt; 16). If you set all intensities to 255, the colour is white. If 
      you set all intensities to 0, the colour is black. When you set a colour, 
      you are making a request. What you will get depends on the capabilities of 
      the system and the current screen mode.</TD></TR>
  <TR>
    <TH id=alpha align=left>alpha</TH>
    <TD>Translucency is set using an alpha value. Alpha ranges from 0 
      (SC_ALPHA_TRANSPARENT) which is completely transparent to 255 
      (SC_ALPHA_OPAQUE) which is opaque. The value 256 (SC_ALPHA_NOALPHA) is 
      opaque and uses code that is not alpha-aware and may be faster. Not all 
      platforms support translucency and only some Scintilla features implement 
      translucency. The default alpha value for most features is 
      SC_ALPHA_NOALPHA.</TD></TR>
  <TR>
    <TH align=left>&lt;unused&gt;</TH>
    <TD>This is an unused argument. Setting it to 0 will ensure compatibility 
      with future enhancements.</TD></TR></TBODY></TABLE>
<H2 id=MessageCategories>Contents</H2>
<TABLE cellSpacing=2 cellPadding=4 summary="Message categories" border=0>
  <TBODY>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#TextRetrievalAndModification">Text 
      retrieval and modification</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Searching">Searching 
      and replacing</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Overtype">Overtype</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#CutCopyAndPaste">Cut, 
      copy and paste</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#ErrorHandling">Error 
      handling</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#UndoAndRedo">Undo 
      and Redo</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#SelectionAndInformation">Selection 
      and information</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#ScrollingAndAutomaticScrolling">Scrolling 
      and automatic scrolling</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#WhiteSpace">White 
      space</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Cursor">Cursor</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#MouseCapture">Mouse 
      capture</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#LineEndings">Line 
      endings</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Styling">Styling</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition">Style 
      definition</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#CaretAndSelectionStyles">Caret, 
      selection, and hotspot styles</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Margins">Margins</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#OtherSettings">Other 
      settings</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#BraceHighlighting">Brace 
      highlighting</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#TabsAndIndentationGuides">Tabs 
      and Indentation Guides</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Markers">Markers</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Indicators">Indicators</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Autocompletion">Autocompletion</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#UserLists">User 
      lists</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#CallTips">Call 
      tips</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#KeyboardCommands">Keyboard 
      commands</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#KeyBindings">Key 
      bindings</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#PopupEditMenu">Popup 
      edit menu</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#MacroRecording">Macro 
      recording</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Printing">Printing</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#DirectAccess">Direct 
      access</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#MultipleViews">Multiple 
      views</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Folding">Folding</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#LineWrapping">Line 
      wrapping</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Zooming">Zooming</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#LongLines">Long 
      lines</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Lexer">Lexer</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">Notifications</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#GTK">GTK+</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#DeprecatedMessages">Deprecated 
      messages</A></TD></TR>
  <TR>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#EditMessagesNeverSupportedByScintilla">Edit 
      messages never supported by Scintilla</A></TD>
    <TD>o <A class=toc 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#BuildingScintilla">Building 
      Scintilla</A></TD></TR></TBODY></TABLE>
<P>Messages with names of the form <CODE>SCI_SETxxxxx</CODE> often have a 
companion <CODE>SCI_GETxxxxx</CODE>. To save tedious repetition, if the 
<CODE>SCI_GETxxxxx</CODE> message returns the value set by the 
<CODE>SCI_SETxxxxx</CODE> message, the <CODE>SET</CODE> routine is described and 
the <CODE>GET</CODE> routine is left to your imagination.</P>
<H2 id=TextRetrievalAndModification>Text retrieval and modification</H2>
<P>Each character in a Scintilla document is followed by an associated byte of 
styling information. The combination of a character byte and a style byte is 
called a cell. Style bytes are interpreted as a style index in the low 5 bits 
and as 3 individual bits of <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Indicators">indicators</A>. 
This allows 32 fundamental styles, which is enough for most languages, and three 
independent indicators so that, for example, syntax errors, deprecated names and 
bad indentation could all be displayed at once. The number of bits used for 
styles can be altered with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLEBITS"><CODE>SCI_SETSTYLEBITS</CODE></A> 
up to a maximum of 7 bits. The remaining bits can be used for indicators.</P>
<P>Positions within the Scintilla document refer to a character or the gap 
before that character. The first character in a document is 0, the second 1 and 
so on. If a document contains <CODE>nLen</CODE> characters, the last character 
is numbered <CODE>nLen</CODE>-1. The caret exists between character positions 
and can be located from before the first character (0) to after the last 
character (<CODE>nLen</CODE>).</P>
<P>There are places where the caret can not go where two character bytes make up 
one character. This occurs when a DBCS character from a language like Japanese 
is included in the document or when line ends are marked with the CP/M standard 
of a carriage return followed by a line feed. The <CODE>INVALID_POSITION</CODE> 
constant (-1) represents an invalid position within the document.</P>
<P>All lines of text in Scintilla are the same height, and this height is 
calculated from the largest font in any current style. This restriction is for 
performance; if lines differed in height then calculations involving positioning 
of text would require the text to be styled first.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXT">SCI_GETTEXT(int 
length, char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETTEXT">SCI_SETTEXT(&lt;unused&gt;, 
const char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSAVEPOINT">SCI_SETSAVEPOINT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINE">SCI_GETLINE(int 
line, char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_REPLACESEL">SCI_REPLACESEL(&lt;unused&gt;, 
const char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETREADONLY">SCI_SETREADONLY(bool 
readOnly)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETREADONLY">SCI_GETREADONLY</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE(&lt;unused&gt;, 
TextRange *tr)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ALLOCATE">SCI_ALLOCATE(int 
bytes, &lt;unused&gt;)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ADDTEXT">SCI_ADDTEXT(int 
length, const char *s)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ADDSTYLEDTEXT">SCI_ADDSTYLEDTEXT(int 
length, cell *s)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_APPENDTEXT">SCI_APPENDTEXT(int 
length, const char *s)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_INSERTTEXT">SCI_INSERTTEXT(int 
pos, const char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CLEARALL">SCI_CLEARALL</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CLEARDOCUMENTSTYLE">SCI_CLEARDOCUMENTSTYLE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCHARAT">SCI_GETCHARAT(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEAT">SCI_GETSTYLEAT(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT(&lt;unused&gt;, 
TextRange *tr)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLEBITS">SCI_SETSTYLEBITS(int 
bits)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEBITS">SCI_GETSTYLEBITS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_TARGETASUTF8">SCI_TARGETASUTF8(&lt;unused&gt;, 
char *s)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ENCODEDFROMUTF8">SCI_ENCODEDFROMUTF8(const 
char *utf8, char *encoded)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETLENGTHFORENCODE">SCI_SETLENGTHFORENCODE(int 
bytes)</A><BR></CODE>
<P><B id=SCI_GETTEXT>SCI_GETTEXT(int length, char *text)</B><BR>This returns 
<CODE>length</CODE>-1 characters of text from the start of the document plus one 
terminating 0 character. To collect all the text in a document, use 
<CODE>SCI_GETLENGTH</CODE> to get the number of characters in the document 
(<CODE>nLen</CODE>), allocate a character buffer of length <CODE>nLen+1</CODE> 
bytes, then call <CODE>SCI_GETTEXT(nLen+1, char *text)</CODE>. If the text 
argument is 0 then the length that should be allocated to store the entire 
document is returned. If you then save the text, you should use 
<CODE>SCI_SETSAVEPOINT</CODE> to mark the text as unmodified.</P>
<P>See also: <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSELTEXT">SCI_GETSELTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCURLINE">SCI_GETCURLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINE">SCI_GETLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</A></CODE></P>
<P><B id=SCI_SETTEXT>SCI_SETTEXT(&lt;unused&gt;, const char *text)</B><BR>This 
replaces all the text in the document with the zero terminated text string you 
pass in.</P>
<P><B id=SCI_SETSAVEPOINT>SCI_SETSAVEPOINT</B><BR>This message tells Scintilla 
that the current state of the document is unmodified. This is usually done when 
the file is saved or loaded, hence the name "save point". As Scintilla performs 
undo and redo operations, it notifies the container that it has entered or left 
the save point with <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</A></CODE> 
and <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_SAVEPOINTLEFT">SCN_SAVEPOINTLEFT</A></CODE> 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">notification 
messages</A>, allowing the container to know if the file should be considered 
dirty or not.</P>
<P>See also: <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMODIFY">SCI_GETMODIFY</A></CODE></P>
<P><B id=SCI_GETLINE>SCI_GETLINE(int line, char *text)</B><BR>This fills the 
buffer defined by text with the contents of the nominated line (lines start at 
0). The buffer is not terminated by a 0 character. It is up to you to make sure 
that the buffer is long enough for the text, use <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LINELENGTH"><CODE>SCI_LINELENGTH(int 
line)</CODE></A>. The returned value is the number of characters copied to the 
buffer. The returned text includes any end of line characters. If you ask for a 
line number outside the range of lines in the document, 0 characters are copied. 
If the text argument is 0 then the length that should be allocated to store the 
entire line is returned.</P>
<P>See also: <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCURLINE">SCI_GETCURLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSELTEXT">SCI_GETSELTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXT">SCI_GETTEXT</A></CODE></P>
<P><B id=SCI_REPLACESEL>SCI_REPLACESEL(&lt;unused&gt;, const char 
*text)</B><BR>The currently selected text between the <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SelectionAndInformation">anchor 
and the current position</A> is replaced by the 0 terminated text string. If the 
anchor and current position are the same, the text is inserted at the caret 
position. The caret is positioned after the inserted text and the caret is 
scrolled into view.</P>
<P><B id=SCI_SETREADONLY>SCI_SETREADONLY(bool readOnly)</B><BR><B 
id=SCI_GETREADONLY>SCI_GETREADONLY</B><BR>These messages set and get the 
read-only flag for the document. If you mark a document as read only, attempts 
to modify the text cause the <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MODIFYATTEMPTRO"><CODE>SCN_MODIFYATTEMPTRO</CODE></A> 
notification.</P>
<P><B id=SCI_GETTEXTRANGE>SCI_GETTEXTRANGE(&lt;unused&gt;, <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#TextRange">TextRange</A> 
*tr)</B><BR>This collects the text between the positions <CODE>cpMin</CODE> and 
<CODE>cpMax</CODE> and copies it to <CODE>lpstrText</CODE> (see <CODE>struct 
TextRange</CODE> in <CODE>Scintilla.h</CODE>). If <CODE>cpMax</CODE> is -1, text 
is returned to the end of the document. The text is 0 terminated, so you must 
supply a buffer that is at least 1 character longer than the number of 
characters you wish to read. The return value is the length of the returned text 
not including the terminating 0.</P>
<P>See also: <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSELTEXT">SCI_GETSELTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINE">SCI_GETLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCURLINE">SCI_GETCURLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXT">SCI_GETTEXT</A></CODE></P>
<P><B id=SCI_GETSTYLEDTEXT>SCI_GETSTYLEDTEXT(&lt;unused&gt;, <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#TextRange">TextRange</A> 
*tr)</B><BR>This collects styled text into a buffer using two bytes for each 
cell, with the character at the lower address of each pair and the style byte at 
the upper address. Characters between the positions <CODE>cpMin</CODE> and 
<CODE>cpMax</CODE> are copied to <CODE>lpstrText</CODE> (see <CODE>struct 
TextRange</CODE> in <CODE>Scintilla.h</CODE>). Two 0 bytes are added to the end 
of the text, so the buffer that <CODE>lpstrText</CODE> points at must be at 
least <CODE>2*(cpMax-cpMin)+2</CODE> bytes long. No check is made for sensible 
values of <CODE>cpMin</CODE> or <CODE>cpMax</CODE>. Positions outside the 
document return character codes and style bytes of 0.</P>
<P>See also: <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSELTEXT">SCI_GETSELTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINE">SCI_GETLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCURLINE">SCI_GETCURLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXT">SCI_GETTEXT</A></CODE></P>
<P><B id=SCI_ALLOCATE>SCI_ALLOCATE(int bytes, &lt;unused&gt;)</B><BR>Allocate a 
document buffer large enough to store a given number of bytes. The document will 
not be made smaller than its current contents.</P>
<P><B id=SCI_ADDTEXT>SCI_ADDTEXT(int length, const char *s)</B><BR>This inserts 
the first <CODE>length</CODE> characters from the string <CODE>s</CODE> at the 
current position. This will include any 0's in the string that you might have 
expected to stop the insert operation. The current position is set at the end of 
the inserted text, but it is not scrolled into view.</P>
<P><B id=SCI_ADDSTYLEDTEXT>SCI_ADDSTYLEDTEXT(int length, cell *s)</B><BR>This 
behaves just like <CODE>SCI_ADDTEXT</CODE>, but inserts styled text.</P>
<P><B id=SCI_APPENDTEXT>SCI_APPENDTEXT(int length, const char *s)</B><BR>This 
adds the first <CODE>length</CODE> characters from the string <CODE>s</CODE> to 
the end of the document. This will include any 0's in the string that you might 
have expected to stop the operation. The current selection is not changed and 
the new text is not scrolled into view.</P>
<P><B id=SCI_INSERTTEXT>SCI_INSERTTEXT(int pos, const char *text)</B><BR>This 
inserts the zero terminated <CODE>text</CODE> string at position 
<CODE>pos</CODE> or at the current position if <CODE>pos</CODE> is -1. If the 
current position is after the insertion point then it is moved along with its 
surrounding text but no scrolling is performed.</P>
<P><B id=SCI_CLEARALL>SCI_CLEARALL</B><BR>Unless the document is read-only, this 
deletes all the text.</P>
<P><B id=SCI_CLEARDOCUMENTSTYLE>SCI_CLEARDOCUMENTSTYLE</B><BR>When wanting to 
completely restyle the document, for example after choosing a lexer, the 
<CODE>SCI_CLEARDOCUMENTSTYLE</CODE> can be used to clear all styling information 
and reset the folding state.</P>
<P><B id=SCI_GETCHARAT>SCI_GETCHARAT(int pos)</B><BR>This returns the character 
at <CODE>pos</CODE> in the document or 0 if <CODE>pos</CODE> is negative or past 
the end of the document.</P>
<P><B id=SCI_GETSTYLEAT>SCI_GETSTYLEAT(int pos)</B><BR>This returns the style at 
<CODE>pos</CODE> in the document, or 0 if <CODE>pos</CODE> is negative or past 
the end of the document.</P>
<P><B id=SCI_SETSTYLEBITS>SCI_SETSTYLEBITS(int bits)</B><BR><B 
id=SCI_GETSTYLEBITS>SCI_GETSTYLEBITS</B><BR>This pair of routines sets and reads 
back the number of bits in each cell to use for styling, to a maximum of 7 style 
bits. The remaining bits can be used as indicators. The standard setting is 
<CODE>SCI_SETSTYLEBITS(5)</CODE>. The number of styling bits needed by the 
current lexer can be found with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEBITSNEEDED">SCI_GETSTYLEBITSNEEDED</A>.</P>
<P><B id=TextRange>TextRange</B> and <B 
id=CharacterRange>CharacterRange</B><BR>These structures are defined to be 
exactly the same shape as the Win32 <CODE>TEXTRANGE</CODE> and 
<CODE>CHARRANGE</CODE>, so that older code that treats Scintilla as a RichEdit 
will work.</P><PRE>struct CharacterRange {
    long cpMin;
    long cpMax;
};

struct TextRange {
    struct CharacterRange chrg;
    char *lpstrText;
};
</PRE>
<H3 id=EncodedAccess>GTK+-specific: Access to encoded text</H3>
<P><B id=SCI_TARGETASUTF8>SCI_TARGETASUTF8(&lt;unused&gt;, char *s)</B><BR>This 
method retrieves the value of the target encoded as UTF-8 which is the default 
encoding of GTK+ so is useful for retrieving text for use in other parts of the 
user interface, such as find and replace dialogs. The length of the encoded text 
in bytes is returned. </P>
<P><B id=SCI_ENCODEDFROMUTF8>SCI_ENCODEDFROMUTF8(const char *utf8, char 
*encoded)</B><BR><B id=SCI_SETLENGTHFORENCODE>SCI_SETLENGTHFORENCODE(int 
bytes)</B><BR><CODE>SCI_ENCODEDFROMUTF8</CODE> converts a UTF-8 string into the 
document's encoding which is useful for taking the results of a find dialog, for 
example, and receiving a string of bytes that can be searched for in the 
document. Since the text can contain nul bytes, the 
<CODE>SCI_SETLENGTHFORENCODE</CODE> method can be used to set the length that 
will be converted. If set to -1, the length is determined by finding a nul byte. 
The length of the converted string is returned. </P>
<H2 id=Searching>Searching</H2><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_FINDTEXT">SCI_FINDTEXT(int 
flags, TextToFind *ttf)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SEARCHANCHOR">SCI_SEARCHANCHOR</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SEARCHNEXT">SCI_SEARCHNEXT(int 
searchFlags, const char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SEARCHPREV">SCI_SEARCHPREV(int 
searchFlags, const char *text)</A><BR><A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SearchAndReplaceUsingTheTarget">Search 
and replace using the target</A><BR></CODE>
<P><B id=searchFlags><CODE>searchFlags</CODE></B><BR>Several of the search 
routines use flag options, which include a simple regular expression search. 
Combine the flag options by adding them:</P>
<TABLE summary="Search flags" border=0>
  <TBODY>
  <TR>
    <TD><CODE>SCFIND_MATCHCASE</CODE></TD>
    <TD>A match only occurs with text that matches the case of the search 
      string.</TD></TR>
  <TR>
    <TD><CODE>SCFIND_WHOLEWORD</CODE></TD>
    <TD>A match only occurs if the characters before and after are not word 
      characters.</TD></TR>
  <TR>
    <TD><CODE>SCFIND_WORDSTART</CODE></TD>
    <TD>A match only occurs if the character before is not a word 
  character.</TD></TR>
  <TR>
    <TD><CODE>SCFIND_REGEXP</CODE></TD>
    <TD>The search string should be interpreted as a regular expression.</TD></TR>
  <TR>
    <TD><CODE>SCFIND_POSIX</CODE></TD>
    <TD>Treat regular expression in a more POSIX compatible manner by 
      interpreting bare ( and ) for tagged sections rather than \( and 
  \).</TD></TR></TBODY></TABLE>
<P>If <CODE>SCFIND_REGEXP</CODE> is not included in the 
<CODE>searchFlags</CODE>, you can search backwards to find the previous 
occurrence of a search string by setting the end of the search range before the 
start. If <CODE>SCFIND_REGEXP</CODE> is included, searches are always from a 
lower position to a higher position, even if the search range is backwards.</P>
<P>In a regular expression, special characters interpreted are:</P>
<TABLE summary="Regular expression synopsis" border=0>
  <TBODY>
  <TR>
    <TD><CODE>.</CODE></TD>
    <TD>Matches any character</TD></TR>
  <TR>
    <TD><CODE>\(</CODE></TD>
    <TD>This marks the start of a region for tagging a match.</TD></TR>
  <TR>
    <TD><CODE>\)</CODE></TD>
    <TD>This marks the end of a tagged region.</TD></TR>
  <TR>
    <TD><CODE>\n</CODE></TD>
    <TD>Where <CODE>n</CODE> is 1 through 9 refers to the first through ninth 
      tagged region when replacing. For example, if the search string was 
      <CODE>Fred\([1-9]\)XXX</CODE> and the replace string was 
      <CODE>Sam\1YYY</CODE>, when applied to <CODE>Fred2XXX</CODE> this would 
      generate <CODE>Sam2YYY</CODE>.</TD></TR>
  <TR>
    <TD><CODE>\&lt;</CODE></TD>
    <TD>This matches the start of a word using Scintilla's definitions of 
      words.</TD></TR>
  <TR>
    <TD>\&gt;</TD>
    <TD>This matches the end of a word using Scintilla's definition of 
    words.</TD></TR>
  <TR>
    <TD><CODE>\x</CODE></TD>
    <TD>This allows you to use a character x that would otherwise have a 
      special meaning. For example, \[ would be interpreted as [ and not as the 
      start of a character set.</TD></TR>
  <TR>
    <TD><CODE>[...]</CODE></TD>
    <TD>This indicates a set of characters, for example, [abc] means any of 
      the characters a, b or c. You can also use ranges, for example [a-z] for 
      any lower case character.</TD></TR>
  <TR>
    <TD><CODE>[^...]</CODE></TD>
    <TD>The complement of the characters in the set. For example, [^A-Za-z] 
      means any character except an alphabetic character.</TD></TR>
  <TR>
    <TD><CODE>^</CODE></TD>
    <TD>This matches the start of a line (unless used inside a set, see 
    above).</TD></TR>
  <TR>
    <TD><CODE>$</CODE></TD>
    <TD>This matches the end of a line.</TD></TR>
  <TR>
    <TD><CODE>*</CODE></TD>
    <TD>This matches 0 or more times. For example, <CODE>Sa*m</CODE> matches 
      <CODE>Sm</CODE>, <CODE>Sam</CODE>, <CODE>Saam</CODE>, <CODE>Saaam</CODE> 
      and so on.</TD></TR>
  <TR>
    <TD><CODE>+</CODE></TD>
    <TD>This matches 1 or more times. For example, <CODE>Sa+m</CODE> matches 
      <CODE>Sam</CODE>, <CODE>Saam</CODE>, <CODE>Saaam</CODE> and so 
  on.</TD></TR></TBODY></TABLE>
<P><B id=SCI_FINDTEXT>SCI_FINDTEXT(int searchFlags, <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#TextToFind">TextToFind</A> 
*ttf)</B><BR>This message searches for text in the document. It does not use or 
move the current selection. The <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#searchFlags"><CODE>searchFlags</CODE></A> 
argument controls the search type, which includes regular expression 
searches.</P>
<P>The <CODE>TextToFind</CODE> structure is defined in <CODE>Scintilla.h</CODE>; 
set <CODE>chrg.cpMin</CODE> and <CODE>chrg.cpMax</CODE> with the range of 
positions in the document to search. If <CODE>SCFIND_REGEXP</CODE> is not 
included in the flags, you can search backwards by setting 
<CODE>chrg.cpMax</CODE> less than <CODE>chrg.cpMin</CODE>. If 
<CODE>SCFIND_REGEXP</CODE> is included, the search is always forwards (even if 
<CODE>chrg.cpMax</CODE> is less than <CODE>chrg.cpMin</CODE>). Set the 
<CODE>lpstrText</CODE> member of <CODE>TextToFind</CODE> to point at a zero 
terminated text string holding the search pattern. If your language makes the 
use of <CODE>TextToFind</CODE> difficult, you should consider using 
<CODE>SCI_SEARCHINTARGET</CODE> instead.</P>
<P>The return value is -1 if the search fails or the position of the start of 
the found text if it succeeds. The <CODE>chrgText.cpMin</CODE> and 
<CODE>chrgText.cpMax</CODE> members of <CODE>TextToFind</CODE> are filled in 
with the start and end positions of the found text.</P>
<P>See also: <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SEARCHINTARGET">SCI_SEARCHINTARGET</A></CODE></P>
<P><B id=TextToFind>TextToFind</B><BR>This structure is defined to have exactly 
the same shape as the Win32 structure <CODE>FINDTEXTEX</CODE> for old code that 
treated Scintilla as a RichEdit control.</P><PRE>struct TextToFind {
    struct <A class=jump href="http://scintilla.sourceforge.net/ScintillaDoc.html#CharacterRange">CharacterRange</A> chrg;     // range to search
    char *lpstrText;                // the search pattern (zero terminated)
    struct CharacterRange chrgText; // returned as position of matching text
};
</PRE>
<P><B id=SCI_SEARCHANCHOR>SCI_SEARCHANCHOR</B><BR><B 
id=SCI_SEARCHNEXT>SCI_SEARCHNEXT(int searchFlags, const char *text)</B><BR><B 
id=SCI_SEARCHPREV>SCI_SEARCHPREV(int searchFlags, const char *text)</B><BR>These 
messages provide relocatable search support. This allows multiple incremental 
interactive searches to be macro recorded while still setting the selection to 
found text so the find/select operation is self-contained. These three messages 
send <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MACRORECORD"><CODE>SCN_MACRORECORD</CODE></A> 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">notifications</A> 
if macro recording is enabled.</P>
<P><CODE>SCI_SEARCHANCHOR</CODE> sets the search start point used by 
<CODE>SCI_SEARCHNEXT</CODE> and <CODE>SCI_SEARCHPREV</CODE> to the start of the 
current selection, that is, the end of the selection that is nearer to the start 
of the document. You should always call this before calling either of 
<CODE>SCI_SEARCHNEXT</CODE> or <CODE>SCI_SEARCHPREV</CODE>.</P>
<P><CODE>SCI_SEARCHNEXT</CODE> and <CODE>SCI_SEARCHPREV</CODE> search for the 
next and previous occurrence of the zero terminated search string pointed at by 
text. The search is modified by the <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#searchFlags"><CODE>searchFlags</CODE></A>. 
If you request a regular expression, <CODE>SCI_SEARCHPREV</CODE> finds the first 
occurrence of the search string in the document, not the previous one before the 
anchor point.</P>
<P>The return value is -1 if nothing is found, otherwise the return value is the 
start position of the matching text. The selection is updated to show the 
matched text, but is not scrolled into view.</P>
<P>See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SEARCHINTARGET"><CODE>SCI_SEARCHINTARGET</CODE></A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_FINDTEXT"><CODE>SCI_FINDTEXT</CODE></A></P>
<H3 id=SearchAndReplaceUsingTheTarget>Search and replace using the target</H3>
<P>Using <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_REPLACESEL"><CODE>SCI_REPLACESEL</CODE></A>, 
modifications cause scrolling and other visible changes, which may take some 
time and cause unwanted display updates. If performing many changes, such as a 
replace all command, the target can be used instead. First, set the target, ie. 
the range to be replaced. Then call <CODE>SCI_REPLACETARGET</CODE> or 
<CODE>SCI_REPLACETARGETRE</CODE>.</P>
<P>Searching can be performed within the target range with 
<CODE>SCI_SEARCHINTARGET</CODE>, which uses a counted string to allow searching 
for null characters. It returns the length of range or -1 for failure, in which 
case the target is not moved. The flags used by <CODE>SCI_SEARCHINTARGET</CODE> 
such as <CODE>SCFIND_MATCHCASE</CODE>, <CODE>SCFIND_WHOLEWORD</CODE>, 
<CODE>SCFIND_WORDSTART</CODE>, and <CODE>SCFIND_REGEXP</CODE> can be set with 
<CODE>SCI_SETSEARCHFLAGS</CODE>. <CODE>SCI_SEARCHINTARGET</CODE> may be simpler 
for some clients to use than <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_FINDTEXT"><CODE>SCI_FINDTEXT</CODE></A>, 
as that requires using a pointer to a structure.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETTARGETSTART">SCI_SETTARGETSTART(int 
pos)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTARGETSTART">SCI_GETTARGETSTART</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETTARGETEND">SCI_SETTARGETEND(int 
pos)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTARGETEND">SCI_GETTARGETEND</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_TARGETFROMSELECTION">SCI_TARGETFROMSELECTION</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSEARCHFLAGS">SCI_SETSEARCHFLAGS(int 
searchFlags)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSEARCHFLAGS">SCI_GETSEARCHFLAGS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SEARCHINTARGET">SCI_SEARCHINTARGET(int 
length, const char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_REPLACETARGET">SCI_REPLACETARGET(int 
length, const char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_REPLACETARGETRE">SCI_REPLACETARGETRE(int 
length, const char *text)</A><BR></CODE>
<P><B id=SCI_SETTARGETSTART>SCI_SETTARGETSTART(int pos)</B><BR><B 
id=SCI_GETTARGETSTART>SCI_GETTARGETSTART</B><BR><B 
id=SCI_SETTARGETEND>SCI_SETTARGETEND(int pos)</B><BR><B 
id=SCI_GETTARGETEND>SCI_GETTARGETEND</B><BR>These functions set and return the 
start and end of the target. When searching in non-regular expression mode, you 
can set start greater than end to find the last matching text in the target 
rather than the first matching text. The target is also set by a successful 
<CODE>SCI_SEARCHINTARGET</CODE>.</P>
<P><B id=SCI_TARGETFROMSELECTION>SCI_TARGETFROMSELECTION</B><BR>Set the target 
start and end to the start and end positions of the selection.</P>
<P><B id=SCI_SETSEARCHFLAGS>SCI_SETSEARCHFLAGS(int searchFlags)</B><BR><B 
id=SCI_GETSEARCHFLAGS>SCI_GETSEARCHFLAGS</B><BR>These get and set the <A 
class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#searchFlags"><CODE>searchFlags</CODE></A> 
used by <CODE>SCI_SEARCHINTARGET</CODE>. There are several option flags 
including a simple regular expression search.</P>
<P><B id=SCI_SEARCHINTARGET>SCI_SEARCHINTARGET(int length, const char 
*text)</B><BR>This searches for the first occurrence of a text string in the 
target defined by <CODE>SCI_SETTARGETSTART</CODE> and 
<CODE>SCI_SETTARGETEND</CODE>. The text string is not zero terminated; the size 
is set by <CODE>length</CODE>. The search is modified by the search flags set by 
<CODE>SCI_SETSEARCHFLAGS</CODE>. If the search succeeds, the target is set to 
the found text and the return value is the position of the start of the matching 
text. If the search fails, the result is -1.</P>
<P><B id=SCI_REPLACETARGET>SCI_REPLACETARGET(int length, const char 
*text)</B><BR>If <CODE>length</CODE> is -1, <CODE>text</CODE> is a zero 
terminated string, otherwise <CODE>length</CODE> sets the number of character to 
replace the target with. After replacement, the target range refers to the 
replacement text. The return value is the length of the replacement 
string.<BR>Note that the recommended way to delete text in the document is to 
set the target to the text to be removed, and to perform a replace target with 
an empty string.</P>
<P><B id=SCI_REPLACETARGETRE>SCI_REPLACETARGETRE(int length, const char 
*text)</B><BR>This replaces the target using regular expressions. If 
<CODE>length</CODE> is -1, <CODE>text</CODE> is a zero terminated string, 
otherwise <CODE>length</CODE> is the number of characters to use. The 
replacement string is formed from the text string with any sequences of 
<CODE>\1</CODE> through <CODE>\9</CODE> replaced by tagged matches from the most 
recent regular expression search. After replacement, the target range refers to 
the replacement text. The return value is the length of the replacement 
string.</P>
<P>See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_FINDTEXT"><CODE>SCI_FINDTEXT</CODE></A></P>
<H2 id=Overtype>Overtype</H2>
<P><B id=SCI_SETOVERTYPE>SCI_SETOVERTYPE(bool overType)</B><BR><B 
id=SCI_GETOVERTYPE>SCI_GETOVERTYPE</B><BR>When overtype is enabled, each typed 
character replaces the character to the right of the text caret. When overtype 
is disabled, characters are inserted at the caret. <CODE>SCI_GETOVERTYPE</CODE> 
returns <CODE>TRUE</CODE> (1) if overtyping is active, otherwise 
<CODE>FALSE</CODE> (0) will be returned. Use <CODE>SCI_SETOVERTYPE</CODE> to set 
the overtype mode.</P>
<H2 id=CutCopyAndPaste>Cut, copy and paste</H2><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CUT">SCI_CUT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_COPY">SCI_COPY</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_PASTE">SCI_PASTE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CLEAR">SCI_CLEAR</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CANPASTE">SCI_CANPASTE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_COPYRANGE">SCI_COPYRANGE(int 
start, int end)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_COPYTEXT">SCI_COPYTEXT(int 
length, const char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETPASTECONVERTENDINGS">SCI_SETPASTECONVERTENDINGS(bool 
convert)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETPASTECONVERTENDINGS">SCI_GETPASTECONVERTENDINGS</A><BR></CODE>
<P><B id=SCI_CUT>SCI_CUT</B><BR><B id=SCI_COPY>SCI_COPY</B><BR><B 
id=SCI_PASTE>SCI_PASTE</B><BR><B id=SCI_CLEAR>SCI_CLEAR</B><BR><B 
id=SCI_CANPASTE>SCI_CANPASTE</B><BR>These commands perform the standard tasks of 
cutting and copying data to the clipboard, pasting from the clipboard into the 
document, and clearing the document. <CODE>SCI_CANPASTE</CODE> returns non-zero 
if the document isn't read-only and if the selection doesn't contain protected 
text. If you need a "can copy" or "can cut", use 
<CODE>SCI_GETSELECTIONSTART()-SCI_GETSELECTIONEND()</CODE>, which will be 
non-zero if you can copy or cut to the clipboard.</P>
<P>GTK+ does not really support <CODE>SCI_CANPASTE</CODE> and always returns 
<CODE>TRUE</CODE> unless the document is read-only.</P>
<P>On X, the clipboard is asynchronous and may require several messages between 
the destination and source applications. Data from SCI_PASTE will not arrive in 
the document immediately.</P><B id=SCI_COPYRANGE>SCI_COPYRANGE(int start, int 
end)</B><BR><B id=SCI_COPYTEXT>SCI_COPYTEXT(int length, const char 
*text)</B><BR>
<P><CODE>SCI_COPYRANGE</CODE> copies a range of text from the document to the 
system clipboard and <CODE>SCI_COPYTEXT</CODE> copies a supplied piece of text 
to the system clipboard.</P>
<P><B id=SCI_SETPASTECONVERTENDINGS>SCI_SETPASTECONVERTENDINGS(bool 
convert)</B><BR><B 
id=SCI_GETPASTECONVERTENDINGS>SCI_GETPASTECONVERTENDINGS</B><BR>If this property 
is set then when text is pasted any line ends are converted to match the 
document's end of line mode as set with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETEOLMODE">SCI_SETEOLMODE</A>. 
Currently only changeable on Windows. On GTK+ pasted text is always 
converted.</P>
<H2 id=ErrorHandling>Error handling</H2>
<P><B id=SCI_SETSTATUS>SCI_SETSTATUS(int status)</B><BR><B 
id=SCI_GETSTATUS>SCI_GETSTATUS</B><BR>If an error occurs, Scintilla may set an 
internal error number that can be retrieved with <CODE>SCI_GETSTATUS</CODE>. Not 
currently used but will be in the future. To clear the error status call 
<CODE>SCI_SETSTATUS(0)</CODE>.</P>
<H2 id=UndoAndRedo>Undo and Redo</H2>
<P>Scintilla has multiple level undo and redo. It will continue to collect 
undoable actions until memory runs out. Scintilla saves actions that change the 
document. Scintilla does not save caret and selection movements, view scrolling 
and the like. Sequences of typing or deleting are compressed into single actions 
to make it easier to undo and redo at a sensible level of detail. Sequences of 
actions can be combined into actions that are undone as a unit. These sequences 
occur between <CODE>SCI_BEGINUNDOACTION</CODE> and 
<CODE>SCI_ENDUNDOACTION</CODE> messages. These sequences can be nested and only 
the top-level sequences are undone as units.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_UNDO">SCI_UNDO</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CANUNDO">SCI_CANUNDO</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_REDO">SCI_REDO</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CANREDO">SCI_CANREDO</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETUNDOCOLLECTION">SCI_SETUNDOCOLLECTION(bool 
collectUndo)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETUNDOCOLLECTION">SCI_GETUNDOCOLLECTION</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_BEGINUNDOACTION">SCI_BEGINUNDOACTION</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ENDUNDOACTION">SCI_ENDUNDOACTION</A><BR></CODE>
<P><B id=SCI_UNDO>SCI_UNDO</B><BR><B 
id=SCI_CANUNDO>SCI_CANUNDO</B><BR><CODE>SCI_UNDO</CODE> undoes one action, or if 
the undo buffer has reached a <CODE>SCI_ENDUNDOACTION</CODE> point, all the 
actions back to the corresponding <CODE>SCI_BEGINUNDOACTION</CODE>.</P>
<P><CODE>SCI_CANUNDO</CODE> returns 0 if there is nothing to undo, and 1 if 
there is. You would typically use the result of this message to enable/disable 
the Edit menu Undo command.</P>
<P><B id=SCI_REDO>SCI_REDO</B><BR><B 
id=SCI_CANREDO>SCI_CANREDO</B><BR><CODE>SCI_REDO</CODE> undoes the effect of the 
last <CODE>SCI_UNDO</CODE> operation.</P>
<P><CODE>SCI_CANREDO</CODE> returns 0 if there is no action to redo and 1 if 
there are undo actions to redo. You could typically use the result of this 
message to enable/disable the Edit menu Redo command.</P>
<P><B id=SCI_EMPTYUNDOBUFFER>SCI_EMPTYUNDOBUFFER</B><BR>This command tells 
Scintilla to forget any saved undo or redo history. It also sets the save point 
to the start of the undo buffer, so the document will appear to be unmodified. 
This does not cause the <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</A></CODE> 
notification to be sent to the container.</P>
<P>See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSAVEPOINT"><CODE>SCI_SETSAVEPOINT</CODE></A></P>
<P><B id=SCI_SETUNDOCOLLECTION>SCI_SETUNDOCOLLECTION(bool collectUndo)</B><BR><B 
id=SCI_GETUNDOCOLLECTION>SCI_GETUNDOCOLLECTION</B><BR>You can control whether 
Scintilla collects undo information with <CODE>SCI_SETUNDOCOLLECTION</CODE>. 
Pass in <CODE>true</CODE> (1) to collect information and <CODE>false</CODE> (0) 
to stop collecting. If you stop collection, you should also use 
<CODE>SCI_EMPTYUNDOBUFFER</CODE> to avoid the undo buffer being unsynchronized 
with the data in the buffer.</P>
<P>You might wish to turn off saving undo information if you use the Scintilla 
to store text generated by a program (a Log view) or in a display window where 
text is often deleted and regenerated.</P>
<P><B id=SCI_BEGINUNDOACTION>SCI_BEGINUNDOACTION</B><BR><B 
id=SCI_ENDUNDOACTION>SCI_ENDUNDOACTION</B><BR>Send these two messages to 
Scintilla to mark the beginning and end of a set of operations that you want to 
undo all as one operation but that you have to generate as several operations. 
Alternatively, you can use these to mark a set of operations that you do not 
want to have combined with the preceding or following operations if they are 
undone.</P>
<H2 id=SelectionAndInformation>Selection and information</H2>
<P>Scintilla maintains a selection that stretches between two points, the anchor 
and the current position. If the anchor and the current position are the same, 
there is no selected text. Positions in the document range from 0 (before the 
first character), to the document size (after the last character). If you use 
messages, there is nothing to stop you setting a position that is in the middle 
of a CRLF pair, or in the middle of a 2 byte character. However, keyboard 
commands will not move the caret into such positions.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXTLENGTH">SCI_GETTEXTLENGTH</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLENGTH">SCI_GETLENGTH</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINECOUNT">SCI_GETLINECOUNT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETFIRSTVISIBLELINE">SCI_GETFIRSTVISIBLELINE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LINESONSCREEN">SCI_LINESONSCREEN</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMODIFY">SCI_GETMODIFY</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSEL">SCI_SETSEL(int 
anchorPos, int currentPos)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GOTOPOS">SCI_GOTOPOS(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GOTOLINE">SCI_GOTOLINE(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCURRENTPOS">SCI_SETCURRENTPOS(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCURRENTPOS">SCI_GETCURRENTPOS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETANCHOR">SCI_SETANCHOR(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETANCHOR">SCI_GETANCHOR</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSELECTIONSTART">SCI_SETSELECTIONSTART(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSELECTIONSTART">SCI_GETSELECTIONSTART</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSELECTIONEND">SCI_SETSELECTIONEND(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSELECTIONEND">SCI_GETSELECTIONEND</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SELECTALL">SCI_SELECTALL</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINEENDPOSITION">SCI_GETLINEENDPOSITION(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LINELENGTH">SCI_LINELENGTH(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCOLUMN">SCI_GETCOLUMN(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_FINDCOLUMN">SCI_FINDCOLUMN(int 
line, int column)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POSITIONFROMPOINT">SCI_POSITIONFROMPOINT(int 
x, int y)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE(int 
x, int y)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POINTXFROMPOSITION">SCI_POINTXFROMPOSITION(&lt;unused&gt;, 
int position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POINTYFROMPOSITION">SCI_POINTYFROMPOSITION(&lt;unused&gt;, 
int position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_HIDESELECTION">SCI_HIDESELECTION(bool 
hide)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSELTEXT">SCI_GETSELTEXT(&lt;unused&gt;, 
char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCURLINE">SCI_GETCURLINE(int 
textLen, char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SELECTIONISRECTANGLE">SCI_SELECTIONISRECTANGLE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSELECTIONMODE">SCI_SETSELECTIONMODE(int 
mode)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSELECTIONMODE">SCI_GETSELECTIONMODE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINESELSTARTPOSITION">SCI_GETLINESELSTARTPOSITION(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINESELENDPOSITION">SCI_GETLINESELENDPOSITION(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MOVECARETINSIDEVIEW">SCI_MOVECARETINSIDEVIEW</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_WORDENDPOSITION">SCI_WORDENDPOSITION(int 
position, bool onlyWordCharacters)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_WORDSTARTPOSITION">SCI_WORDSTARTPOSITION(int 
position, bool onlyWordCharacters)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POSITIONBEFORE">SCI_POSITIONBEFORE(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POSITIONAFTER">SCI_POSITIONAFTER(int 
position)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_TEXTWIDTH">SCI_TEXTWIDTH(int 
styleNumber, const char *text)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_TEXTHEIGHT">SCI_TEXTHEIGHT(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CHOOSECARETX">SCI_CHOOSECARETX</A><BR></CODE>
<P><B id=SCI_GETTEXTLENGTH>SCI_GETTEXTLENGTH</B><BR><B 
id=SCI_GETLENGTH>SCI_GETLENGTH</B><BR>Both these messages return the length of 
the document in characters.</P>
<P><B id=SCI_GETLINECOUNT>SCI_GETLINECOUNT</B><BR>This returns the number of 
lines in the document. An empty document contains 1 line. A document holding 
only an end of line sequence has 2 lines.</P>
<P><B id=SCI_GETFIRSTVISIBLELINE>SCI_GETFIRSTVISIBLELINE</B><BR>This returns the 
line number of the first visible line in the Scintilla view. The first line in 
the document is numbered 0.</P>
<P><B id=SCI_LINESONSCREEN>SCI_LINESONSCREEN</B><BR>This returns the number of 
complete lines visible on the screen. With a constant line height, this is the 
vertical space available divided by the line separation. Unless you arrange to 
size your window to an integral number of lines, there may be a partial line 
visible at the bottom of the view.</P>
<P><B id=SCI_GETMODIFY>SCI_GETMODIFY</B><BR>This returns non-zero if the 
document is modified and 0 if it is unmodified. The modified status of a 
document is determined by the undo position relative to the save point. The save 
point is set by <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSAVEPOINT"><CODE>SCI_SETSAVEPOINT</CODE></A>, 
usually when you have saved data to a file.</P>
<P>If you need to be notified when the document becomes modified, Scintilla 
notifies the container that it has entered or left the save point with the <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_SAVEPOINTREACHED"><CODE>SCN_SAVEPOINTREACHED</CODE></A> 
and <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_SAVEPOINTLEFT"><CODE>SCN_SAVEPOINTLEFT</CODE></A> 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">notification 
messages</A>.</P>
<P><B id=SCI_SETSEL>SCI_SETSEL(int anchorPos, int currentPos)</B><BR>This 
message sets both the anchor and the current position. If 
<CODE>currentPos</CODE> is negative, it means the end of the document. If 
<CODE>anchorPos</CODE> is negative, it means remove any selection (i.e. set the 
anchor to the same position as <CODE>currentPos</CODE>). The caret is scrolled 
into view after this operation.</P>
<P><B id=SCI_GOTOPOS>SCI_GOTOPOS(int pos)</B><BR>This removes any selection, 
sets the caret at <CODE>pos</CODE> and scrolls the view to make the caret 
visible, if necessary. It is equivalent to <CODE>SCI_SETSEL(pos, pos)</CODE>. 
The anchor position is set the same as the current position.</P>
<P><B id=SCI_GOTOLINE>SCI_GOTOLINE(int line)</B><BR>This removes any selection 
and sets the caret at the start of line number <CODE>line</CODE> and scrolls the 
view (if needed) to make it visible. The anchor position is set the same as the 
current position. If <CODE>line</CODE> is outside the lines in the document 
(first line is 0), the line set is the first or last.</P>
<P><B id=SCI_SETCURRENTPOS>SCI_SETCURRENTPOS(int pos)</B><BR>This sets the 
current position and creates a selection between the anchor and the current 
position. The caret is not scrolled into view.</P>
<P>See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SCROLLCARET"><CODE>SCI_SCROLLCARET</CODE></A></P>
<P><B id=SCI_GETCURRENTPOS>SCI_GETCURRENTPOS</B><BR>This returns the current 
position.</P>
<P><B id=SCI_SETANCHOR>SCI_SETANCHOR(int pos)</B><BR>This sets the anchor 
position and creates a selection between the anchor position and the current 
position. The caret is not scrolled into view.</P>
<P>See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SCROLLCARET"><CODE>SCI_SCROLLCARET</CODE></A></P>
<P><B id=SCI_GETANCHOR>SCI_GETANCHOR</B><BR>This returns the current anchor 
position.</P>
<P><B id=SCI_SETSELECTIONSTART>SCI_SETSELECTIONSTART(int pos)</B><BR><B 
id=SCI_SETSELECTIONEND>SCI_SETSELECTIONEND(int pos)</B><BR>These set the 
selection based on the assumption that the anchor position is less than the 
current position. They do not make the caret visible. The table shows the 
positions of the anchor and the current position after using these messages.</P>
<TABLE cellSpacing=0 cellPadding=3 summary="SetSelection caret positioning" 
border=1>
  <THEAD align=middle>
  <TR>
    <TH></TH>
    <TH>anchor</TH>
    <TH>current</TH></TR></THEAD>
  <TBODY align=middle>
  <TR>
    <TH><CODE>SCI_SETSELECTIONSTART</CODE></TH>
    <TD><CODE>pos</CODE></TD>
    <TD><CODE>Max(pos, current)</CODE></TD></TR>
  <TR>
    <TH><CODE>SCI_SETSELECTIONEND</CODE></TH>
    <TD><CODE>Min(anchor, pos)</CODE></TD>
    <TD><CODE>pos</CODE></TD></TR></TBODY></TABLE>
<P>See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SCROLLCARET"><CODE>SCI_SCROLLCARET</CODE></A></P>
<P><B id=SCI_GETSELECTIONSTART>SCI_GETSELECTIONSTART</B><BR><B 
id=SCI_GETSELECTIONEND>SCI_GETSELECTIONEND</B><BR>These return the start and end 
of the selection without regard to which end is the current position and which 
is the anchor. <CODE>SCI_GETSELECTIONSTART</CODE> returns the smaller of the 
current position or the anchor position. <CODE>SCI_GETSELECTIONEND</CODE> 
returns the larger of the two values.</P>
<P><B id=SCI_SELECTALL>SCI_SELECTALL</B><BR>This selects all the text in the 
document. The current position is not scrolled into view.</P>
<P><B id=SCI_LINEFROMPOSITION>SCI_LINEFROMPOSITION(int pos)</B><BR>This message 
returns the line that contains the position <CODE>pos</CODE> in the document. 
The return value is 0 if <CODE>pos</CODE> &lt;= 0. The return value is the last 
line if <CODE>pos</CODE> is beyond the end of the document.</P>
<P><B id=SCI_POSITIONFROMLINE>SCI_POSITIONFROMLINE(int line)</B><BR>This returns 
the document position that corresponds with the start of the line. If 
<CODE>line</CODE> is negative, the position of the line holding the start of the 
selection is returned. If <CODE>line</CODE> is greater than the lines in the 
document, the return value is -1. If <CODE>line</CODE> is equal to the number of 
lines in the document (i.e. 1 line past the last line), the return value is the 
end of the document.</P>
<P><B id=SCI_GETLINEENDPOSITION>SCI_GETLINEENDPOSITION(int line)</B><BR>This 
returns the position at the end of the line, before any line end characters. If 
<CODE>line</CODE> is the last line in the document (which does not have any end 
of line characters), the result is the size of the document. If 
<CODE>line</CODE> is negative or <CODE>line</CODE> &gt;= <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINECOUNT"><CODE>SCI_GETLINECOUNT()</CODE></A>, 
the result is undefined.</P>
<P><B id=SCI_LINELENGTH>SCI_LINELENGTH(int line)</B><BR>This returns the length 
of the line, including any line end characters. If <CODE>line</CODE> is negative 
or beyond the last line in the document, the result is 0. If you want the length 
of the line not including any end of line characters, use <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINEENDPOSITION"><CODE>SCI_GETLINEENDPOSITION(line)</CODE></A> 
- <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POSITIONFROMLINE"><CODE>SCI_POSITIONFROMLINE(line)</CODE></A>.</P><B 
id=SCI_GETSELTEXT>SCI_GETSELTEXT(&lt;unused&gt;, char *text)</B><BR>This copies 
the currently selected text and a terminating 0 byte to the <CODE>text</CODE> 
buffer. The buffer must be at least 
<CODE>SCI_GETSELECTIONEND()-SCI_GETSELECTIONSTART()+1</CODE> bytes long. <BR>If 
the text argument is 0 then the length that should be allocated to store the 
entire selection is returned.<BR>
<P>See also: <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCURLINE">SCI_GETCURLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINE">SCI_GETLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXT">SCI_GETTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</A></CODE></P>
<P><B id=SCI_GETCURLINE>SCI_GETCURLINE(int textLen, char *text)</B><BR>This 
retrieves the text of the line containing the caret and returns the position 
within the line of the caret. Pass in <CODE>char* text</CODE> pointing at a 
buffer large enough to hold the text you wish to retrieve and a terminating 0 
character. Set <CODE>textLen</CODE> to the length of the buffer which must be at 
least 1 to hold the terminating 0 character. If the text argument is 0 then the 
length that should be allocated to store the entire current line is 
returned.</P>
<P>See also: <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSELTEXT">SCI_GETSELTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINE">SCI_GETLINE</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXT">SCI_GETTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</A></CODE></P>
<P><B id=SCI_SELECTIONISRECTANGLE>SCI_SELECTIONISRECTANGLE</B><BR>This returns 1 
if the current selection is in rectangle mode, 0 if not.</P>
<P><B id=SCI_SETSELECTIONMODE>SCI_SETSELECTIONMODE(int mode)</B><BR><B 
id=SCI_GETSELECTIONMODE>SCI_GETSELECTIONMODE</B><BR>The two functions set and 
get the selection mode, which can be stream (<CODE>SC_SEL_STREAM</CODE>=0) or 
rectangular (<CODE>SC_SEL_RECTANGLE</CODE>=1) or by lines 
(<CODE>SC_SEL_LINES</CODE>=2). When set in these modes, regular caret moves will 
extend or reduce the selection, until the mode is cancelled by a call with same 
value or with <CODE>SCI_CANCEL</CODE>. The get function returns the current mode 
even if the selection was made by mouse or with regular extended moves.</P>
<P><B id=SCI_GETLINESELSTARTPOSITION>SCI_GETLINESELSTARTPOSITION(int 
line)</B><BR><B id=SCI_GETLINESELENDPOSITION>SCI_GETLINESELENDPOSITION(int 
line)</B><BR>Retrieve the position of the start and end of the selection at the 
given line with INVALID_POSITION returned if no selection on this line.</P>
<P><B id=SCI_MOVECARETINSIDEVIEW>SCI_MOVECARETINSIDEVIEW</B><BR>If the caret is 
off the top or bottom of the view, it is moved to the nearest line that is 
visible to its current position. Any selection is lost.</P>
<P><B id=SCI_WORDENDPOSITION>SCI_WORDENDPOSITION(int position, bool 
onlyWordCharacters)</B><BR><B id=SCI_WORDSTARTPOSITION>SCI_WORDSTARTPOSITION(int 
position, bool onlyWordCharacters)</B><BR>These messages return the start and 
end of words using the same definition of words as used internally within 
Scintilla. You can set your own list of characters that count as words with <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETWORDCHARS"><CODE>SCI_SETWORDCHARS</CODE></A>. 
The position sets the start or the search, which is forwards when searching for 
the end and backwards when searching for the start.</P>
<P>Set <CODE>onlyWordCharacters</CODE> to <CODE>true</CODE> (1) to stop 
searching at the first non-word character in the search direction. If 
<CODE>onlyWordCharacters</CODE> is <CODE>false</CODE> (0), the first character 
in the search direction sets the type of the search as word or non-word and the 
search stops at the first non-matching character. Searches are also terminated 
by the start or end of the document.</P>
<P>If "w" represents word characters and "." represents non-word characters and 
"|" represents the position and <CODE>true</CODE> or <CODE>false</CODE> is the 
state of <CODE>onlyWordCharacters</CODE>:</P>
<TABLE cellSpacing=0 cellPadding=3 summary="Word start and end positions" 
border=1>
  <THEAD align=middle>
  <TR>
    <TH>Initial state</TH>
    <TH>end, true</TH>
    <TH>end, false</TH>
    <TH>start, true</TH>
    <TH>start, false</TH></TR></THEAD>
  <TBODY align=middle>
  <TR>
    <TD>..ww..|..ww..</TD>
    <TD>..ww..|..ww..</TD>
    <TD>..ww....|ww..</TD>
    <TD>..ww..|..ww..</TD>
    <TD>..ww|....ww..</TD></TR>
  <TR>
    <TD>....ww|ww....</TD>
    <TD>....wwww|....</TD>
    <TD>....wwww|....</TD>
    <TD>....|wwww....</TD>
    <TD>....|wwww....</TD></TR>
  <TR>
    <TD>..ww|....ww..</TD>
    <TD>..ww|....ww..</TD>
    <TD>..ww....|ww..</TD>
    <TD>..|ww....ww..</TD>
    <TD>..|ww....ww..</TD></TR>
  <TR>
    <TD>..ww....|ww..</TD>
    <TD>..ww....ww|..</TD>
    <TD>..ww....ww|..</TD>
    <TD>..ww....|ww..</TD>
    <TD>..ww|....ww..</TD></TR></TBODY></TABLE>
<P><B id=SCI_POSITIONBEFORE>SCI_POSITIONBEFORE(int position)</B><BR><B 
id=SCI_POSITIONAFTER>SCI_POSITIONAFTER(int position)</B><BR>These messages 
return the position before and after another position in the document taking 
into account the current code page. The minimum position returned is 0 and the 
maximum is the last position in the document. If called with a position within a 
multi byte character will return the position of the start/end of that 
character.</P>
<P><B id=SCI_TEXTWIDTH>SCI_TEXTWIDTH(int styleNumber, const char 
*text)</B><BR>This returns the pixel width of a string drawn in the given 
<CODE>styleNumber</CODE> which can be used, for example, to decide how wide to 
make the line number margin in order to display a given number of numerals.</P>
<P><B id=SCI_TEXTHEIGHT>SCI_TEXTHEIGHT(int line)</B><BR>This returns the height 
in pixels of a particular line. Currently all lines are the same height.</P>
<P><B id=SCI_GETCOLUMN>SCI_GETCOLUMN(int pos)</B><BR>This message returns the 
column number of a position <CODE>pos</CODE> within the document taking the 
width of tabs into account. This returns the column number of the last tab on 
the line before <CODE>pos</CODE>, plus the number of characters between the last 
tab and <CODE>pos</CODE>. If there are no tab characters on the line, the return 
value is the number of characters up to the position on the line. In both cases, 
double byte characters count as a single character. This is probably only useful 
with monospaced fonts.</P>
<P><B id=SCI_FINDCOLUMN>SCI_FINDCOLUMN(int line, int column)</B><BR>This message 
returns the position of a <CODE>column</CODE> on a <CODE>line</CODE> taking the 
width of tabs into account. It treats a multi-byte character as a single column. 
Column numbers, like lines start at 0.</P>
<P><B id=SCI_POSITIONFROMPOINT>SCI_POSITIONFROMPOINT(int x, int y)</B><BR><B 
id=SCI_POSITIONFROMPOINTCLOSE>SCI_POSITIONFROMPOINTCLOSE(int x, int 
y)</B><BR><CODE>SCI_POSITIONFROMPOINT</CODE> finds the closest character 
position to a point and <CODE>SCI_POSITIONFROMPOINTCLOSE</CODE> is similar but 
returns -1 if the point is outside the window or not close to any 
characters.</P>
<P><B id=SCI_POINTXFROMPOSITION>SCI_POINTXFROMPOSITION(&lt;unused&gt;, int 
pos)</B><BR><B id=SCI_POINTYFROMPOSITION>SCI_POINTYFROMPOSITION(&lt;unused&gt;, 
int pos)</B><BR>These messages return the x and y display pixel location of text 
at position <CODE>pos</CODE> in the document.</P>
<P><B id=SCI_HIDESELECTION>SCI_HIDESELECTION(bool hide)</B><BR>The normal state 
is to make the selection visible by drawing it as set by <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSELFORE"><CODE>SCI_SETSELFORE</CODE></A> 
and <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSELBACK"><CODE>SCI_SETSELBACK</CODE></A>. 
However, if you hide the selection, it is drawn as normal text.</P>
<P><B id=SCI_CHOOSECARETX>SCI_CHOOSECARETX</B><BR>Scintilla remembers the x 
value of the last position horizontally moved to explicitly by the user and this 
value is then used when moving vertically such as by using the up and down keys. 
This message sets the current x position of the caret as the remembered 
value.</P>
<H2 id=ScrollingAndAutomaticScrolling>Scrolling and automatic 
scrolling</H2><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LINESCROLL">SCI_LINESCROLL(int 
column, int line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SCROLLCARET">SCI_SCROLLCARET</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETXCARETPOLICY">SCI_SETXCARETPOLICY(int 
caretPolicy, int caretSlop)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETYCARETPOLICY">SCI_SETYCARETPOLICY(int 
caretPolicy, int caretSlop)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETVISIBLEPOLICY">SCI_SETVISIBLEPOLICY(int 
caretPolicy, int caretSlop)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETHSCROLLBAR">SCI_SETHSCROLLBAR(bool 
visible)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETHSCROLLBAR">SCI_GETHSCROLLBAR</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETVSCROLLBAR">SCI_SETVSCROLLBAR(bool 
visible)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETVSCROLLBAR">SCI_GETVSCROLLBAR</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETXOFFSET">SCI_GETXOFFSET</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETXOFFSET">SCI_SETXOFFSET(int 
xOffset)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH(int 
pixelWidth)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSCROLLWIDTH">SCI_GETSCROLLWIDTH</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETENDATLASTLINE">SCI_SETENDATLASTLINE(bool 
endAtLastLine)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETENDATLASTLINE">SCI_GETENDATLASTLINE</A><BR></CODE>
<P><B id=SCI_LINESCROLL>SCI_LINESCROLL(int column, int line)</B><BR>This will 
attempt to scroll the display by the number of columns and lines that you 
specify. Positive line values increase the line number at the top of the screen 
(i.e. they move the text upwards as far as the user is concerned), Negative line 
values do the reverse.</P>
<P>The column measure is the width of a space in the default style. Positive 
values increase the column at the left edge of the view (i.e. they move the text 
leftwards as far as the user is concerned). Negative values do the reverse.</P>
<P>See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETXOFFSET"><CODE>SCI_SETXOFFSET</CODE></A></P>
<P><B id=SCI_SCROLLCARET>SCI_SCROLLCARET</B><BR>If the current position (this is 
the caret if there is no selection) is not visible, the view is scrolled to make 
it visible according to the current caret policy.</P>
<P><B id=SCI_SETXCARETPOLICY>SCI_SETXCARETPOLICY(int caretPolicy, int 
caretSlop)</B><BR><B id=SCI_SETYCARETPOLICY>SCI_SETYCARETPOLICY(int caretPolicy, 
int caretSlop)</B><BR>These set the caret policy. The value of 
<CODE>caretPolicy</CODE> is a combination of <CODE>CARET_SLOP</CODE>, 
<CODE>CARET_STRICT</CODE>, <CODE>CARET_JUMPS</CODE> and 
<CODE>CARET_EVEN</CODE>.</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Caret policy" border=0>
  <TBODY vAlign=top>
  <TR>
    <TH align=left><CODE>CARET_SLOP</CODE></TH>
    <TD>If set, we can define a slop value: <CODE>caretSlop</CODE>. This value 
      defines an unwanted zone (UZ) where the caret is... unwanted. This zone is 
      defined as a number of pixels near the vertical margins, and as a number 
      of lines near the horizontal margins. By keeping the caret away from the 
      edges, it is seen within its context. This makes it likely that the 
      identifier that the caret is on can be completely seen, and that the 
      current line is seen with some of the lines following it, which are often 
      dependent on that line.</TD></TR>
  <TR>
    <TH align=left><CODE>CARET_STRICT</CODE></TH>
    <TD>If set, the policy set by <CODE>CARET_SLOP</CODE> is enforced... 
      strictly. The caret is centred on the display if <CODE>caretSlop</CODE> is 
      not set, and cannot go in the UZ if <CODE>caretSlop</CODE> is set.</TD></TR>
  <TR>
    <TH align=left><CODE>CARET_JUMPS</CODE></TH>
    <TD>If set, the display is moved more energetically so the caret can move 
      in the same direction longer before the policy is applied again. '3UZ' 
      notation is used to indicate three time the size of the UZ as a distance 
      to the margin.</TD></TR>
  <TR>
    <TH align=left><CODE>CARET_EVEN</CODE></TH>
    <TD>If not set, instead of having symmetrical UZs, the left and bottom UZs 
      are extended up to right and top UZs respectively. This way, we favour the 
      displaying of useful information: the beginning of lines, where most code 
      reside, and the lines after the caret, for example, the body of a 
    function.</TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=3 summary="Caret positioning" border=1>
  <THEAD align=middle>
  <TR>
    <TH>slop</TH>
    <TH>strict</TH>
    <TH>jumps</TH>
    <TH>even</TH>
    <TH>Caret can go to the margin</TH>
    <TH>On reaching limit (going out of visibility<BR>or going into the UZ) 
      display is...</TH></TR></THEAD>
  <TBODY align=middle>
  <TR>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>Yes</TD>
    <TD>moved to put caret on top/on right</TD></TR>
  <TR>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>1</TD>
    <TD>Yes</TD>
    <TD>moved by one position</TD></TR>
  <TR>
    <TD>0</TD>
    <TD>0</TD>
    <TD>1</TD>
    <TD>0</TD>
    <TD>Yes</TD>
    <TD>moved to put caret on top/on right</TD></TR>
  <TR>
    <TD>0</TD>
    <TD>0</TD>
    <TD>1</TD>
    <TD>1</TD>
    <TD>Yes</TD>
    <TD>centred on the caret</TD></TR>
  <TR>
    <TD>0</TD>
    <TD>1</TD>
    <TD>-</TD>
    <TD>0</TD>
    <TD>Caret is always on top/on right of display</TD>
    <TD>-</TD></TR>
  <TR>
    <TD>0</TD>
    <TD>1</TD>
    <TD>-</TD>
    <TD>1</TD>
    <TD>No, caret is always centred</TD>
    <TD>-</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>Yes</TD>
    <TD>moved to put caret out of the asymmetrical UZ</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>1</TD>
    <TD>Yes</TD>
    <TD>moved to put caret out of the UZ</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>0</TD>
    <TD>1</TD>
    <TD>0</TD>
    <TD>Yes</TD>
    <TD>moved to put caret at 3UZ of the top or right margin</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>0</TD>
    <TD>1</TD>
    <TD>1</TD>
    <TD>Yes</TD>
    <TD>moved to put caret at 3UZ of the margin</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>1</TD>
    <TD>-</TD>
    <TD>0</TD>
    <TD>Caret is always at UZ of top/right margin</TD>
    <TD>-</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>1</TD>
    <TD>0</TD>
    <TD>1</TD>
    <TD>No, kept out of UZ</TD>
    <TD>moved by one position</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>1</TD>
    <TD>1</TD>
    <TD>0</TD>
    <TD>No, kept out of UZ</TD>
    <TD>moved to put caret at 3UZ of the margin</TD></TR></TBODY></TABLE>
<P><B id=SCI_SETVISIBLEPOLICY>SCI_SETVISIBLEPOLICY(int caretPolicy, int 
caretSlop)</B><BR>This determines how the vertical positioning is determined 
when <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ENSUREVISIBLEENFORCEPOLICY"><CODE>SCI_ENSUREVISIBLEENFORCEPOLICY</CODE></A> 
is called. It takes <CODE>VISIBLE_SLOP</CODE> and <CODE>VISIBLE_STRICT</CODE> 
flags for the policy parameter. It is similar in operation to <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETYCARETPOLICY"><CODE>SCI_SETYCARETPOLICY(int 
caretPolicy, int caretSlop)</CODE></A>.</P>
<P><B id=SCI_SETHSCROLLBAR>SCI_SETHSCROLLBAR(bool visible)</B><BR><B 
id=SCI_GETHSCROLLBAR>SCI_GETHSCROLLBAR</B><BR>The horizontal scroll bar is only 
displayed if it is needed for the assumed width. If you never wish to see it, 
call <CODE>SCI_SETHSCROLLBAR(0)</CODE>. Use <CODE>SCI_SETHSCROLLBAR(1)</CODE> to 
enable it again. <CODE>SCI_GETHSCROLLBAR</CODE> returns the current state. The 
default state is to display it when needed. See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH</A>.</P>
<P><B id=SCI_SETVSCROLLBAR>SCI_SETVSCROLLBAR(bool visible)</B><BR><B 
id=SCI_GETVSCROLLBAR>SCI_GETVSCROLLBAR</B><BR>By default, the vertical scroll 
bar is always displayed when required. You can choose to hide or show it with 
<CODE>SCI_SETVSCROLLBAR</CODE> and get the current state with 
<CODE>SCI_GETVSCROLLBAR</CODE>.</P>
<P><B id=SCI_SETXOFFSET>SCI_SETXOFFSET(int xOffset)</B><BR><B 
id=SCI_GETXOFFSET>SCI_GETXOFFSET</B><BR>The <CODE>xOffset</CODE> is the 
horizontal scroll position in pixels of the start of the text view. A value of 0 
is the normal position with the first text column visible at the left of the 
view.</P>
<P>See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LINESCROLL"><CODE>SCI_LINESCROLL</CODE></A></P>
<P><B id=SCI_SETSCROLLWIDTH>SCI_SETSCROLLWIDTH(int pixelWidth)</B><BR><B 
id=SCI_GETSCROLLWIDTH>SCI_GETSCROLLWIDTH</B><BR>For performance, Scintilla does 
not measure the display width of the document to determine the properties of the 
horizontal scroll bar. Instead, an assumed width is used. These messages set and 
get the document width in pixels assumed by Scintilla. The default value is 
2000.</P>
<P><B id=SCI_SETENDATLASTLINE>SCI_SETENDATLASTLINE(bool endAtLastLine)</B><BR><B 
id=SCI_GETENDATLASTLINE>SCI_GETENDATLASTLINE</B><BR><CODE>SCI_SETENDATLASTLINE</CODE> 
sets the scroll range so that maximum scroll position has the last line at the 
bottom of the view (default). Setting this to <CODE>false</CODE> allows 
scrolling one page below the last line.</P>
<H2 id=WhiteSpace>White space</H2><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETVIEWWS">SCI_SETVIEWWS(int 
wsMode)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETVIEWWS">SCI_GETVIEWWS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETWHITESPACEFORE">SCI_SETWHITESPACEFORE(bool 
useWhitespaceForeColour, int colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETWHITESPACEBACK">SCI_SETWHITESPACEBACK(bool 
useWhitespaceBackColour, int colour)</A><BR></CODE>
<P><B id=SCI_SETVIEWWS>SCI_SETVIEWWS(int wsMode)</B><BR><B 
id=SCI_GETVIEWWS>SCI_GETVIEWWS</B><BR>White space can be made visible which may 
useful for languages in which white space is significant, such as Python. Space 
characters appear as small centred dots and tab characters as light arrows 
pointing to the right. There are also ways to control the display of <A 
class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#LineEndings">end of 
line characters</A>. The two messages set and get the white space display mode. 
The <CODE>wsMode</CODE> argument can be one of:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="White space policy" border=0>
  <TBODY vAlign=top>
  <TR>
    <TH align=left><CODE>SCWS_INVISIBLE</CODE></TH>
    <TD>0</TD>
    <TD>The normal display mode with white space displayed as an empty 
      background colour.</TD></TR>
  <TR>
    <TH align=left><CODE>SCWS_VISIBLEALWAYS</CODE></TH>
    <TD>1</TD>
    <TD>White space characters are drawn as dots and arrows,</TD></TR>
  <TR>
    <TH align=left><CODE>SCWS_VISIBLEAFTERINDENT</CODE></TH>
    <TD>2</TD>
    <TD>White space used for indentation is displayed normally but after the 
      first visible character, it is shown as dots and 
arrows.</TD></TR></TBODY></TABLE>
<P>The effect of using any other <CODE>wsMode</CODE> value is undefined.</P>
<P><B id=SCI_SETWHITESPACEFORE>SCI_SETWHITESPACEFORE&lt;(bool 
useWhitespaceForeColour, int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_SETWHITESPACEBACK>SCI_SETWHITESPACEBACK(bool useWhitespaceBackColour, int 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR>By 
default, the colour of visible white space is determined by the lexer in use. 
The foreground and/or background colour of all visible white space can be set 
globally, overriding the lexer's colours with <CODE>SCI_SETWHITESPACEFORE</CODE> 
and <CODE>SCI_SETWHITESPACEBACK</CODE>.</P>
<H2 id=Cursor>Cursor</H2>
<P><B id=SCI_SETCURSOR>SCI_SETCURSOR(int curType)</B><BR><B 
id=SCI_GETCURSOR>SCI_GETCURSOR</B><BR>The cursor is normally chosen in a context 
sensitive way, so it will be different over the margin than when over the text. 
When performing a slow action, you may wish to change to a wait cursor. You set 
the cursor type with <CODE>SCI_SETCURSOR</CODE>. The <CODE>curType</CODE> 
argument can be:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Mouse cursors" border=0>
  <TBODY vAlign=top>
  <TR>
    <TH align=left><CODE>SC_CURSORNORMAL</CODE></TH>
    <TD>-1</TD>
    <TD>The normal cursor is displayed.</TD></TR>
  <TR>
    <TH align=left><CODE>SC_CURSORWAIT</CODE></TH>
    <TD>&nbsp;4</TD>
    <TD>The wait cursor is displayed when the mouse is over or owned by the 
      Scintilla window.</TD></TR></TBODY></TABLE>
<P>Cursor values 1 through 7 have defined cursors, but only 
<CODE>SC_CURSORWAIT</CODE> is usefully controllable. Other values of 
<CODE>curType</CODE> cause a pointer to be displayed. The 
<CODE>SCI_GETCURSOR</CODE> message returns the last cursor type you set, or 
<CODE>SC_CURSORNORMAL</CODE> (-1) if you have not set a cursor type.</P>
<H2 id=MouseCapture>Mouse capture</H2>
<P><B id=SCI_SETMOUSEDOWNCAPTURES>SCI_SETMOUSEDOWNCAPTURES(bool 
captures)</B><BR><B 
id=SCI_GETMOUSEDOWNCAPTURES>SCI_GETMOUSEDOWNCAPTURES</B><BR>When the mouse is 
pressed inside Scintilla, it is captured so future mouse movement events are 
sent to Scintilla. This behavior may be turned off with 
<CODE>SCI_SETMOUSEDOWNCAPTURES(0)</CODE>.</P>
<H2 id=LineEndings>Line endings</H2>
<P>Scintilla can interpret any of the three major line end conventions, 
Macintosh (\r), Unix (\n) and CP/M / DOS / Windows (\r\n). When the user presses 
the Enter key, one of these line end strings is inserted into the buffer. The 
default is \r\n in Windows and \n in Unix, but this can be changed with the 
<CODE>SCI_SETEOLMODE</CODE> message. You can also convert the entire document to 
one of these line endings with <CODE>SCI_CONVERTEOLS</CODE>. Finally, you can 
choose to display the line endings with <CODE>SCI_SETVIEWEOL</CODE>.</P><CODE><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETEOLMODE">SCI_SETEOLMODE(int 
eolMode)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETEOLMODE">SCI_GETEOLMODE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CONVERTEOLS">SCI_CONVERTEOLS(int 
eolMode)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETVIEWEOL">SCI_SETVIEWEOL(bool 
visible)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETVIEWEOL">SCI_GETVIEWEOL</A><BR></CODE>
<P><B id=SCI_SETEOLMODE>SCI_SETEOLMODE(int eolMode)</B><BR><B 
id=SCI_GETEOLMODE>SCI_GETEOLMODE</B><BR><CODE>SCI_SETEOLMODE</CODE> sets the 
characters that are added into the document when the user presses the Enter key. 
You can set <CODE>eolMode</CODE> to one of <CODE>SC_EOL_CRLF</CODE> (0), 
<CODE>SC_EOL_CR</CODE> (1), or <CODE>SC_EOL_LF</CODE> (2). The 
<CODE>SCI_GETEOLMODE</CODE> message retrieves the current state.</P>
<P><B id=SCI_CONVERTEOLS>SCI_CONVERTEOLS(int eolMode)</B><BR>This message 
changes all the end of line characters in the document to match 
<CODE>eolMode</CODE>. Valid values are: <CODE>SC_EOL_CRLF</CODE> (0), 
<CODE>SC_EOL_CR</CODE> (1), or <CODE>SC_EOL_LF</CODE> (2).</P>
<P><B id=SCI_SETVIEWEOL>SCI_SETVIEWEOL(bool visible)</B><BR><B 
id=SCI_GETVIEWEOL>SCI_GETVIEWEOL</B><BR>Normally, the end of line characters are 
hidden, but <CODE>SCI_SETVIEWEOL</CODE> allows you to display (or hide) them by 
setting <CODE>visible</CODE> <CODE>true</CODE> (or <CODE>false</CODE>). The 
visible rendering of the end of line characters is similar to <CODE>(CR)</CODE>, 
<CODE>(LF)</CODE>, or <CODE>(CR)(LF)</CODE>. <CODE>SCI_GETVIEWEOL</CODE> returns 
the current state.</P>
<H2 id=Styling>Styling</H2>
<P>The styling messages allow you to assign styles to text. The standard 
Scintilla settings divide the 8 style bits available for each character into 5 
bits (0 to 4 = <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition">styles 
0 to 31</A>) that set a style and three bits (5 to 7) that define <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Indicators">indicators</A>. 
You can change the balance between styles and indicators with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLEBITS"><CODE>SCI_SETSTYLEBITS</CODE></A>. 
If your styling needs can be met by one of the standard lexers, or if you can 
write your own, then a lexer is probably the easiest way to style your document. 
If you choose to use the container to do the styling you can use the <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETLEXER"><CODE>SCI_SETLEXER</CODE></A> 
command to select <CODE>SCLEX_CONTAINER</CODE>, in which case the container is 
sent a <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_STYLENEEDED"><CODE>SCN_STYLENEEDED</CODE></A> 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">notification</A> 
each time text needs styling for display. As another alternative, you might use 
idle time to style the document. Even if you use a lexer, you might use the 
styling commands to mark errors detected by a compiler. The following commands 
can be used.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETENDSTYLED">SCI_GETENDSTYLED</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STARTSTYLING">SCI_STARTSTYLING(int 
position, int mask)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLING">SCI_SETSTYLING(int 
length, int style)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLINGEX">SCI_SETSTYLINGEX(int 
length, const char *styles)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETLINESTATE">SCI_SETLINESTATE(int 
line, int value)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINESTATE">SCI_GETLINESTATE(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMAXLINESTATE">SCI_GETMAXLINESTATE</A><BR></CODE>
<P><B id=SCI_GETENDSTYLED>SCI_GETENDSTYLED</B><BR>Scintilla keeps a record of 
the last character that is likely to be styled correctly. This is moved forwards 
when characters after it are styled and moved backwards if changes are made to 
the text of the document before it. Before drawing text, this position is 
checked to see if any styling is needed and, if so, a <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_STYLENEEDED">SCN_STYLENEEDED</A></CODE> 
notification message is sent to the container. The container can send 
<CODE>SCI_GETENDSTYLED</CODE> to work out where it needs to start styling. 
Scintilla will always ask to style whole lines.</P>
<P><B id=SCI_STARTSTYLING>SCI_STARTSTYLING(int pos, int mask)</B><BR>This 
prepares for styling by setting the styling position <CODE>pos</CODE> to start 
at and a <CODE>mask</CODE> indicating which bits of the style bytes can be set. 
The mask allows styling to occur over several passes, with, for example, basic 
styling done on an initial pass to ensure that the text of the code is seen 
quickly and correctly, and then a second slower pass, detecting syntax errors 
and using indicators to show where these are. For example, with the standard 
settings of 5 style bits and 3 indicator bits, you would use a <CODE>mask</CODE> 
value of 31 (0x1f) if you were setting text styles and did not want to change 
the indicators. After <CODE>SCI_STARTSTYLING</CODE>, send multiple 
<CODE>SCI_SETSTYLING</CODE> messages for each lexical entity to style.</P>
<P><B id=SCI_SETSTYLING>SCI_SETSTYLING(int length, int style)</B><BR>This 
message sets the style of <CODE>length</CODE> characters starting at the styling 
position and then increases the styling position by <CODE>length</CODE>, ready 
for the next call. If <CODE>sCell</CODE> is the style byte, the operation 
is:<BR><CODE>if ((sCell &amp; mask) != style) sCell = (sCell &amp; ~mask) | 
(style &amp; mask);</CODE><BR></P>
<P><B id=SCI_SETSTYLINGEX>SCI_SETSTYLINGEX(int length, const char 
*styles)</B><BR>As an alternative to <CODE>SCI_SETSTYLING</CODE>, which applies 
the same style to each byte, you can use this message which specifies the styles 
for each of <CODE>length</CODE> bytes from the styling position and then 
increases the styling position by <CODE>length</CODE>, ready for the next call. 
The <CODE>length</CODE> styling bytes pointed at by <CODE>styles</CODE> should 
not contain any bits not set in mask.</P>
<P><B id=SCI_SETLINESTATE>SCI_SETLINESTATE(int line, int value)</B><BR><B 
id=SCI_GETLINESTATE>SCI_GETLINESTATE(int line)</B><BR>As well as the 8 bits of 
lexical state stored for each character there is also an integer stored for each 
line. This can be used for longer lived parse states such as what the current 
scripting language is in an ASP page. Use <CODE>SCI_SETLINESTATE</CODE> to set 
the integer value and <CODE>SCI_GETLINESTATE</CODE> to get the value.</P>
<P><B id=SCI_GETMAXLINESTATE>SCI_GETMAXLINESTATE</B><BR>This returns the last 
line that has any line state.</P>
<H2 id=StyleDefinition>Style definition</H2>
<P>While the style setting messages mentioned above change the style numbers 
associated with text, these messages define how those style numbers are 
interpreted visually. There are 128 lexer styles that can be set, numbered 0 to 
<CODE>STYLEMAX</CODE> (127). Unless you use <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLEBITS"><CODE>SCI_SETSTYLEBITS</CODE></A> 
to change the number of style bits, styles 0 to 31 are used to set the text 
attributes. There are also some predefined numbered styles starting at 32, The 
following <CODE>STYLE_</CODE>* constants are defined.</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Preset styles" border=0>
  <TBODY vAlign=top>
  <TR>
    <TH align=left><CODE>STYLE_DEFAULT</CODE></TH>
    <TD>32</TD>
    <TD>This style defines the attributes that all styles receive when the 
      <CODE>SCI_STYLECLEARALL</CODE> message is used.</TD></TR>
  <TR>
    <TH align=left><CODE>STYLE_LINENUMBER</CODE></TH>
    <TD>33</TD>
    <TD>This style sets the attributes of the text used to display line 
      numbers in a line number margin. The background colour set for this style 
      also sets the background colour for all margins that do not have any 
      folding mask bits set. That is, any margin for which <CODE>mask &amp; 
      SC_MASK_FOLDERS</CODE> is 0. See <A class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINMASKN"><CODE>SCI_SETMARGINMASKN</CODE></A> 
      for more about masks.</TD></TR>
  <TR>
    <TH align=left><CODE>STYLE_BRACELIGHT</CODE></TH>
    <TD>34</TD>
    <TD>This style sets the attributes used when highlighting braces with the 
      <A class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#BraceHighlighting"><CODE>SCI_BRACEHIGHLIGHT</CODE></A> 
      message and when highlighting the corresponding indentation with <A 
      class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETHIGHLIGHTGUIDE"><CODE>SCI_SETHIGHLIGHTGUIDE</CODE></A>.</TD></TR>
  <TR>
    <TH align=left><CODE>STYLE_BRACEBAD</CODE></TH>
    <TD>35</TD>
    <TD>This style sets the display attributes used when marking an unmatched 
      brace with the <A class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#BraceHighlighting"><CODE>SCI_BRACEBADLIGHT</CODE></A> 
      message.</TD></TR>
  <TR>
    <TH align=left><CODE>STYLE_CONTROLCHAR</CODE></TH>
    <TD>36</TD>
    <TD>This style sets the font used when drawing control characters. Only 
      the font, size, bold, italics, and character set attributes are used and 
      not the colour attributes. See also: <A class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCONTROLCHARSYMBOL"><CODE>SCI_SETCONTROLCHARSYMBOL</CODE></A>.</TD></TR>
  <TR>
    <TH align=left><CODE>STYLE_INDENTGUIDE</CODE></TH>
    <TD>37</TD>
    <TD>This style sets the foreground and background colours used when 
      drawing the indentation guides.</TD></TR>
  <TR>
    <TH align=left><CODE>STYLE_CALLTIP</CODE></TH>
    <TD>38</TD>
    <TD>Call tips normally use the font attributes defined by 
      <CODE>STYLE_DEFAULT</CODE>. Use of <A class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPUSESTYLE"><CODE>SCI_CALLTIPUSESTYLE</CODE></A> 
      causes call tips to use this style instead. Only the font face name, font 
      size, foreground and background colours and character set attributes are 
      used.</TD></TR>
  <TR>
    <TH align=left><CODE>STYLE_LASTPREDEFINED</CODE></TH>
    <TD>39</TD>
    <TD>To make it easier for client code to discover the range of styles that 
      are predefined, this is set to the style number of the last predefined 
      style. This is currently set to 39 and the last style with an identifier 
      is 38, which reserves space for one future predefined style.</TD></TR>
  <TR>
    <TH align=left><CODE>STYLE_MAX</CODE></TH>
    <TD>127</TD>
    <TD>This is not a style but is the number of the maximum style that can be 
      set. Styles between <CODE>STYLE_LASTPREDEFINED</CODE> and 
      <CODE>STYLE_MAX</CODE> would be appropriate if you used <A class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLEBITS"><CODE>SCI_SETSTYLEBITS</CODE></A> 
      to set more than 5 style bits.</TD></TR></TBODY></TABLE>
<P>For each style you can set the font name, size and use of bold, italic and 
underline, foreground and background colour and the character set. You can also 
choose to hide text with a given style, display all characters as upper or lower 
case and fill from the last character on a line to the end of the line (for 
embedded languages). There is also an experimental attribute to make text 
read-only.</P>
<P>It is entirely up to you how you use styles. If you want to use syntax 
colouring you might use style 0 for white space, style 1 for numbers, style 2 
for keywords, style 3 for strings, style 4 for preprocessor, style 5 for 
operators, and so on.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLERESETDEFAULT">SCI_STYLERESETDEFAULT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLECLEARALL">SCI_STYLECLEARALL</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETFONT">SCI_STYLESETFONT(int 
styleNumber, char *fontName)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETSIZE">SCI_STYLESETSIZE(int 
styleNumber, int sizeInPoints)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETBOLD">SCI_STYLESETBOLD(int 
styleNumber, bool bold)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETITALIC">SCI_STYLESETITALIC(int 
styleNumber, bool italic)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETUNDERLINE">SCI_STYLESETUNDERLINE(int 
styleNumber, bool underline)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETFORE">SCI_STYLESETFORE(int 
styleNumber, int colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETBACK">SCI_STYLESETBACK(int 
styleNumber, int colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETEOLFILLED">SCI_STYLESETEOLFILLED(int 
styleNumber, bool eolFilled)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETCHARACTERSET">SCI_STYLESETCHARACTERSET(int 
styleNumber, int charSet)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETCASE">SCI_STYLESETCASE(int 
styleNumber, int caseMode)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETVISIBLE">SCI_STYLESETVISIBLE(int 
styleNumber, bool visible)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETCHANGEABLE">SCI_STYLESETCHANGEABLE(int 
styleNumber, bool changeable)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETHOTSPOT">SCI_STYLESETHOTSPOT(int 
styleNumber, bool hotspot)</A><BR></CODE>
<P><B id=SCI_STYLERESETDEFAULT>SCI_STYLERESETDEFAULT</B><BR>This message resets 
<CODE>STYLE_DEFAULT</CODE> to its state when Scintilla was initialised.</P>
<P><B id=SCI_STYLECLEARALL>SCI_STYLECLEARALL</B><BR>This message sets all styles 
to have the same attributes as <CODE>STYLE_DEFAULT</CODE>. If you are setting up 
Scintilla for syntax colouring, it is likely that the lexical styles you set 
will be very similar. One way to set the styles is to:<BR>1. Set 
<CODE>STYLE_DEFAULT</CODE> to the common features of all styles.<BR>2. Use 
<CODE>SCI_STYLECLEARALL</CODE> to copy this to all styles.<BR>3. Set the style 
attributes that make your lexical styles different.</P>
<P><B id=SCI_STYLESETFONT>SCI_STYLESETFONT(int styleNumber, const char 
*fontName)</B><BR><B id=SCI_STYLESETSIZE>SCI_STYLESETSIZE(int styleNumber, int 
sizeInPoints)</B><BR><B id=SCI_STYLESETBOLD>SCI_STYLESETBOLD(int styleNumber, 
bool bold)</B><BR><B id=SCI_STYLESETITALIC>SCI_STYLESETITALIC(int styleNumber, 
bool italic)</B><BR>These messages (plus <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETCHARACTERSET"><CODE>SCI_STYLESETCHARACTERSET</CODE></A>) 
set the font attributes that are used to match the fonts you request to those 
available. The <CODE>fontName</CODE> is a zero terminated string holding the 
name of a font. Under Windows, only the first 32 characters of the name are used 
and the name is not case sensitive. For internal caching, Scintilla tracks fonts 
by name and does care about the casing of font names, so please be consistent. 
On GTK+ 2.x, either GDK or Pango can be used to display text. Pango antialiases 
text and works well with Unicode but GDK is faster. Prepend a '!' character to 
the font name to use Pango.</P>
<P><B id=SCI_STYLESETUNDERLINE>SCI_STYLESETUNDERLINE(int styleNumber, bool 
underline)</B><BR>You can set a style to be underlined. The underline is drawn 
in the foreground colour. All characters with a style that includes the 
underline attribute are underlined, even if they are white space.</P>
<P><B id=SCI_STYLESETFORE>SCI_STYLESETFORE(int styleNumber, int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_STYLESETBACK>SCI_STYLESETBACK(int styleNumber, int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR>Text 
is drawn in the foreground colour. The space in each character cell that is not 
occupied by the character is drawn in the background colour.</P>
<P><B id=SCI_STYLESETEOLFILLED>SCI_STYLESETEOLFILLED(int styleNumber, bool 
eolFilled)</B><BR>If the last character in the line has a style with this 
attribute set, the remainder of the line up to the right edge of the window is 
filled with the background colour set for the last character. This is useful 
when a document contains embedded sections in another language such as HTML 
pages with embedded JavaScript. By setting <CODE>eolFilled</CODE> to 
<CODE>true</CODE> and a consistent background colour (different from the 
background colour set for the HTML styles) to all JavaScript styles then 
JavaScript sections will be easily distinguished from HTML.</P>
<P><B id=SCI_STYLESETCHARACTERSET>SCI_STYLESETCHARACTERSET(int styleNumber, int 
charSet)</B><BR>You can set a style to use a different character set than the 
default. The places where such characters sets are likely to be useful are 
comments and literal strings. For example, 
<CODE>SCI_STYLESETCHARACTERSET(SCE_C_STRING, SC_CHARSET_RUSSIAN)</CODE> would 
ensure that strings in Russian would display correctly in C and C++ 
(<CODE>SCE_C_STRING</CODE> is the style number used by the C and C++ lexer to 
display literal strings; it has the value 6). This feature works differently on 
Windows and GTK+.</P>
<P>The character sets supported on Windows are:<BR><CODE>SC_CHARSET_ANSI</CODE>, 
<CODE>SC_CHARSET_ARABIC</CODE>, <CODE>SC_CHARSET_BALTIC</CODE>, 
<CODE>SC_CHARSET_CHINESEBIG5</CODE>, <CODE>SC_CHARSET_DEFAULT</CODE>, 
<CODE>SC_CHARSET_EASTEUROPE</CODE>, <CODE>SC_CHARSET_GB2312</CODE>, 
<CODE>SC_CHARSET_GREEK</CODE>, <CODE>SC_CHARSET_HANGUL</CODE>, 
<CODE>SC_CHARSET_HEBREW</CODE>, <CODE>SC_CHARSET_JOHAB</CODE>, 
<CODE>SC_CHARSET_MAC</CODE>, <CODE>SC_CHARSET_OEM</CODE>, 
<CODE>SC_CHARSET_RUSSIAN</CODE> (code page 1251), 
<CODE>SC_CHARSET_SHIFTJIS</CODE>, <CODE>SC_CHARSET_SYMBOL</CODE>, 
<CODE>SC_CHARSET_THAI</CODE>, <CODE>SC_CHARSET_TURKISH</CODE>, and 
<CODE>SC_CHARSET_VIETNAMESE</CODE>.</P>
<P>The character sets supported on GTK+ are:<BR><CODE>SC_CHARSET_ANSI</CODE>, 
<CODE>SC_CHARSET_CYRILLIC</CODE> (code page 1251), 
<CODE>SC_CHARSET_EASTEUROPE</CODE>, <CODE>SC_CHARSET_GB2312</CODE>, 
<CODE>SC_CHARSET_HANGUL</CODE>, <CODE>SC_CHARSET_RUSSIAN</CODE> (KOI8-R), 
<CODE>SC_CHARSET_SHIFTJIS</CODE>, and <CODE>SC_CHARSET_8859_15</CODE>.</P>
<P><B id=SCI_STYLESETCASE>SCI_STYLESETCASE(int styleNumber, int 
caseMode)</B><BR>The value of caseMode determines how text is displayed. You can 
set upper case (<CODE>SC_CASE_UPPER</CODE>, 1) or lower case 
(<CODE>SC_CASE_LOWER</CODE>, 2) or display normally (<CODE>SC_CASE_MIXED</CODE>, 
0). This does not change the stored text, only how it is displayed.</P>
<P><B id=SCI_STYLESETVISIBLE>SCI_STYLESETVISIBLE(int styleNumber, bool 
visible)</B><BR>Text is normally visible. However, you can completely hide it by 
giving it a style with the <CODE>visible</CODE> set to 0. This could be used to 
hide embedded formatting instructions or hypertext keywords in HTML or XML.</P>
<P><B id=SCI_STYLESETCHANGEABLE>SCI_STYLESETCHANGEABLE(int styleNumber, bool 
changeable)</B><BR>This is an experimental and incompletely implemented style 
attribute. The default setting is <CODE>changeable</CODE> set <CODE>true</CODE> 
but when set <CODE>false</CODE> it makes text read-only. Currently it only stops 
the caret from being within not-changeable text and does not yet stop deleting a 
range that contains not-changeable text.</P>
<P><B id=SCI_STYLESETHOTSPOT>SCI_STYLESETHOTSPOT(int styleNumber, bool 
hotspot)</B><BR>This style is used to mark ranges of text that can detect mouse 
clicks. The cursor changes to a hand over hotspots, and the foreground, and 
background colours may change and an underline appear to indicate that these 
areas are sensitive to clicking. This may be used to allow hyperlinks to other 
documents.</P><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STYLESETHOTSPOT">SCI_STYLESETHOTSPOT(int 
styleNumber, bool hotspot)</A><BR>
<H2 id=CaretAndSelectionStyles>Caret, selection, and hotspot styles</H2>
<P>The selection is shown by changing the foreground and/or background colours. 
If one of these is not set then that attribute is not changed for the selection. 
The default is to show the selection by changing the background to light gray 
and leaving the foreground the same as when it was not selected. When there is 
no selection, the current insertion point is marked by the text caret. This is a 
vertical line that is normally blinking on and off to attract the users 
attention.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSELFORE">SCI_SETSELFORE(bool 
useSelectionForeColour, int colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSELBACK">SCI_SETSELBACK(bool 
useSelectionBackColour, int colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCARETFORE">SCI_SETCARETFORE(int 
colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCARETFORE">SCI_GETCARETFORE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCARETLINEVISIBLE">SCI_SETCARETLINEVISIBLE(bool 
show)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCARETLINEVISIBLE">SCI_GETCARETLINEVISIBLE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCARETLINEBACK">SCI_SETCARETLINEBACK(int 
colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCARETLINEBACK">SCI_GETCARETLINEBACK</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCARETLINEBACKALPHA">SCI_SETCARETLINEBACKALPHA(int 
alpha)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCARETLINEBACKALPHA">SCI_GETCARETLINEBACKALPHA</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCARETPERIOD">SCI_SETCARETPERIOD(int 
milliseconds)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCARETPERIOD">SCI_GETCARETPERIOD</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCARETWIDTH">SCI_SETCARETWIDTH(int 
pixels)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCARETWIDTH">SCI_GETCARETWIDTH</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETHOTSPOTACTIVEFORE">SCI_SETHOTSPOTACTIVEFORE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETHOTSPOTACTIVEBACK">SCI_SETHOTSPOTACTIVEBACK</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETHOTSPOTACTIVEUNDERLINE">SCI_SETHOTSPOTACTIVEUNDERLINE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETHOTSPOTSINGLELINE">SCI_SETHOTSPOTSINGLELINE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCONTROLCHARSYMBOL">SCI_SETCONTROLCHARSYMBOL(int 
symbol)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCONTROLCHARSYMBOL">SCI_GETCONTROLCHARSYMBOL</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCARETSTICKY">SCI_SETCARETSTICKY</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCARETSTICKY">SCI_GETCARETSTICKY</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_TOGGLECARETSTICKY">SCI_TOGGLECARETSTICKY</A><BR></CODE>
<P><B id=SCI_SETSELFORE>SCI_SETSELFORE(bool useSelectionForeColour, int <A 
class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_SETSELBACK>SCI_SETSELBACK(bool useSelectionBackColour, int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR>You 
can choose to override the default selection colouring with these two messages. 
The colour you provide is used if you set <CODE>useSelection*Colour</CODE> to 
<CODE>true</CODE>. If it is set to <CODE>false</CODE>, the default colour 
colouring is used and the <CODE>colour</CODE> argument has no effect.</P>
<P><B id=SCI_SETCARETFORE>SCI_SETCARETFORE(int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_GETCARETFORE>SCI_GETCARETFORE</B><BR>The colour of the caret can be set 
with <CODE>SCI_SETCARETFORE</CODE> and retrieved with 
<CODE>SCI_CETCARETFORE</CODE>.</P>
<P><B id=SCI_SETCARETLINEVISIBLE>SCI_SETCARETLINEVISIBLE(bool show)</B><BR><B 
id=SCI_GETCARETLINEVISIBLE>SCI_GETCARETLINEVISIBLE</B><BR><B 
id=SCI_SETCARETLINEBACK>SCI_SETCARETLINEBACK(int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_GETCARETLINEBACK>SCI_GETCARETLINEBACK</B><BR><B 
id=SCI_SETCARETLINEBACKALPHA>SCI_SETCARETLINEBACKALPHA(int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#alpha">alpha</A>)</B><BR><B 
id=SCI_GETCARETLINEBACKALPHA>SCI_GETCARETLINEBACKALPHA</B><BR>You can choose to 
make the background colour of the line containing the caret different with these 
messages. To do this, set the desired background colour with 
<CODE>SCI_SETCARETLINEBACK</CODE>, then use 
<CODE>SCI_SETCARETLINEVISIBLE(true)</CODE> to enable the effect. You can cancel 
the effect with <CODE>SCI_SETCARETLINEVISIBLE(false)</CODE>. The two 
<CODE>SCI_GETCARET*</CODE> functions return the state and the colour. This form 
of background colouring has highest priority when a line has markers that would 
otherwise change the background colour. The caret line may also be drawn 
translucently which allows other background colours to show through. This is 
done by setting the alpha (translucency) value by calling 
SCI_SETCARETLINEBACKALPHA. When the alpha is not SC_ALPHA_NOALPHA, the caret 
line is drawn after all other features so will affect the colour of all other 
features. </P>
<P><B id=SCI_SETCARETPERIOD>SCI_SETCARETPERIOD(int milliseconds)</B><BR><B 
id=SCI_GETCARETPERIOD>SCI_GETCARETPERIOD</B><BR>The rate at which the caret 
blinks can be set with <CODE>SCI_SETCARETPERIOD</CODE> which determines the time 
in milliseconds that the caret is visible or invisible before changing state. 
Setting the period to 0 stops the caret blinking. The default value is 500 
milliseconds. <CODE>SCI_GETCARETPERIOD</CODE> returns the current setting.</P>
<P><B id=SCI_SETCARETWIDTH>SCI_SETCARETWIDTH(int pixels)</B><BR><B 
id=SCI_GETCARETWIDTH>SCI_GETCARETWIDTH</B><BR>The width of the caret can be set 
with <CODE>SCI_SETCARETWIDTH</CODE> to a value of 0, 1, 2 or 3 pixels. The 
default width is 1 pixel. You can read back the current width with 
<CODE>SCI_GETCARETWIDTH</CODE>. A width of 0 makes the caret invisible (added at 
version 1.50).</P>
<P><B id=SCI_SETHOTSPOTACTIVEFORE>SCI_SETHOTSPOTACTIVEFORE(bool 
useHotSpotForeColour, int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_SETHOTSPOTACTIVEBACK>SCI_SETHOTSPOTACTIVEBACK(bool useHotSpotBackColour, 
int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_SETHOTSPOTACTIVEUNDERLINE>SCI_SETHOTSPOTACTIVEUNDERLINE(bool 
underline,)</B><BR><B id=SCI_SETHOTSPOTSINGLELINE>SCI_SETHOTSPOTSINGLELINE(bool 
singleLine,)</B><BR>While the cursor hovers over text in a style with the 
hotspot attribute set, the default colouring can be modified and an underline 
drawn with these settings. Single line mode stops a hotspot from wrapping onto 
next line.</P>
<P><B id=SCI_SETCONTROLCHARSYMBOL>SCI_SETCONTROLCHARSYMBOL(int symbol)</B><BR><B 
id=SCI_GETCONTROLCHARSYMBOL>SCI_GETCONTROLCHARSYMBOL</B><BR>By default, 
Scintilla displays control characters (characters with codes less than 32) in a 
rounded rectangle as ASCII mnemonics: "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", 
"ACK", "BEL", "BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI", "DLE", "DC1", 
"DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN", "EM", "SUB", "ESC", "FS", "GS", 
"RS", "US". These mnemonics come from the early days of signaling, though some 
are still used (LF = Line Feed, BS = Back Space, CR = Carriage Return, for 
example).</P>
<P>You can choose to replace these mnemonics by a nominated symbol with an ASCII 
code in the range 32 to 255. If you set a symbol value less than 32, all control 
characters are displayed as mnemonics. The symbol you set is rendered in the 
font of the style set for the character. You can read back the current symbol 
with the <CODE>SCI_GETCONTROLCHARSYMBOL</CODE> message. The default symbol value 
is 0.</P>
<P><B id=SCI_SETCARETSTICKY>SCI_SETCARETSTICKY(bool 
useCaretStickyBehaviour)</B><BR><B 
id=SCI_GETCARETSTICKY>SCI_GETCARETSTICKY</B><BR><B 
id=SCI_TOGGLECARETSTICKY>SCI_TOGGLECARETSTICKY</B><BR>These messages set, get or 
toggle the caretSticky flag which controls when the last position of the caret 
on the line is saved. When set to true, the position is not saved when you type 
a character, a tab, paste the clipboard content or press backspace.</P>
<H2 id=Margins>Margins</H2>
<P>There may be up to three margins to the left of the text display, plus a gap 
either side of the text. Each margin can be set to display either symbols or 
line numbers with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINTYPEN"><CODE>SCI_SETMARGINTYPEN</CODE></A>. 
The markers that can be displayed in each margin are set with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINMASKN"><CODE>SCI_SETMARGINMASKN</CODE></A>. 
Any markers not associated with a visible margin will be displayed as changes in 
background colour in the text. A width in pixels can be set for each margin. 
Margins with a zero width are ignored completely. You can choose if a mouse 
click in a margin sends a <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MARGINCLICK"><CODE>SCN_MARGINCLICK</CODE></A> 
notification to the container or selects a line of text.</P>
<P>The margins are numbered 0 to 2. Using a margin number outside the valid 
range has no effect. By default, margin 0 is set to display line numbers, but is 
given a width of 0, so it is hidden. Margin 1 is set to display non-folding 
symbols and is given a width of 16 pixels, so it is visible. Margin 2 is set to 
display the folding symbols, but is given a width of 0, so it is hidden. Of 
course, you can set the margins to be whatever you wish.</P><CODE><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINTYPEN">SCI_SETMARGINTYPEN(int 
margin, int type)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMARGINTYPEN">SCI_GETMARGINTYPEN(int 
margin)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINWIDTHN">SCI_SETMARGINWIDTHN(int 
margin, int pixelWidth)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMARGINWIDTHN">SCI_GETMARGINWIDTHN(int 
margin)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINMASKN">SCI_SETMARGINMASKN(int 
margin, int mask)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMARGINMASKN">SCI_GETMARGINMASKN(int 
margin)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINSENSITIVEN">SCI_SETMARGINSENSITIVEN(int 
margin, bool sensitive)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMARGINSENSITIVEN">SCI_GETMARGINSENSITIVEN(int 
margin)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINLEFT">SCI_SETMARGINLEFT(&lt;unused&gt;, 
int pixels)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMARGINLEFT">SCI_GETMARGINLEFT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINRIGHT">SCI_SETMARGINRIGHT(&lt;unused&gt;, 
int pixels)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMARGINRIGHT">SCI_GETMARGINRIGHT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETFOLDMARGINCOLOUR">SCI_SETFOLDMARGINCOLOUR(bool 
useSetting, int colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETFOLDMARGINHICOLOUR">SCI_SETFOLDMARGINHICOLOUR(bool 
useSetting, int colour)</A><BR></CODE>
<P><B id=SCI_SETMARGINTYPEN>SCI_SETMARGINTYPEN(int margin, int iType)</B><BR><B 
id=SCI_GETMARGINTYPEN>SCI_GETMARGINTYPEN(int margin)</B><BR>These two routines 
set and get the type of a margin. The margin argument should be 0, 1 or 2. You 
can use the predefined constants <CODE>SC_MARGIN_SYMBOL</CODE> (0) and 
<CODE>SC_MARGIN_NUMBER</CODE> (1) to set a margin as either a line number or a 
symbol margin. By convention, margin 0 is used for line numbers and the other 
two are used for symbols.</P>
<P><B id=SCI_SETMARGINWIDTHN>SCI_SETMARGINWIDTHN(int margin, int 
pixelWidth)</B><BR><B id=SCI_GETMARGINWIDTHN>SCI_GETMARGINWIDTHN(int 
margin)</B><BR>These routines set and get the width of a margin in pixels. A 
margin with zero width is invisible. By default, Scintilla sets margin 1 for 
symbols with a width of 16 pixels, so this is a reasonable guess if you are not 
sure what would be appropriate. Line number margins widths should take into 
account the number of lines in the document and the line number style. You could 
use something like <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_TEXTWIDTH"><CODE>SCI_TEXTWIDTH(STYLE_LINENUMBER, 
"_99999")</CODE></A> to get a suitable width.</P>
<P><B id=SCI_SETMARGINMASKN>SCI_SETMARGINMASKN(int margin, int mask)</B><BR><B 
id=SCI_GETMARGINMASKN>SCI_GETMARGINMASKN(int margin)</B><BR>The mask is a 32-bit 
value. Each bit corresponds to one of 32 logical symbols that can be displayed 
in a margin that is enabled for symbols. There is a useful constant, 
<CODE>SC_MASK_FOLDERS</CODE> (0xFE000000 or -33554432), that is a mask for the 7 
logical symbols used to denote folding. You can assign a wide range of symbols 
and colours to each of the 32 logical symbols, see <A 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Markers">Markers</A> 
for more information. If <CODE>(mask &amp; SC_MASK_FOLDERS)==0</CODE>, the 
margin background colour is controlled by style 33 (<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition"><CODE>STYLE_LINENUMBER</CODE></A>).</P>
<P>You add logical markers to a line with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERADD"><CODE>SCI_MARKERADD</CODE></A>. 
If a line has an associated marker that does not appear in the mask of any 
margin with a non-zero width, the marker changes the background colour of the 
line. For example, suppose you decide to use logical marker 10 to mark lines 
with a syntax error and you want to show such lines by changing the background 
colour. The mask for this marker is 1 shifted left 10 times (1&lt;&lt;10) which 
is 0x400. If you make sure that no symbol margin includes 0x400 in its mask, any 
line with the marker gets the background colour changed.</P>
<P>To set a non-folding margin 1 use <CODE>SCI_SETMARGINMASKN(1, 
~SC_MASK_FOLDERS)</CODE>; to set a folding margin 2 use 
<CODE>SCI_SETMARGINMASKN(2, SC_MASK_FOLDERS)</CODE>. This is the default set by 
Scintilla. <CODE>~SC_MASK_FOLDERS</CODE> is 0x1FFFFFF in hexadecimal or 33554431 
decimal. Of course, you may need to display all 32 symbols in a margin, in which 
case use <CODE>SCI_SETMARGINMASKN(margin, -1)</CODE>.</P>
<P><B id=SCI_SETMARGINSENSITIVEN>SCI_SETMARGINSENSITIVEN(int margin, bool 
sensitive)</B><BR><B id=SCI_GETMARGINSENSITIVEN>SCI_GETMARGINSENSITIVEN(int 
margin)</B><BR>Each of the three margins can be set sensitive or insensitive to 
mouse clicks. A click in a sensitive margin sends a <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MARGINCLICK"><CODE>SCN_MARGINCLICK</CODE></A> 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">notification</A> 
to the container. Margins that are not sensitive act as selection margins which 
make it easy to select ranges of lines. By default, all margins are 
insensitive.</P>
<P><B id=SCI_SETMARGINLEFT>SCI_SETMARGINLEFT(&lt;unused&gt;, int 
pixels)</B><BR><B id=SCI_GETMARGINLEFT>SCI_GETMARGINLEFT</B><BR><B 
id=SCI_SETMARGINRIGHT>SCI_SETMARGINRIGHT(&lt;unused&gt;, int pixels)</B><BR><B 
id=SCI_GETMARGINRIGHT>SCI_GETMARGINRIGHT</B><BR>These messages set and get the 
width of the blank margin on both sides of the text in pixels. The default is to 
one pixel on each side.</P>
<P><B id=SCI_SETFOLDMARGINCOLOUR>SCI_SETFOLDMARGINCOLOUR(bool useSetting, int 
colour)</B><BR><B id=SCI_SETFOLDMARGINHICOLOUR>SCI_SETFOLDMARGINHICOLOUR(bool 
useSetting, int colour)</B><BR>These messages allow changing the colour of the 
fold margin and fold margin highlight. On Windows the fold margin colour 
defaults to ::GetSysColor(COLOR_3DFACE) and the fold margin highlight colour to 
::GetSysColor(COLOR_3DHIGHLIGHT).</P>
<H2 id=OtherSettings>Other settings</H2><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETUSEPALETTE">SCI_SETUSEPALETTE(bool 
allowPaletteUse)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETUSEPALETTE">SCI_GETUSEPALETTE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETBUFFEREDDRAW">SCI_SETBUFFEREDDRAW(bool 
isBuffered)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETBUFFEREDDRAW">SCI_GETBUFFEREDDRAW</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETTWOPHASEDRAW">SCI_SETTWOPHASEDRAW(bool 
twoPhase)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTWOPHASEDRAW">SCI_GETTWOPHASEDRAW</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCODEPAGE">SCI_SETCODEPAGE(int 
codePage)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCODEPAGE">SCI_GETCODEPAGE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETWORDCHARS">SCI_SETWORDCHARS(&lt;unused&gt;, 
const char *chars)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETWHITESPACECHARS">SCI_SETWHITESPACECHARS(&lt;unused&gt;, 
const char *chars)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETCHARSDEFAULT">SCI_SETCHARSDEFAULT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GRABFOCUS">SCI_GRABFOCUS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETFOCUS">SCI_SETFOCUS(bool 
focus)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETFOCUS">SCI_GETFOCUS</A><BR></CODE>
<P><B id=SCI_SETUSEPALETTE>SCI_SETUSEPALETTE(bool allowPaletteUse)</B><BR><B 
id=SCI_GETUSEPALETTE>SCI_GETUSEPALETTE</B><BR>On 8 bit displays, which can only 
display a maximum of 256 colours, the graphics environment mediates between the 
colour needs of applications through the use of palettes. On GTK+, Scintilla 
always uses a palette.</P>
<P>On Windows, there are some problems with visual flashing when switching 
between applications with palettes and it is also necessary for the application 
containing the Scintilla control to forward some messages to Scintilla for its 
palette code to work. Because of this, by default, the palette is not used and 
the application must tell Scintilla to use one. If Scintilla is not using a 
palette, it will only display in those colours already available, which are 
often the 20 Windows system colours.</P>
<P>To see an example of how to enable palette support in Scintilla, search the 
text of SciTE for <CODE>WM_PALETTECHANGED</CODE>, 
<CODE>WM_QUERYNEWPALETTE</CODE> and <CODE>SCI_SETUSEPALETTE</CODE>. The Windows 
messages to forward are:<BR><CODE>WM_SYSCOLORCHANGE</CODE>, 
<CODE>WM_PALETTECHANGED</CODE>, <CODE>WM_QUERYNEWPALETTE</CODE> (should return 
<CODE>TRUE</CODE>).</P>
<P>To forward a message <CODE>(WM_XXXX, WPARAM, LPARAM)</CODE> to Scintilla, you 
can use <CODE>SendMessage(hScintilla, WM_XXXX, WPARAM, LPARAM)</CODE> where 
<CODE>hScintilla</CODE> is the handle to the Scintilla window you created as 
your editor.</P>
<P>While we are on the subject of forwarding messages in Windows, the top level 
window should forward any <CODE>WM_SETTINGCHANGE</CODE> messages to Scintilla 
(this is currently used to collect changes to mouse settings, but could be used 
for other user interface items in the future).</P>
<P><B id=SCI_SETBUFFEREDDRAW>SCI_SETBUFFEREDDRAW(bool isBuffered)</B><BR><B 
id=SCI_GETBUFFEREDDRAW>SCI_GETBUFFEREDDRAW</B><BR>These messages turn buffered 
drawing on or off and report the buffered drawing state. Buffered drawing draws 
each line into a bitmap rather than directly to the screen and then copies the 
bitmap to the screen. This avoids flickering although it does take longer. The 
default is for drawing to be buffered.</P>
<P><B id=SCI_SETTWOPHASEDRAW>SCI_SETTWOPHASEDRAW(bool twoPhase)</B><BR><B 
id=SCI_GETTWOPHASEDRAW>SCI_GETTWOPHASEDRAW</B><BR>Two phase drawing is a better 
but slower way of drawing text. In single phase drawing each run of characters 
in one style is drawn along with its background. If a character overhangs the 
end of a run, such as in "<I>V</I>_" where the "<I>V</I>" is in a different 
style from the "_", then this can cause the right hand side of the "<I>V</I>" to 
be overdrawn by the background of the "_" which cuts it off. Two phase drawing 
fixes this by drawing all the backgrounds first and then drawing the text in 
transparent mode. Two phase drawing may flicker more than single phase unless 
buffered drawing is on. The default is for drawing to be two phase.</P>
<P><B id=SCI_SETCODEPAGE>SCI_SETCODEPAGE(int codePage)</B><BR><B 
id=SCI_GETCODEPAGE>SCI_GETCODEPAGE</B><BR>Scintilla has some support for 
Japanese, Chinese and Korean DBCS. Use this message with <CODE>codePage</CODE> 
set to the code page number to set Scintilla to use code page information to 
ensure double byte characters are treated as one character rather than two. This 
also stops the caret from moving between the two bytes in a double byte 
character. Call with <CODE>codePage</CODE> set to zero to disable DBCS support. 
The default is <CODE>SCI_SETCODEPAGE(0)</CODE>.</P>
<P>Code page <CODE>SC_CP_UTF8</CODE> (65001) sets Scintilla into Unicode mode 
with the document treated as a sequence of characters expressed in UTF-8. The 
text is converted to the platform's normal Unicode encoding before being drawn 
by the OS and thus can display Hebrew, Arabic, Cyrillic, and Han characters. 
Languages which can use two characters stacked vertically in one horizontal 
space, such as Thai, will mostly work but there are some issues where the 
characters are drawn separately leading to visual glitches. Bi-directional text 
is not supported.</P>
<P>On Windows, code page can be set to 932 (Japanese Shift-JIS), 936 (Simplified 
Chinese GBK), 949 (Korean), and 950 (Traditional Chinese Big5) although these 
may require installation of language specific support.</P>
<P>On GTK+, code page <CODE>SC_CP_DBCS</CODE> (1) sets Scintilla into multi byte 
character mode as is required for Japanese language processing with the EUC 
encoding.</P>
<P>For GTK+, the locale should be set to a Unicode locale with a call similar to 
<CODE>setlocale(LC_CTYPE, "en_US.UTF-8")</CODE>. Fonts with an 
<CODE>"iso10646"</CODE> registry should be used in a font set. Font sets are a 
comma separated list of partial font specifications where each partial font 
specification can be in the form: 
<CODE>foundry-fontface-charsetregistry-encoding</CODE> or 
<CODE>fontface-charsetregistry-encoding</CODE> or <CODE>foundry-fontface</CODE> 
or <CODE>fontface</CODE>. An example is 
<CODE>"misc-fixed-iso10646-1,*"</CODE>.</P>
<P>Setting <CODE>codePage</CODE> to a non-zero value that is not 
<CODE>SC_CP_UTF8</CODE> is operating system dependent.</P>
<P><B id=SCI_SETWORDCHARS>SCI_SETWORDCHARS(&lt;unused&gt;, const char 
*chars)</B><BR>Scintilla has several functions that operate on words, which are 
defined to be contiguous sequences of characters from a particular set of 
characters. This message defines which characters are members of that set. The 
character sets are set to default values before processing this function. For 
example, if you don't allow '_' in your set of characters 
use:<BR><CODE>SCI_SETWORDCHARS(0, 
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")</CODE>;</P>
<P><B id=SCI_SETWHITESPACECHARS>SCI_SETWHITESPACECHARS(&lt;unused&gt;, const 
char *chars)</B><BR>Similar to <CODE>SCI_SETWORDCHARS</CODE>, this message 
allows the user to define which chars Scintilla considers as whitespace. Setting 
the whitespace chars allows the user to fine-tune Scintilla's behaviour doing 
such things as moving the cursor to the start or end of a word; for example, by 
defining punctuation chars as whitespace, they will be skipped over when the 
user presses ctrl+left or ctrl+right. This function should be called after 
<CODE>SCI_SETWORDCHARS</CODE> as it will reset the whitespace characters to the 
default set.</P>
<P><B id=SCI_SETCHARSDEFAULT>SCI_SETCHARSDEFAULT</B><BR>Use the default sets of 
word and whitespace characters. This sets whitespace to space, tab and other 
characters with codes less than 0x20, with word characters set to alphanumeric 
and '_'. </P>
<P><B id=SCI_GRABFOCUS>SCI_GRABFOCUS</B><BR><B id=SCI_SETFOCUS>SCI_SETFOCUS(bool 
focus)</B><BR><B id=SCI_GETFOCUS>SCI_GETFOCUS</B><BR>Scintilla can be told to 
grab the focus with this message. This is needed more on GTK+ where focus 
handling is more complicated than on Windows.</P>
<P>The internal focus flag can be set with <CODE>SCI_SETFOCUS</CODE>. This is 
used by clients that have complex focus requirements such as having their own 
window that gets the real focus but with the need to indicate that Scintilla has 
the logical focus.</P>
<H2 id=BraceHighlighting>Brace highlighting</H2><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_BRACEHIGHLIGHT">SCI_BRACEHIGHLIGHT(int 
pos1, int pos2)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_BRACEBADLIGHT">SCI_BRACEBADLIGHT(int 
pos1)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_BRACEMATCH">SCI_BRACEMATCH(int 
position, int maxReStyle)</A><BR></CODE>
<P><B id=SCI_BRACEHIGHLIGHT>SCI_BRACEHIGHLIGHT(int pos1, int pos2)</B><BR>Up to 
two characters can be highlighted in a 'brace highlighting style', which is 
defined as style number <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition"><CODE>STYLE_BRACELIGHT</CODE></A> 
(34). If you have enabled indent guides, you may also wish to highlight the 
indent that corresponds with the brace. You can locate the column with <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCOLUMN"><CODE>SCI_GETCOLUMN</CODE></A> 
and highlight the indent with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETHIGHLIGHTGUIDE"><CODE>SCI_SETHIGHLIGHTGUIDE</CODE></A>.</P>
<P><B id=SCI_BRACEBADLIGHT>SCI_BRACEBADLIGHT(int pos1)</B><BR>If there is no 
matching brace then the <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition">brace 
badlighting style</A>, style <CODE>BRACE_BADLIGHT</CODE> (35), can be used to 
show the brace that is unmatched. Using a position of 
<CODE>INVALID_POSITION</CODE> (-1) removes the highlight.</P>
<P><B id=SCI_BRACEMATCH>SCI_BRACEMATCH(int pos, int maxReStyle)</B><BR>The 
<CODE>SCI_BRACEMATCH</CODE> message finds a corresponding matching brace given 
<CODE>pos</CODE>, the position of one brace. The brace characters handled are 
'(', ')', '[', ']', '{', '}', '&lt;', and '&gt;'. The search is forwards from an 
opening brace and backwards from a closing brace. If the character at position 
is not a brace character, or a matching brace cannot be found, the return value 
is -1. Otherwise, the return value is the position of the matching brace.</P>
<P>A match only occurs if the style of the matching brace is the same as the 
starting brace or the matching brace is beyond the end of styling. Nested braces 
are handled correctly. The <CODE>maxReStyle</CODE> parameter must currently be 0 
- it may be used in the future to limit the length of brace searches.</P>
<H2 id=TabsAndIndentationGuides>Tabs and Indentation Guides</H2>
<P>Indentation (the white space at the start of a line) is often used by 
programmers to clarify program structure and in some languages, for example 
Python, it may be part of the language syntax. Tabs are normally used in editors 
to insert a tab character or to pad text with spaces up to the next tab.</P>
<P>Scintilla can be set to treat tab and backspace in the white space at the 
start of a line in a special way: inserting a tab indents the line to the next 
indent position rather than just inserting a tab at the current character 
position and backspace unindents the line rather than deleting a character. 
Scintilla can also display indentation guides (vertical lines) to help you to 
generate code.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETTABWIDTH">SCI_SETTABWIDTH(int 
widthInChars)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTABWIDTH">SCI_GETTABWIDTH</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETUSETABS">SCI_SETUSETABS(bool 
useTabs)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETUSETABS">SCI_GETUSETABS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETINDENT">SCI_SETINDENT(int 
widthInChars)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETINDENT">SCI_GETINDENT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETTABINDENTS">SCI_SETTABINDENTS(bool 
tabIndents)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETTABINDENTS">SCI_GETTABINDENTS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETBACKSPACEUNINDENTS">SCI_SETBACKSPACEUNINDENTS(bool 
bsUnIndents)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETBACKSPACEUNINDENTS">SCI_GETBACKSPACEUNINDENTS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETLINEINDENTATION">SCI_SETLINEINDENTATION(int 
line, int indentation)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINEINDENTATION">SCI_GETLINEINDENTATION(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINEINDENTPOSITION">SCI_GETLINEINDENTPOSITION(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETINDENTATIONGUIDES">SCI_SETINDENTATIONGUIDES(bool 
view)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETINDENTATIONGUIDES">SCI_GETINDENTATIONGUIDES</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETHIGHLIGHTGUIDE">SCI_SETHIGHLIGHTGUIDE(int 
column)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETHIGHLIGHTGUIDE">SCI_GETHIGHLIGHTGUIDE</A><BR></CODE>
<P><B id=SCI_SETTABWIDTH>SCI_SETTABWIDTH(int widthInChars)</B><BR><B 
id=SCI_GETTABWIDTH>SCI_GETTABWIDTH</B><BR><CODE>SCI_SETTABWIDTH</CODE> sets the 
size of a tab as a multiple of the size of a space character in 
<CODE>STYLE_DEFAULT</CODE>. The default tab width is 8 characters. There are no 
limits on tab sizes, but values less than 1 or large values may have undesirable 
effects.</P>
<P><B id=SCI_SETUSETABS>SCI_SETUSETABS(bool useTabs)</B><BR><B 
id=SCI_GETUSETABS>SCI_GETUSETABS</B><BR><CODE>SCI_SETUSETABS</CODE> determines 
whether indentation should be created out of a mixture of tabs and spaces or be 
based purely on spaces. Set <CODE>useTabs</CODE> to <CODE>false</CODE> (0) to 
create all tabs and indents out of spaces. The default is <CODE>true</CODE>. You 
can use <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETCOLUMN"><CODE>SCI_GETCOLUMN</CODE></A> 
to get the column of a position taking the width of a tab into account.</P><B 
id=SCI_SETINDENT>SCI_SETINDENT(int widthInChars)</B><BR><B 
id=SCI_GETINDENT>SCI_GETINDENT</B><BR><CODE>SCI_SETINDENT</CODE> sets the size 
of indentation in terms of the width of a space in <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition"><CODE>STYLE_DEFAULT</CODE></A>. 
If you set a width of 0, the indent size is the same as the tab size. There are 
no limits on indent sizes, but values less than 0 or large values may have 
undesirable effects. <BR><BR>
<P><B id=SCI_SETTABINDENTS>SCI_SETTABINDENTS(bool tabIndents)</B><BR><B 
id=SCI_GETTABINDENTS>SCI_GETTABINDENTS</B><BR><B 
id=SCI_SETBACKSPACEUNINDENTS>SCI_SETBACKSPACEUNINDENTS(bool 
bsUnIndents)</B><BR><B 
id=SCI_GETBACKSPACEUNINDENTS>SCI_GETBACKSPACEUNINDENTS</B><BR></P>
<P>Inside indentation white space, the tab and backspace keys can be made to 
indent and unindent rather than insert a tab character or delete a character 
with the <CODE>SCI_SETTABINDENTS</CODE> and 
<CODE>SCI_SETBACKSPACEUNINDENTS</CODE> functions.</P>
<P><B id=SCI_SETLINEINDENTATION>SCI_SETLINEINDENTATION(int line, int 
indentation)</B><BR><B id=SCI_GETLINEINDENTATION>SCI_GETLINEINDENTATION(int 
line)</B><BR>The amount of indentation on a line can be discovered and set with 
<CODE>SCI_GETLINEINDENTATION</CODE> and <CODE>SCI_SETLINEINDENTATION</CODE>. The 
indentation is measured in character columns, which correspond to the width of 
space characters.</P>
<P><B id=SCI_GETLINEINDENTPOSITION>SCI_GETLINEINDENTPOSITION(int 
line)</B><BR>This returns the position at the end of indentation of a line.</P>
<P><B id=SCI_SETINDENTATIONGUIDES>SCI_SETINDENTATIONGUIDES(bool view)</B><BR><B 
id=SCI_GETINDENTATIONGUIDES>SCI_GETINDENTATIONGUIDES</B><BR>Indentation guides 
are dotted vertical lines that appear within indentation white space every 
indent size columns. They make it easy to see which constructs line up 
especially when they extend over multiple pages. Style <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition"><CODE>STYLE_INDENTGUIDE</CODE></A> 
(37) is used to specify the foreground and background colour of the indentation 
guides.</P>
<P><B id=SCI_SETHIGHLIGHTGUIDE>SCI_SETHIGHLIGHTGUIDE(int column)</B><BR><B 
id=SCI_GETHIGHLIGHTGUIDE>SCI_GETHIGHLIGHTGUIDE</B><BR>When brace highlighting 
occurs, the indentation guide corresponding to the braces may be highlighted 
with the brace highlighting style, <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition"><CODE>STYLE_BRACELIGHT</CODE></A> 
(34). Set <CODE>column</CODE> to 0 to cancel this highlight.</P>
<H2 id=Markers>Markers</H2>
<P>There are 32 markers, numbered 0 to 31, and you can assign any combination of 
them to each line in the document. Markers appear in the <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Margins">selection 
margin</A> to the left of the text. If the selection margin is set to zero 
width, the background colour of the whole line is changed instead. Marker 
numbers 25 to 31 are used by Scintilla in folding margins, and have symbolic 
names of the form <CODE>SC_MARKNUM_</CODE>*, for example 
<CODE>SC_MARKNUM_FOLDEROPEN</CODE>.</P>
<P>Marker numbers 0 to 24 have no pre-defined function; you can use them to mark 
syntax errors or the current point of execution, break points, or whatever you 
need marking. If you do not need folding, you can use all 32 for any purpose you 
wish.</P>
<P>Each marker number has a symbol associated with it. You can also set the 
foreground and background colour for each marker number, so you can use the same 
symbol more than once with different colouring for different uses. Scintilla has 
a set of symbols you can assign (<CODE>SC_MARK_</CODE>*) or you can use 
characters. By default, all 32 markers are set to <CODE>SC_MARK_CIRCLE</CODE> 
with a black foreground and a white background.</P>
<P>The markers are drawn in the order of their numbers, so higher numbered 
markers appear on top of lower numbered ones. Markers try to move with their 
text by tracking where the start of their line moves. When a line is deleted, 
its markers are combined, by an <CODE>OR</CODE> operation, with the markers of 
the previous line.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERDEFINE">SCI_MARKERDEFINE(int 
markerNumber, int markerSymbols)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERDEFINEPIXMAP">SCI_MARKERDEFINEPIXMAP(int 
markerNumber, const char *xpm)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERSETFORE">SCI_MARKERSETFORE(int 
markerNumber, int colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERSETBACK">SCI_MARKERSETBACK(int 
markerNumber, int colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERADD">SCI_MARKERADD(int 
line, int markerNumber)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERADDSET">SCI_MARKERADDSET(int 
line, int markerMask)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERDELETE">SCI_MARKERDELETE(int 
line, int markerNumber)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERDELETEALL">SCI_MARKERDELETEALL(int 
markerNumber)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERGET">SCI_MARKERGET(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERNEXT">SCI_MARKERNEXT(int 
lineStart, int markerMask)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERPREVIOUS">SCI_MARKERPREVIOUS(int 
lineStart, int markerMask)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERLINEFROMHANDLE">SCI_MARKERLINEFROMHANDLE(int 
handle)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERDELETEHANDLE">SCI_MARKERDELETEHANDLE(int 
handle)</A><BR></CODE>
<P><B id=SCI_MARKERDEFINE>SCI_MARKERDEFINE(int markerNumber, int 
markerSymbols)</B><BR>This message associates a marker number in the range 0 to 
31 with one of the marker symbols or an ASCII character. The general-purpose 
marker symbols currently available are:<BR><CODE>SC_MARK_CIRCLE</CODE>, 
<CODE>SC_MARK_ROUNDRECT</CODE>, <CODE>SC_MARK_ARROW</CODE>, 
<CODE>SC_MARK_SMALLRECT</CODE>, <CODE>SC_MARK_SHORTARROW</CODE>, 
<CODE>SC_MARK_EMPTY</CODE>, <CODE>SC_MARK_ARROWDOWN</CODE>, 
<CODE>SC_MARK_MINUS</CODE>, <CODE>SC_MARK_PLUS</CODE>, 
<CODE>SC_MARK_ARROWS</CODE>, <CODE>SC_MARK_DOTDOTDOT</CODE>, 
<CODE>SC_MARK_EMPTY</CODE>, <CODE>SC_MARK_BACKGROUND</CODE> and 
<CODE>SC_MARK_FULLRECT</CODE>.</P>
<P>The <CODE>SC_MARK_BACKGROUND</CODE> marker changes the background colour of 
the line only. The <CODE>SC_MARK_FULLRECT</CODE> symbol mirrors this, changing 
only the margin background colour. The <CODE>SC_MARK_EMPTY</CODE> symbol is 
invisible, allowing client code to track the movement of lines. You would also 
use it if you changed the folding style and wanted one or more of the 
<CODE>SC_FOLDERNUM_</CODE>* markers to have no associated symbol.</P>
<P>There are also marker symbols designed for use in the folding margin in a 
flattened tree style.<BR><CODE>SC_MARK_BOXMINUS</CODE>, 
<CODE>SC_MARK_BOXMINUSCONNECTED</CODE>, <CODE>SC_MARK_BOXPLUS</CODE>, 
<CODE>SC_MARK_BOXPLUSCONNECTED</CODE>, <CODE>SC_MARK_CIRCLEMINUS</CODE>, 
<CODE>SC_MARK_CIRCLEMINUSCONNECTED</CODE>, <CODE>SC_MARK_CIRCLEPLUS</CODE>, 
<CODE>SC_MARK_CIRCLEPLUSCONNECTED</CODE>, <CODE>SC_MARK_LCORNER</CODE>, 
<CODE>SC_MARK_LCORNERCURVE</CODE>, <CODE>SC_MARK_TCORNER</CODE>, 
<CODE>SC_MARK_TCORNERCURVE</CODE>, and <CODE>SC_MARK_VLINE</CODE>.</P>Characters 
can be used as markers by adding the ASCII value of the character to 
<CODE>SC_MARK_CHARACTER</CODE> (10000). For example, to use 'A' (ASCII code 65) 
as marker number 1 use:<BR><CODE>SCI_MARKERDEFINE(1, 
SC_MARK_CHARACTER+65)</CODE>. <BR>
<P>The marker numbers <CODE>SC_MARKNUM_FOLDER</CODE> and 
<CODE>SC_MARKNUM_FOLDEROPEN</CODE> are used for showing that a fold is present 
and open or closed. Any symbols may be assigned for this purpose although the 
(<CODE>SC_MARK_PLUS</CODE>, <CODE>SC_MARK_MINUS</CODE>) pair or the 
(<CODE>SC_MARK_ARROW</CODE>, <CODE>SC_MARK_ARROWDOWN</CODE>) pair are good 
choices. As well as these two, more assignments are needed for the flattened 
tree style: <CODE>SC_MARKNUM_FOLDEREND</CODE>, 
<CODE>SC_MARKNUM_FOLDERMIDTAIL</CODE>, <CODE>SC_MARKNUM_FOLDEROPENMID</CODE>, 
<CODE>SC_MARKNUM_FOLDERSUB</CODE>, and <CODE>SC_MARKNUM_FOLDERTAIL</CODE>. The 
bits used for folding are specified by <CODE>SC_MASK_FOLDERS</CODE>, which is 
commonly used as an argument to <CODE>SCI_SETMARGINMASKN</CODE> when defining a 
margin to be used for folding.</P>
<P>This table shows which <CODE>SC_MARK_</CODE>* symbols should be assigned to 
which <CODE>SC_MARKNUM_</CODE>* marker numbers to obtain four folding styles: 
Arrow (mimics Macintosh), plus/minus shows folded lines as '+' and opened folds 
as '-', Circle tree, Box tree.</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Markers used for folding" 
  border=0><THEAD align=left>
  <TR>
    <TH><CODE>SC_MARKNUM_</CODE>*</TH>
    <TH>Arrow</TH>
    <TH>Plus/minus</TH>
    <TH>Circle tree</TH>
    <TH>Box tree</TH></TR></THEAD>
  <TBODY vAlign=top>
  <TR>
    <TH align=left><CODE>FOLDEROPEN</CODE></TH>
    <TD><CODE>ARROWDOWN</CODE></TD>
    <TD><CODE>MINUS</CODE></TD>
    <TD><CODE>CIRCLEMINUS</CODE></TD>
    <TD><CODE>BOXMINUS</CODE></TD></TR>
  <TR>
    <TH align=left><CODE>FOLDER</CODE></TH>
    <TD><CODE>ARROW</CODE></TD>
    <TD><CODE>PLUS</CODE></TD>
    <TD><CODE>CIRCLEPLUS</CODE></TD>
    <TD><CODE>BOXPLUS</CODE></TD></TR>
  <TR>
    <TH align=left><CODE>FOLDERSUB</CODE></TH>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>VLINE</CODE></TD>
    <TD><CODE>VLINE</CODE></TD></TR>
  <TR>
    <TH align=left><CODE>FOLDERTAIL</CODE></TH>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>LCORNERCURVE</CODE></TD>
    <TD><CODE>LCORNER</CODE></TD></TR>
  <TR>
    <TH align=left><CODE>FOLDEREND</CODE></TH>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>CIRCLEPLUSCONNECTED</CODE></TD>
    <TD><CODE>BOXPLUSCONNECTED</CODE></TD></TR>
  <TR>
    <TH align=left><CODE>FOLDEROPENMID</CODE></TH>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>CIRCLEMINUSCONNECTED</CODE></TD>
    <TD><CODE>BOXMINUSCONNECTED</CODE></TD></TR>
  <TR>
    <TH align=left><CODE>FOLDERMIDTAIL</CODE></TH>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>EMPTY</CODE></TD>
    <TD><CODE>TCORNERCURVE</CODE></TD>
    <TD><CODE>TCORNER</CODE></TD></TR></TBODY></TABLE>
<P><B id=SCI_MARKERDEFINEPIXMAP>SCI_MARKERDEFINEPIXMAP(int markerNumber, const 
char *xpm)</B><BR>Markers can be set to pixmaps with this message. The XPM 
format is used for the pixmap and it is limited to pixmaps that use one 
character per pixel. The data should be null terminated. Pixmaps use the 
<CODE>SC_MARK_PIXMAP</CODE> marker symbol. You can find the full description of 
the XPM format <A class=jump 
href="http://koala.ilog.fr/lehors/xpm.html">here</A>.</P>
<P><B id=SCI_MARKERSETFORE>SCI_MARKERSETFORE(int markerNumber, int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_MARKERSETBACK>SCI_MARKERSETBACK(int markerNumber, int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR>These 
two messages set the foreground and background colour of a marker number.</P>
<P><B id=SCI_MARKERADD>SCI_MARKERADD(int line, int markerNumber)</B><BR>This 
message adds marker number <CODE>markerNumber</CODE> to a line. The message 
returns -1 if this fails (illegal line number, out of memory) or it returns a 
marker handle number that identifies the added marker. You can use this returned 
handle with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERLINEFROMHANDLE"><CODE>SCI_MARKERLINEFROMHANDLE</CODE></A> 
to find where a marker is after moving or combining lines and with <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERDELETEHANDLE"><CODE>SCI_MARKERDELETEHANDLE</CODE></A> 
to delete the marker based on its handle. The message does not check the value 
of markerNumber, nor does it check if the line already contains the marker.</P>
<P><B id=SCI_MARKERADDSET>SCI_MARKERADDSET(int line, int markerMask)</B><BR>This 
message can add one or more markers to a line with a single call, specified in 
the same "one-bit-per-marker" 32-bit integer format returned by <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERGET"><CODE>SCI_MARKERGET</CODE></A> 
(and used by the mask-based marker search functions <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERNEXT"><CODE>SCI_MARKERNEXT</CODE></A> 
and <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERPREVIOUS"><CODE>SCI_MARKERPREVIOUS</CODE></A>). 
As with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERADD"><CODE>SCI_MARKERADD</CODE></A>, 
no check is made to see if any of the markers are already present on the 
targeted line.</P>
<P><B id=SCI_MARKERDELETE>SCI_MARKERDELETE(int line, int 
markerNumber)</B><BR>This searches the given line number for the given marker 
number and deletes it if it is present. If you added the same marker more than 
once to the line, this will delete one copy each time it is used. If you pass in 
a marker number of -1, all markers are deleted from the line.</P>
<P><B id=SCI_MARKERDELETEALL>SCI_MARKERDELETEALL(int markerNumber)</B><BR>This 
removes markers of the given number from all lines. If markerNumber is -1, it 
deletes all markers from all lines.</P>
<P><B id=SCI_MARKERGET>SCI_MARKERGET(int line)</B><BR>This returns a 32-bit 
integer that indicates which markers were present on the line. Bit 0 is set if 
marker 0 is present, bit 1 for marker 1 and so on.</P>
<P><B id=SCI_MARKERNEXT>SCI_MARKERNEXT(int lineStart, int markerMask)</B><BR><B 
id=SCI_MARKERPREVIOUS>SCI_MARKERPREVIOUS(int lineStart, int 
markerMask)</B><BR>These messages search efficiently for lines that include a 
given set of markers. The search starts at line number <CODE>lineStart</CODE> 
and continues forwards to the end of the file (<CODE>SCI_MARKERNEXT</CODE>) or 
backwards to the start of the file (<CODE>SCI_MARKERPREVIOUS</CODE>). The 
<CODE>markerMask</CODE> argument should have one bit set for each marker you 
wish to find. Set bit 0 to find marker 0, bit 1 for marker 1 and so on. The 
message returns the line number of the first line that contains one of the 
markers in <CODE>markerMask</CODE> or -1 if no marker is found.</P>
<P><B id=SCI_MARKERLINEFROMHANDLE>SCI_MARKERLINEFROMHANDLE(int 
markerHandle)</B><BR>The <CODE>markerHandle</CODE> argument is an identifier for 
a marker returned by <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERADD"><CODE>SCI_MARKERADD</CODE></A>. 
This function searches the document for the marker with this handle and returns 
the line number that contains it or -1 if it is not found.</P>
<P><B id=SCI_MARKERDELETEHANDLE>SCI_MARKERDELETEHANDLE(int 
markerHandle)</B><BR>The <CODE>markerHandle</CODE> argument is an identifier for 
a marker returned by <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERADD"><CODE>SCI_MARKERADD</CODE></A>. 
This function searches the document for the marker with this handle and deletes 
the marker if it is found.</P>
<H2 id=Indicators>Indicators</H2>
<P>By default, Scintilla organizes the style byte associated with each text byte 
as 5 bits of style information (for 32 styles) and 3 bits of indicator 
information for 3 independent indicators so that, for example, syntax errors, 
deprecated names and bad indentation could all be displayed at once. Indicators 
may be displayed as simple underlines, squiggly underlines, a line of small 'T' 
shapes, a line of diagonal hatching, a strike-out or a rectangle around the 
text.</P>
<P>The indicators are set using <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STARTSTYLING"><CODE>SCI_STARTSTYLING</CODE></A> 
with a <CODE>INDICS_MASK</CODE> mask and <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLING"><CODE>SCI_SETSTYLING</CODE></A> 
with the values <CODE>INDIC0_MASK</CODE>, <CODE>INDIC1_MASK</CODE> and 
<CODE>INDIC2_MASK</CODE>.</P>
<P>If you are using indicators in a buffer that has a lexer active (see <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETLEXER"><CODE>SCI_SETLEXER</CODE></A>), 
you must save lexing state information before setting any indicators and restore 
it afterwards. Use <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETENDSTYLED"><CODE>SCI_GETENDSTYLED</CODE></A> 
to retrieve the current "styled to" position and <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STARTSTYLING"><CODE>SCI_STARTSTYLING</CODE></A> 
to reset the styling position and mask (<CODE>0x1f </CODE>in the default layout 
of 5 style bits and 3 indicator bits) when you are done.</P>
<P>The number of bits used for styles can be altered with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLEBITS"><CODE>SCI_SETSTYLEBITS</CODE></A> 
from 0 to 7 bits. The remaining bits can be used for indicators, so there can be 
from 1 to 8 indicators. However, the <CODE>INDIC*_MASK</CODE> constants defined 
in <CODE>Scintilla.h</CODE> all assume 5 bits of styling information and 3 
indicators. If you use a different arrangement, you must define your own 
constants.</P>
<P>The <CODE>SCI_INDIC*</CODE> messages allow you to get and set the visual 
appearance of the indicators. They all use an <CODE>indicatorNumber</CODE> 
argument in the range 0 to 7 to set the indicator to style. With the default 
settings, only indicators 0, 1 and 2 will have any visible effect.</P><CODE><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_INDICSETSTYLE">SCI_INDICSETSTYLE(int 
indicatorNumber, int indicatorStyle)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_INDICGETSTYLE">SCI_INDICGETSTYLE(int 
indicatorNumber)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_INDICSETFORE">SCI_INDICSETFORE(int 
indicatorNumber, int colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_INDICGETFORE">SCI_INDICGETFORE(int 
indicatorNumber)</A><BR></CODE>
<P><B id=SCI_INDICSETSTYLE>SCI_INDICSETSTYLE(int indicatorNumber, int 
indicatorStyle)</B><BR><B id=SCI_INDICGETSTYLE>SCI_INDICGETSTYLE(int 
indicatorNumber)</B><BR>These two messages set and get the style for a 
particular indicator. The indicator styles currently available are:</P>
<TABLE cellSpacing=2 cellPadding=1 summary=Indicators border=0>
  <TBODY>
  <TR>
    <TH align=left>Symbol</TH>
    <TH>Value</TH>
    <TH align=left>Visual effect</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>INDIC_PLAIN</CODE></TD>
    <TD align=middle>0</TD>
    <TD>Underlined with a single, straight line.</TD></TR>
  <TR>
    <TD align=left><CODE>INDIC_SQUIGGLE</CODE></TD>
    <TD align=middle>1</TD>
    <TD>A squiggly underline.</TD></TR>
  <TR>
    <TD align=left><CODE>INDIC_TT</CODE></TD>
    <TD align=middle>2</TD>
    <TD>A line of small T shapes.</TD></TR>
  <TR>
    <TD align=left><CODE>INDIC_DIAGONAL</CODE></TD>
    <TD align=middle>3</TD>
    <TD>Diagonal hatching.</TD></TR>
  <TR>
    <TD align=left><CODE>INDIC_STRIKE</CODE></TD>
    <TD align=middle>4</TD>
    <TD>Strike out.</TD></TR>
  <TR>
    <TD align=left><CODE>INDIC_HIDDEN</CODE></TD>
    <TD align=middle>5</TD>
    <TD>An indicator with no visual effect.</TD></TR>
  <TR>
    <TD align=left><CODE>INDIC_BOX</CODE></TD>
    <TD align=middle>6</TD>
    <TD>A rectangle around the text.</TD></TR>
  <TR>
    <TD align=left><CODE>INDIC_ROUNDBOX</CODE></TD>
    <TD align=middle>6</TD>
    <TD>A rectangle with rounded corners around the text using translucent 
      drawing with the interior more transparent than the 
border.</TD></TR></TBODY></TABLE>
<P>The default indicator styles are equivalent to:<BR><CODE>SCI_INDICSETSTYLE(0, 
INDIC_SQUIGGLE);</CODE><BR><CODE>SCI_INDICSETSTYLE(1, 
INDIC_TT);</CODE><BR><CODE>SCI_INDICSETSTYLE(2, INDIC_PLAIN);</CODE></P>
<P><B id=SCI_INDICSETFORE>SCI_INDICSETFORE(int indicatorNumber, int <A 
class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_INDICGETFORE>SCI_INDICGETFORE(int indicatorNumber)</B><BR>These two 
messages set and get the colour used to draw an indicator. The default indicator 
colours are equivalent to:<BR><CODE>SCI_INDICSETFORE(0, 0x007f00);</CODE> (dark 
green)<BR><CODE>SCI_INDICSETFORE(1, 0xff0000);</CODE> (light 
blue)<BR><CODE>SCI_INDICSETFORE(2, 0x0000ff);</CODE> (light red)</P>
<H2 id=Autocompletion>Autocompletion</H2>
<P>Autocompletion displays a list box showing likely identifiers based upon the 
user's typing. The user chooses the currently selected item by pressing the tab 
character or another character that is a member of the fillup character set 
defined with <CODE>SCI_AUTOCSETFILLUPS</CODE>. Autocompletion is triggered by 
your application. For example, in C if you detect that the user has just typed 
<CODE>fred.</CODE> you could look up <CODE>fred</CODE>, and if it has a known 
list of members, you could offer them in an autocompletion list. Alternatively, 
you could monitor the user's typing and offer a list of likely items once their 
typing has narrowed down the choice to a reasonable list. As yet another 
alternative, you could define a key code to activate the list.</P>
<P>When the user makes a selection from the list the container is sent a 
<CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_AUTOCSELECTION">SCN_AUTOCSELECTION</A></CODE> 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">notification 
message</A>. On return from the notification Scintilla will insert the selected 
text unless the autocompletion list has been cancelled, for example by the 
container sending <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</A></CODE>.</P>
<P>To make use of autocompletion you must monitor each character added to the 
document. See <CODE>SciTEBase::CharAdded()</CODE> in SciTEBase.cxx for an 
example of autocompletion.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSHOW">SCI_AUTOCSHOW(int 
lenEntered, const char *list)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCACTIVE">SCI_AUTOCACTIVE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCPOSSTART">SCI_AUTOCPOSSTART</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCCOMPLETE">SCI_AUTOCCOMPLETE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSTOPS">SCI_AUTOCSTOPS(&lt;unused&gt;, 
const char *chars)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETSEPARATOR">SCI_AUTOCSETSEPARATOR(char 
separator)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETSEPARATOR">SCI_AUTOCGETSEPARATOR</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSELECT">SCI_AUTOCSELECT(&lt;unused&gt;, 
const char *select)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETCURRENT">SCI_AUTOCGETCURRENT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETCANCELATSTART">SCI_AUTOCSETCANCELATSTART(bool 
cancel)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETCANCELATSTART">SCI_AUTOCGETCANCELATSTART</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETFILLUPS">SCI_AUTOCSETFILLUPS(&lt;unused&gt;, 
const char *chars)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE(bool 
chooseSingle)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETCHOOSESINGLE">SCI_AUTOCGETCHOOSESINGLE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETIGNORECASE">SCI_AUTOCSETIGNORECASE(bool 
ignoreCase)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETIGNORECASE">SCI_AUTOCGETIGNORECASE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETAUTOHIDE">SCI_AUTOCSETAUTOHIDE(bool 
autoHide)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETAUTOHIDE">SCI_AUTOCGETAUTOHIDE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETDROPRESTOFWORD">SCI_AUTOCSETDROPRESTOFWORD(bool 
dropRestOfWord)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETDROPRESTOFWORD">SCI_AUTOCGETDROPRESTOFWORD</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_REGISTERIMAGE">SCI_REGISTERIMAGE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CLEARREGISTEREDIMAGES">SCI_CLEARREGISTEREDIMAGES</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETTYPESEPARATOR">SCI_AUTOCSETTYPESEPARATOR(char 
separatorCharacter)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETTYPESEPARATOR">SCI_AUTOCGETTYPESEPARATOR</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETMAXHEIGHT">SCI_AUTOCSETMAXHEIGHT(int 
rowCount)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETMAXHEIGHT">SCI_AUTOCGETMAXHEIGHT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETMAXWIDTH">SCI_AUTOCSETMAXWIDTH(int 
characterCount)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETMAXWIDTH">SCI_AUTOCGETMAXWIDTH</A><BR></CODE>
<P><B id=SCI_AUTOCSHOW>SCI_AUTOCSHOW(int lenEntered, const char 
*list)</B><BR>This message causes a list to be displayed. 
<CODE>lenEntered</CODE> is the number of characters of the word already entered 
and <CODE>list</CODE> is the list of words separated by separator characters. 
The initial separator character is a space but this can be set or got with <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETSEPARATOR"><CODE>SCI_AUTOCSETSEPARATOR</CODE></A> 
and <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCGETSEPARATOR"><CODE>SCI_AUTOCGETSEPARATOR</CODE></A>.</P>
<P>The list of words should be in sorted order. If set to ignore case mode with 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETIGNORECASE"><CODE>SCI_AUTOCSETIGNORECASE</CODE></A>, 
then strings are matched after being converted to upper case. One result of this 
is that the list should be sorted with the punctuation characters '[', '\', ']', 
'^', '_', and '`' sorted after letters.</P>
<P><B id=SCI_AUTOCCANCEL>SCI_AUTOCCANCEL</B><BR>This message cancels any 
displayed autocompletion list. When in autocompletion mode, the list should 
disappear when the user types a character that can not be part of the 
autocompletion, such as '.', '(' or '[' when typing an identifier. A set of 
characters that will cancel autocompletion can be specified with <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSTOPS"><CODE>SCI_AUTOCSTOPS</CODE></A>.</P>
<P><B id=SCI_AUTOCACTIVE>SCI_AUTOCACTIVE</B><BR>This message returns non-zero if 
there is an active autocompletion list and zero if there is not.</P>
<P><B id=SCI_AUTOCPOSSTART>SCI_AUTOCPOSSTART</B><BR>This returns the value of 
the current position when <CODE>SCI_AUTOCSHOW</CODE> started display of the 
list.</P>
<P><B id=SCI_AUTOCCOMPLETE>SCI_AUTOCCOMPLETE</B><BR>This message triggers 
autocompletion. This has the same effect as the tab key.</P>
<P><B id=SCI_AUTOCSTOPS>SCI_AUTOCSTOPS(&lt;unused&gt;, const char 
*chars)</B><BR>The <CODE>chars</CODE> argument is a string containing a list of 
characters that will automatically cancel the autocompletion list. When you 
start the editor, this list is empty.</P>
<P><B id=SCI_AUTOCSETSEPARATOR>SCI_AUTOCSETSEPARATOR(char separator)</B><BR><B 
id=SCI_AUTOCGETSEPARATOR>SCI_AUTOCGETSEPARATOR</B><BR>These two messages set and 
get the separator character used to separate words in the 
<CODE>SCI_AUTOCSHOW</CODE> list. The default is the space character.</P>
<P><B id=SCI_AUTOCSELECT>SCI_AUTOCSELECT(&lt;unused&gt;, const char 
*select)</B><BR><B id=SCI_AUTOCGETCURRENT>SCI_AUTOCGETCURRENT</B><BR>This 
message selects an item in the autocompletion list. It searches the list of 
words for the first that matches <CODE>select</CODE>. By default, comparisons 
are case sensitive, but you can change this with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETIGNORECASE"><CODE>SCI_AUTOCSETIGNORECASE</CODE></A>. 
The match is character by character for the length of the <CODE>select</CODE> 
string. That is, if select is "Fred" it will match "Frederick" if this is the 
first item in the list that begins with "Fred". If an item is found, it is 
selected. If the item is not found, the autocompletion list closes if auto-hide 
is true (see <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETAUTOHIDE"><CODE>SCI_AUTOCSETAUTOHIDE</CODE></A>).<BR>The 
current selection can be retrieved with <CODE>SCI_AUTOCGETCURRENT</CODE> </P>
<P><B id=SCI_AUTOCSETCANCELATSTART>SCI_AUTOCSETCANCELATSTART(bool 
cancel)</B><BR><B 
id=SCI_AUTOCGETCANCELATSTART>SCI_AUTOCGETCANCELATSTART</B><BR>The default 
behavior is for the list to be cancelled if the caret moves before the location 
it was at when the list was displayed. By calling this message with a 
<CODE>false</CODE> argument, the list is not cancelled until the caret moves 
before the first character of the word being completed.</P>
<P><B id=SCI_AUTOCSETFILLUPS>SCI_AUTOCSETFILLUPS(&lt;unused&gt;, const char 
*chars)</B><BR>If a fillup character is typed with an autocompletion list 
active, the currently selected item in the list is added into the document, then 
the fillup character is added. Common fillup characters are '(', '[' and '.' but 
others are possible depending on the language. By default, no fillup characters 
are set.</P>
<P><B id=SCI_AUTOCSETCHOOSESINGLE>SCI_AUTOCSETCHOOSESINGLE(bool 
chooseSingle)</B><BR><B 
id=SCI_AUTOCGETCHOOSESINGLE>SCI_AUTOCGETCHOOSESINGLE</B><BR>If you use 
<CODE>SCI_AUTOCSETCHOOSESINGLE(1)</CODE> and a list has only one item, it is 
automatically added and no list is displayed. The default is to display the list 
even if there is only a single item.</P>
<P><B id=SCI_AUTOCSETIGNORECASE>SCI_AUTOCSETIGNORECASE(bool 
ignoreCase)</B><BR><B id=SCI_AUTOCGETIGNORECASE>SCI_AUTOCGETIGNORECASE</B><BR>By 
default, matching of characters to list members is case sensitive. These 
messages let you set and get case sensitivity.</P>
<P><B id=SCI_AUTOCSETAUTOHIDE>SCI_AUTOCSETAUTOHIDE(bool autoHide)</B><BR><B 
id=SCI_AUTOCGETAUTOHIDE>SCI_AUTOCGETAUTOHIDE</B><BR>By default, the list is 
cancelled if there are no viable matches (the user has typed characters that no 
longer match a list entry). If you want to keep displaying the original list, 
set <CODE>autoHide</CODE> to <CODE>false</CODE>. This also effects <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSELECT"><CODE>SCI_AUTOCSELECT</CODE></A>.</P>
<P><B id=SCI_AUTOCSETDROPRESTOFWORD>SCI_AUTOCSETDROPRESTOFWORD(bool 
dropRestOfWord)</B><BR><B 
id=SCI_AUTOCGETDROPRESTOFWORD>SCI_AUTOCGETDROPRESTOFWORD</B><BR>When an item is 
selected, any word characters following the caret are first erased if 
<CODE>dropRestOfWord</CODE> is set <CODE>true</CODE>. The default is 
<CODE>false</CODE>.</P>
<P><B id=SCI_REGISTERIMAGE>SCI_REGISTERIMAGE(int type, const char 
*xpmData)</B><BR><B 
id=SCI_CLEARREGISTEREDIMAGES>SCI_CLEARREGISTEREDIMAGES</B><BR><B 
id=SCI_AUTOCSETTYPESEPARATOR>SCI_AUTOCSETTYPESEPARATOR(char 
separatorCharacter)</B><BR><B 
id=SCI_AUTOCGETTYPESEPARATOR>SCI_AUTOCGETTYPESEPARATOR</B><BR>Autocompletion 
list items may display an image as well as text. Each image is first registered 
with an integer type. Then this integer is included in the text of the list 
separated by a '?' from the text. For example, "fclose?2 fopen" displays image 2 
before the string "fclose" and no image before "fopen". The images are in XPM 
format as is described for <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_MARKERDEFINEPIXMAP"><CODE>SCI_MARKERDEFINEPIXMAP</CODE></A> 
The set of registered images can be cleared with 
<CODE>SCI_CLEARREGISTEREDIMAGES</CODE> and the '?' separator changed with 
<CODE>SCI_AUTOCSETTYPESEPARATOR</CODE>. </P>
<P><B id=SCI_AUTOCSETMAXHEIGHT>SCI_AUTOCSETMAXHEIGHT(int rowCount)</B><BR><B 
id=SCI_AUTOCGETMAXHEIGHT>SCI_AUTOCGETMAXHEIGHT</B><BR>Get or set the maximum 
number of rows that will be visible in an autocompletion list. If there are more 
rows in the list, then a vertical scrollbar is shown. The default is 5. </P>
<P><B id=SCI_AUTOCSETMAXWIDTH>SCI_AUTOCSETMAXWIDTH(int characterCount)</B><BR><B 
id=SCI_AUTOCGETMAXWIDTH>SCI_AUTOCGETMAXWIDTH</B><BR>Get or set the maximum width 
of an autocompletion list expressed as the number of characters in the longest 
item that will be totally visible. If zero (the default) then the list's width 
is calculated to fit the item with the most characters. Any items that cannot be 
fully displayed within the available width are indicated by the presence of 
ellipsis. </P>
<H2 id=UserLists>User lists</H2>
<P>User lists use the same internal mechanisms as autocompletion lists, and all 
the calls listed for autocompletion work on them; you cannot display a user list 
at the same time as an autocompletion list is active. They differ in the 
following respects:</P>
<P>o The <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE</A></CODE> 
message has no effect.<BR>o When the user makes a selection you are sent a 
<CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_USERLISTSELECTION">SCN_USERLISTSELECTION</A></CODE> 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">notification 
message</A> rather than <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_AUTOCSELECTION">SCN_AUTOCSELECTION</A></CODE>.</P>
<P>BEWARE: if you have set fillup characters or stop characters, these will 
still be active with the user list, and may result in items being selected or 
the user list cancelled due to the user typing into the editor.</P>
<P><B id=SCI_USERLISTSHOW>SCI_USERLISTSHOW(int listType, const char 
*list)</B><BR>The <CODE>listType</CODE> parameter is returned to the container 
as the <CODE>wParam</CODE> field of the <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCNotification"><CODE>SCNotification</CODE></A> 
structure. It must be greater than 0 as this is how Scintilla tells the 
difference between an autocompletion list and a user list. If you have different 
types of list, for example a list of buffers and a list of macros, you can use 
<CODE>listType</CODE> to tell which one has returned a selection. </P>
<H2 id=CallTips>Call tips</H2>
<P>Call tips are small windows displaying the arguments to a function and are 
displayed after the user has typed the name of the function. They normally 
display characters using the font facename, size and character set defined by 
<CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition">STYLE_DEFAULT</A></CODE>. 
You can choose to use <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition">STYLE_CALLTIP</A></CODE> 
to define the facename, size, foreground and background colours and character 
set with <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPUSESTYLE">SCI_CALLTIPUSESTYLE</A></CODE>. 
This also enables support for Tab characters. There is some interaction between 
call tips and autocompletion lists in that showing a call tip cancels any active 
autocompletion list, and vice versa.</P>
<P>Call tips can highlight part of the text within them. You could use this to 
highlight the current argument to a function by counting the number of commas 
(or whatever separator your language uses). See 
<CODE>SciTEBase::CharAdded()</CODE> in <CODE>SciTEBase.cxx</CODE> for an example 
of call tip use.</P>
<P>The mouse may be clicked on call tips and this causes a <CODE><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_CALLTIPCLICK">SCN_CALLTIPCLICK</A></CODE> 
notification to be sent to the container. Small up an down arrows may be 
displayed within a call tip by, respectively, including the characters '\001', 
or '\002'. This is useful for showing that there are overloaded variants of one 
function name and that the user can click on the arrows to cycle through the 
overloads.</P>
<P>Alternatively, call tips can be displayed when you leave the mouse pointer 
for a while over a word in response to the <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_DWELLSTART">SCN_DWELLSTART</A></CODE> 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">notification</A> 
and cancelled in response to <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_DWELLEND">SCN_DWELLEND</A></CODE>. 
This method could be used in a debugger to give the value of a variable, or 
during editing to give information about the word under the pointer.</P><CODE><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPSHOW">SCI_CALLTIPSHOW(int 
posStart, const char *definition)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPCANCEL">SCI_CALLTIPCANCEL</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPACTIVE">SCI_CALLTIPACTIVE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPPOSSTART">SCI_CALLTIPPOSSTART</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPSETHLT">SCI_CALLTIPSETHLT(int 
highlightStart, int highlightEnd)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPSETBACK">SCI_CALLTIPSETBACK(int 
colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPSETFORE">SCI_CALLTIPSETFORE(int 
colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPSETFOREHLT">SCI_CALLTIPSETFOREHLT(int 
colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPUSESTYLE">SCI_CALLTIPUSESTYLE(int 
tabsize)</A><BR></CODE>
<P><B id=SCI_CALLTIPSHOW>SCI_CALLTIPSHOW(int posStart, const char 
*definition)</B><BR>This message starts the process by displaying the call tip 
window. If a call tip is already active, this has no 
effect.<BR><CODE>posStart</CODE> is the position in the document at which to 
align the call tip. The call tip text is aligned to start 1 line below this 
character unless you have included up and/or down arrows in the call tip text in 
which case the tip is aligned to the right-hand edge of the rightmost arrow. The 
assumption is that you will start the text with something like "\001 1 of 3 
\002".<BR><CODE>definition</CODE> is the call tip text. This can contain 
multiple lines separated by '\n' (Line Feed, ASCII code 10) characters. Do not 
include '\r' (Carriage Return, ASCII code 13), as this will most likely print as 
an empty box. '\t' (Tab, ASCII code 9) is supported if you set a tabsize with 
<CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CALLTIPUSESTYLE">SCI_CALLTIPUSESTYLE</A></CODE>.<BR></P>
<P><B id=SCI_CALLTIPCANCEL>SCI_CALLTIPCANCEL</B><BR>This message cancels any 
displayed call tip. Scintilla will also cancel call tips for you if you use any 
keyboard commands that are not compatible with editing the argument list of a 
function.</P>
<P><B id=SCI_CALLTIPACTIVE>SCI_CALLTIPACTIVE</B><BR>This returns 1 if a call tip 
is active and 0 if it is not active.</P>
<P><B id=SCI_CALLTIPPOSSTART>SCI_CALLTIPPOSSTART</B><BR>This message returns the 
value of the current position when <CODE>SCI_CALLTIPSHOW</CODE> started to 
display the tip.</P>
<P><B id=SCI_CALLTIPSETHLT>SCI_CALLTIPSETHLT(int hlStart, int hlEnd)</B><BR>This 
sets the region of the call tips text to display in a highlighted style. 
<CODE>hlStart</CODE> is the zero-based index into the string of the first 
character to highlight and <CODE>hlEnd</CODE> is the index of the first 
character after the highlight. <CODE>hlEnd</CODE> must be greater than 
<CODE>hlStart</CODE>; <CODE>hlEnd-hlStart</CODE> is the number of characters to 
highlight. Highlights can extend over line ends if this is required.</P>
<P>Unhighlighted text is drawn in a mid gray. Selected text is drawn in a dark 
blue. The background is white. These can be changed with 
<CODE>SCI_CALLTIPSETBACK</CODE>, <CODE>SCI_CALLTIPSETFORE</CODE>, and 
<CODE>SCI_CALLTIPSETFOREHLT</CODE>. </P>
<P><B id=SCI_CALLTIPSETBACK>SCI_CALLTIPSETBACK(int colour)</B><BR>The background 
colour of call tips can be set with this message; the default colour is white. 
It is not a good idea to set a dark colour as the background as the default 
colour for normal calltip text is mid gray and the defaultcolour for highlighted 
text is dark blue. This also sets the background colour of 
<CODE>STYLE_CALLTIP</CODE>.</P>
<P><B id=SCI_CALLTIPSETFORE>SCI_CALLTIPSETFORE(int colour)</B><BR>The colour of 
call tip text can be set with this message; the default colour is mid gray. This 
also sets the foreground colour of <CODE>STYLE_CALLTIP</CODE>.</P>
<P><B id=SCI_CALLTIPSETFOREHLT>SCI_CALLTIPSETFOREHLT(int colour)</B><BR>The 
colour of highlighted call tip text can be set with this message; the default 
colour is dark blue.</P>
<P><B id=SCI_CALLTIPUSESTYLE>SCI_CALLTIPUSESTYLE(int tabsize)</B><BR>This 
message changes the style used for call tips from <CODE>STYLE_DEFAULT</CODE> to 
<CODE>STYLE_CALLTIP</CODE> and sets a tab size in screen pixels. If 
<CODE>tabsize</CODE> is less than 1, Tab characters are not treated specially. 
Once this call has been used, the call tip foreground and background colours are 
also taken from the style.</P>
<H2 id=KeyboardCommands>Keyboard commands</H2>
<P>To allow the container application to perform any of the actions available to 
the user with keyboard, all the keyboard actions are messages. They do not take 
any parameters. These commands are also used when redefining the key bindings 
with the <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ASSIGNCMDKEY"><CODE>SCI_ASSIGNCMDKEY</CODE></A> 
message.</P>
<TABLE summary="Keyboard commands" border=0>
  <TBODY>
  <TR>
    <TD><CODE>SCI_LINEDOWN</CODE></TD>
    <TD><CODE>SCI_LINEDOWNEXTEND</CODE></TD>
    <TD><CODE>SCI_LINEDOWNRECTEXTEND</CODE></TD>
    <TD><CODE>SCI_LINESCROLLDOWN</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_LINEUP</CODE></TD>
    <TD><CODE>SCI_LINEUPEXTEND</CODE></TD>
    <TD><CODE>SCI_LINEUPRECTEXTEND</CODE></TD>
    <TD><CODE>SCI_LINESCROLLUP</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_PARADOWN</CODE></TD>
    <TD><CODE>SCI_PARADOWNEXTEND</CODE></TD>
    <TD><CODE>SCI_PARAUP</CODE></TD>
    <TD><CODE>SCI_PARAUPEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_CHARLEFT</CODE></TD>
    <TD><CODE>SCI_CHARLEFTEXTEND</CODE></TD>
    <TD><CODE>SCI_CHARLEFTRECTEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_CHARRIGHT</CODE></TD>
    <TD><CODE>SCI_CHARRIGHTEXTEND</CODE></TD>
    <TD><CODE>SCI_CHARRIGHTRECTEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_WORDLEFT</CODE></TD>
    <TD><CODE>SCI_WORDLEFTEXTEND</CODE></TD>
    <TD><CODE>SCI_WORDRIGHT</CODE></TD>
    <TD><CODE>SCI_WORDRIGHTEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_WORDLEFTEND</CODE></TD>
    <TD><CODE>SCI_WORDLEFTENDEXTEND</CODE></TD>
    <TD><CODE>SCI_WORDRIGHTEND</CODE></TD>
    <TD><CODE>SCI_WORDRIGHTENDEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_WORDPARTLEFT</CODE></TD>
    <TD><CODE>SCI_WORDPARTLEFTEXTEND</CODE></TD>
    <TD><CODE>SCI_WORDPARTRIGHT</CODE></TD>
    <TD><CODE>SCI_WORDPARTRIGHTEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_HOME</CODE></TD>
    <TD><CODE>SCI_HOMEEXTEND</CODE></TD>
    <TD><CODE>[SCI_HOMERECTEXTEND]</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_HOMEDISPLAY</CODE></TD>
    <TD><CODE>SCI_HOMEDISPLAYEXTEND</CODE></TD>
    <TD><CODE>SCI_HOMEWRAP</CODE></TD>
    <TD><CODE>SCI_HOMEWRAPEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_VCHOME</CODE></TD>
    <TD><CODE>SCI_VCHOMEEXTEND</CODE></TD>
    <TD><CODE>SCI_VCHOMERECTEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_VCHOMEWRAP</CODE></TD>
    <TD><CODE>SCI_VCHOMEWRAPEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_LINEEND</CODE></TD>
    <TD><CODE>SCI_LINEENDEXTEND</CODE></TD>
    <TD><CODE>SCI_LINEENDRECTEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_LINEENDDISPLAY</CODE></TD>
    <TD><CODE>SCI_LINEENDDISPLAYEXTEND</CODE></TD>
    <TD><CODE>SCI_LINEENDWRAP</CODE></TD>
    <TD><CODE>SCI_LINEENDWRAPEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_DOCUMENTSTART</CODE></TD>
    <TD><CODE>SCI_DOCUMENTSTARTEXTEND</CODE></TD>
    <TD><CODE>SCI_DOCUMENTEND</CODE></TD>
    <TD><CODE>SCI_DOCUMENTENDEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_PAGEUP</CODE></TD>
    <TD><CODE>SCI_PAGEUPEXTEND</CODE></TD>
    <TD><CODE>SCI_PAGEUPRECTEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_PAGEDOWN</CODE></TD>
    <TD><CODE>SCI_PAGEDOWNEXTEND</CODE></TD>
    <TD><CODE>SCI_PAGEDOWNRECTEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_STUTTEREDPAGEUP</CODE></TD>
    <TD><CODE>SCI_STUTTEREDPAGEUPEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_STUTTEREDPAGEDOWN</CODE></TD>
    <TD><CODE>SCI_STUTTEREDPAGEDOWNEXTEND</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_DELETEBACK</CODE></TD>
    <TD><CODE>SCI_DELETEBACKNOTLINE</CODE></TD>
    <TD><CODE>SCI_DELWORDLEFT</CODE></TD>
    <TD><CODE>SCI_DELWORDRIGHT</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_DELLINELEFT</CODE></TD>
    <TD><CODE>SCI_DELLINERIGHT</CODE></TD>
    <TD><CODE>SCI_LINEDELETE</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_LINECUT</CODE></TD>
    <TD><CODE>SCI_LINECOPY</CODE></TD>
    <TD><CODE>SCI_LINETRANSPOSE</CODE></TD>
    <TD><CODE>SCI_LINEDUPLICATE</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_LOWERCASE</CODE></TD>
    <TD><CODE>SCI_UPPERCASE</CODE></TD>
    <TD><CODE>SCI_CANCEL</CODE></TD>
    <TD><CODE>SCI_EDITTOGGLEOVERTYPE</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_NEWLINE</CODE></TD>
    <TD><CODE>SCI_FORMFEED</CODE></TD>
    <TD><CODE>SCI_TAB</CODE></TD>
    <TD><CODE>SCI_BACKTAB</CODE></TD></TR>
  <TR>
    <TD><CODE>SCI_SELECTIONDUPLICATE</CODE></TD></TR></TBODY></TABLE>
<P>The <CODE>SCI_*EXTEND</CODE> messages extend the selection.</P>
<P>The <CODE>SCI_*RECTEXTEND</CODE> messages extend the rectangular selection 
(and convert regular selection to rectangular one, if any).</P>
<P>The <CODE>SCI_WORDPART*</CODE> commands are used to move between word 
segments marked by capitalisation (aCamelCaseIdentifier) or underscores 
(an_under_bar_ident).</P>
<P>The <CODE>SCI_HOME*</CODE> commands move the caret to the start of the line, 
while the <CODE>SCI_VCHOME*</CODE>commands move the caret to the first non-blank 
character of the line (ie. just after the indentation) unless it is already 
there; in this case, it acts as SCI_HOME*.</P>
<P>The <CODE>SCI_[HOME|LINEEND]DISPLAY*</CODE> commands are used when in line 
wrap mode to allow movement to the start or end of display lines as opposed to 
the normal <CODE>SCI_[HOME|LINEEND]</CODE> commands which move to the start or 
end of document lines.</P>
<P>The <CODE>SCI_[[VC]HOME|LINEEND]WRAP*</CODE> commands are like their 
namesakes <CODE>SCI_[[VC]HOME|LINEEND]*</CODE> except they behave differently 
when word-wrap is enabled: They go first to the start / end of the display line, 
like <CODE>SCI_[HOME|LINEEND]DISPLAY*</CODE>, but if the cursor is already at 
the point, it goes on to the start or end of the document line, as appropriate 
for <CODE>SCI_[[VC]HOME|LINEEND]*</CODE>. </P>
<H2 id=KeyBindings>Key bindings</H2>
<P>There is a default binding of keys to commands that is defined in the 
Scintilla source in the file <CODE>KeyMap.cxx</CODE> by the constant 
<CODE>KeyMap::MapDefault[]</CODE>. This table maps key definitions to 
<CODE>SCI_*</CODE> messages with no parameters (mostly the <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#KeyboardCommands">keyboard 
commands</A> discussed above, but any Scintilla command that has no arguments 
can be mapped). You can change the mapping to suit your own 
requirements.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ASSIGNCMDKEY">SCI_ASSIGNCMDKEY(int 
keyDefinition, int sciCommand)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CLEARCMDKEY">SCI_CLEARCMDKEY(int 
keyDefinition)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CLEARALLCMDKEYS">SCI_CLEARALLCMDKEYS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_NULL">SCI_NULL</A><BR></CODE>
<P><B id=keyDefinition>keyDefinition</B><BR>A key definition contains the key 
code in the low 16-bits and the key modifiers in the high 16-bits. To combine 
<CODE>keyCode</CODE> and <CODE>keyMod</CODE> set:<BR><BR><CODE>keyDefinition = 
keyCode + (keyMod &lt;&lt; 16)</CODE></P>
<P>The key code is a visible or control character or a key from the 
<CODE>SCK_*</CODE> enumeration, which contains:<BR><CODE>SCK_ADD</CODE>, 
<CODE>SCK_BACK</CODE>, <CODE>SCK_DELETE</CODE>, <CODE>SCK_DIVIDE</CODE>, 
<CODE>SCK_DOWN</CODE>, <CODE>SCK_END</CODE>, <CODE>SCK_ESCAPE</CODE>, 
<CODE>SCK_HOME</CODE>, <CODE>SCK_INSERT</CODE>, <CODE>SCK_LEFT</CODE>, 
<CODE>SCK_NEXT</CODE> (Page Down), <CODE>SCK_PRIOR</CODE> (Page Up), 
<CODE>SCK_RETURN</CODE>, <CODE>SCK_RIGHT</CODE>, <CODE>SCK_SUBTRACT</CODE>, 
<CODE>SCK_TAB</CODE>, and <CODE>SCK_UP</CODE>.</P>
<P>The modifiers are a combination of zero or more of <CODE>SCMOD_ALT</CODE>, 
<CODE>SCMOD_CTRL</CODE>, and <CODE>SCMOD_SHIFT</CODE>. If you are building a 
table, you might want to use <CODE>SCMOD_NORM</CODE>, which has the value 0, to 
mean no modifiers.</P>
<P><B id=SCI_ASSIGNCMDKEY>SCI_ASSIGNCMDKEY(int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#keyDefinition">keyDefinition</A>, 
int sciCommand)</B><BR>This assigns the given key definition to a Scintilla 
command identified by <CODE>sciCommand</CODE>. <CODE>sciCommand</CODE> can be 
any <CODE>SCI_*</CODE> command that has no arguments.</P>
<P><B id=SCI_CLEARCMDKEY>SCI_CLEARCMDKEY(int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#keyDefinition">keyDefinition</A>)</B><BR>This 
makes the given key definition do nothing by assigning the action 
<CODE>SCI_NULL</CODE> to it.</P>
<P><B id=SCI_CLEARALLCMDKEYS>SCI_CLEARALLCMDKEYS</B><BR>This command removes all 
keyboard command mapping by setting an empty mapping table.</P>
<P><B id=SCI_NULL>SCI_NULL</B><BR>The <CODE>SCI_NULL</CODE> does nothing and is 
the value assigned to keys that perform no action. SCI_NULL ensures that keys do 
not propagate to the parent window as that may cause focus to move. If you want 
the standard platform behaviour use the constant 0 instead.</P>
<H2 id=PopupEditMenu>Popup edit menu</H2>
<P><B id=SCI_USEPOPUP>SCI_USEPOPUP(bool bEnablePopup)</B><BR>Clicking the wrong 
button on the mouse pops up a short default editing menu. This may be turned off 
with <CODE>SCI_USEPOPUP(0)</CODE>. If you turn it off, context menu commands (in 
Windows, <CODE>WM_CONTEXTMENU</CODE>) will not be handled by Scintilla, so the 
parent of the Scintilla window will have the opportunity to handle the 
message.</P>
<H2 id=MacroRecording>Macro recording</H2>
<P>Start and stop macro recording mode. In macro recording mode, actions are 
reported to the container through <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MACRORECORD">SCN_MACRORECORD</A></CODE> 
<A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Notifications">notifications</A>. 
It is then up to the container to record these actions for future replay.</P>
<P><B id=SCI_STARTRECORD>SCI_STARTRECORD</B><BR><B 
id=SCI_STOPRECORD>SCI_STOPRECORD</B><BR>These two messages turn macro recording 
on and off.</P>
<H2 id=Printing>Printing</H2>
<P>On Windows <CODE>SCI_FORMATRANGE</CODE> can be used to draw the text onto a 
display context which can include a printer display context. Printed output 
shows text styling as on the screen, but it hides all margins except a line 
number margin. All special marker effects are removed and the selection and 
caret are hidden.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_FORMATRANGE">SCI_FORMATRANGE(bool 
bDraw, RangeToFormat *pfr)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETPRINTMAGNIFICATION">SCI_SETPRINTMAGNIFICATION(int 
magnification)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETPRINTMAGNIFICATION">SCI_GETPRINTMAGNIFICATION</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETPRINTCOLOURMODE">SCI_SETPRINTCOLOURMODE(int 
mode)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETPRINTCOLOURMODE">SCI_GETPRINTCOLOURMODE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETPRINTWRAPMODE">SCI_SETPRINTWRAPMODE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETPRINTWRAPMODE">SCI_GETPRINTWRAPMODE</A><BR></CODE>
<P><B id=SCI_FORMATRANGE>SCI_FORMATRANGE(bool bDraw, RangeToFormat 
*pfr)</B><BR>This call allows Windows users to render a range of text into a 
device context. If you use this for printing, you will probably want to arrange 
a page header and footer; Scintilla does not do this for you. See 
<CODE>SciTEWin::Print()</CODE> in <CODE>SciTEWinDlg.cxx</CODE> for an example. 
Each use of this message renders a range of text into a rectangular area and 
returns the position in the document of the next character to print.</P>
<P><CODE>bDraw</CODE> controls if any output is done. Set this to false if you 
are paginating (for example, if you use this with MFC you will need to paginate 
in <CODE>OnBeginPrinting()</CODE> before you output each page.</P><PRE>struct RangeToFormat {
    SurfaceID hdc;        // The HDC (device context) we print to
    SurfaceID hdcTarget;  // The HDC we use for measuring (may be same as hdc)
    PRectangle rc;        // Rectangle in which to print
    PRectangle rcPage;    // Physically printable page size
    CharacterRange chrg;  // Range of characters to print
};
</PRE>
<P><CODE>hdc</CODE> and <CODE>hdcTarget</CODE> should both be set to the device 
context handle of the output device (usually a printer). If you print to a 
metafile these will not be the same as Windows metafiles (unlike extended 
metafiles) do not implement the full API for returning information. In this 
case, set <CODE>hdcTarget</CODE> to the screen DC.<BR><CODE>rcPage</CODE> is the 
rectangle <CODE>{0, 0, maxX, maxY}</CODE> where <CODE>maxX+1</CODE> and 
<CODE>maxY+1</CODE> are the number of physically printable pixels in x and 
y.<BR><CODE>rc</CODE> is the rectangle to render the text in (which will, of 
course, fit within the rectangle defined by rcPage).<BR><CODE>chrg.cpMin</CODE> 
and <CODE>chrg.cpMax</CODE> define the start position and maximum position of 
characters to output. All of each line within this character range is drawn.</P>
<P>When printing, the most tedious part is always working out what the margins 
should be to allow for the non-printable area of the paper and printing a header 
and footer. If you look at the printing code in SciTE, you will find that most 
of it is taken up with this. The loop that causes Scintilla to render text is 
quite simple if you strip out all the margin, non-printable area, header and 
footer code.</P>
<P><B id=SCI_SETPRINTMAGNIFICATION>SCI_SETPRINTMAGNIFICATION(int 
magnification)</B><BR><B 
id=SCI_GETPRINTMAGNIFICATION>SCI_GETPRINTMAGNIFICATION</B><BR><CODE>SCI_GETPRINTMAGNIFICATION</CODE> 
lets you to print at a different size than the screen font. 
<CODE>magnification</CODE> is the number of points to add to the size of each 
screen font. A value of -3 or -4 gives reasonably small print. You can get this 
value with <CODE>SCI_GETPRINTMAGNIFICATION</CODE>.</P>
<P><B id=SCI_SETPRINTCOLOURMODE>SCI_SETPRINTCOLOURMODE(int mode)</B><BR><B 
id=SCI_GETPRINTCOLOURMODE>SCI_GETPRINTCOLOURMODE</B><BR>These two messages set 
and get the method used to render coloured text on a printer that is probably 
using white paper. It is especially important to consider the treatment of 
colour if you use a dark or black screen background. Printing white on black 
uses up toner and ink very many times faster than the other way around. You can 
set the mode to one of:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Colour printing modes" border=0>
  <TBODY>
  <TR>
    <TH align=left>Symbol</TH>
    <TH>Value</TH>
    <TH align=left>Purpose</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>SC_PRINT_NORMAL</CODE></TD>
    <TD align=middle>0</TD>
    <TD>Print using the current screen colours. This is the default.</TD></TR>
  <TR>
    <TD align=left><CODE>SC_PRINT_INVERTLIGHT</CODE></TD>
    <TD align=middle>1</TD>
    <TD>If you use a dark screen background this saves ink by inverting the 
      light value of all colours and printing on a white background.</TD></TR>
  <TR>
    <TD align=left><CODE>SC_PRINT_BLACKONWHITE</CODE></TD>
    <TD align=middle>2</TD>
    <TD>Print all text as black on a white background.</TD></TR>
  <TR>
    <TD align=left><CODE>SC_PRINT_COLOURONWHITE</CODE></TD>
    <TD align=middle>3</TD>
    <TD>Everything prints in its own colour on a white background.</TD></TR>
  <TR>
    <TD align=left><CODE>SC_PRINT_COLOURONWHITEDEFAULTBG</CODE></TD>
    <TD align=middle>4</TD>
    <TD>Everything prints in its own colour on a white background except that 
      line numbers use their own background colour.</TD></TR></TBODY></TABLE>
<P><B id=SCI_SETPRINTWRAPMODE>SCI_SETPRINTWRAPMODE(int wrapMode)</B><BR><B 
id=SCI_GETPRINTWRAPMODE>SCI_GETPRINTWRAPMODE</B><BR>These two functions get and 
set the printer wrap mode. <CODE>wrapMode</CODE> can be set to 
<CODE>SC_WRAP_NONE</CODE> (0), <CODE>SC_WRAP_WORD</CODE> (1) or 
<CODE>SC_WRAP_CHAR</CODE> (2). The default is <CODE>SC_WRAP_WORD</CODE>, which 
wraps printed output so that all characters fit into the print rectangle. If you 
set <CODE>SC_WRAP_NONE</CODE>, each line of text generates one line of output 
and the line is truncated if it is too long to fit into the print 
area.<BR><CODE>SC_WRAP_WORD</CODE> tries to wrap only between words as indicated 
by white space or style changes although if a word is longer than a line, it 
will be wrapped before the line end. <CODE>SC_WRAP_CHAR</CODE> is preferred to 
<CODE>SC_WRAP_WORD</CODE> for Asian languages where there is no white space 
between words.</P>
<H2 id=DirectAccess>Direct access</H2><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETDIRECTFUNCTION">SCI_GETDIRECTFUNCTION</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETDIRECTPOINTER">SCI_GETDIRECTPOINTER</A><BR></CODE>
<P>On Windows, the message-passing scheme used to communicate between the 
container and Scintilla is mediated by the operating system 
<CODE>SendMessage</CODE> function and can lead to bad performance when calling 
intensively. To avoid this overhead, Scintilla provides messages that allow you 
to call the Scintilla message function directly. The code to do this in C/C++ is 
of the form:</P><PRE>#include "Scintilla.h"
SciFnDirect pSciMsg = (SciFnDirect)SendMessage(hSciWnd, SCI_GETDIRECTFUNCTION, 0, 0);
sptr_t pSciWndData = (sptr_t)SendMessage(hSciWnd, SCI_GETDIRECTPOINTER, 0, 0);

// now a wrapper to call Scintilla directly
sptr_t CallScintilla(unsigned int iMessage, uptr_t wParam, sptr_t lParam){
    return pSciMsg(pSciWndData, iMessage, wParam, lParam);
}
</PRE>
<P><CODE>SciFnDirect</CODE>, <CODE>sptr_t</CODE> and <CODE>uptr_t</CODE> are 
declared in <CODE>Scintilla.h</CODE>. <CODE>hSciWnd</CODE> is the window handle 
returned when you created the Scintilla window.</P>
<P>While faster, this direct calling will cause problems if performed from a 
different thread to the native thread of the Scintilla window in which case 
<CODE>SendMessage(hSciWnd, SCI_*, wParam, lParam)</CODE> should be used to 
synchronize with the window's thread.</P>
<P>This feature also works on GTK+ but has no significant impact on speed.</P>
<P>From version 1.47 on Windows, Scintilla exports a function called 
<CODE>Scintilla_DirectFunction</CODE> that can be used the same as the function 
returned by <CODE>SCI_GETDIRECTFUNCTION</CODE>. This saves you the call to 
<CODE>SCI_GETDIRECTFUNCTION</CODE> and the need to call Scintilla indirectly via 
the function pointer.</P>
<P><B id=SCI_GETDIRECTFUNCTION>SCI_GETDIRECTFUNCTION</B><BR>This message returns 
the address of the function to call to handle Scintilla messages without the 
overhead of passing through the Windows messaging system. You need only call 
this once, regardless of the number of Scintilla windows you create.</P>
<P><B id=SCI_GETDIRECTPOINTER>SCI_GETDIRECTPOINTER</B><BR>This returns a pointer 
to data that identifies which Scintilla window is in use. You must call this 
once for each Scintilla window you create. When you call the direct function, 
you must pass in the direct pointer associated with the target window.</P>
<H2 id=MultipleViews>Multiple views</H2>
<P>A Scintilla window and the document that it displays are separate entities. 
When you create a new window, you also create a new, empty document. Each 
document has a reference count that is initially set to 1. The document also has 
a list of the Scintilla windows that are linked to it so when any window changes 
the document, all other windows in which it appears are notified to cause them 
to update. The system is arranged in this way so that you can work with many 
documents in a single Scintilla window and so you can display a single document 
in multiple windows (for use with splitter windows).</P>
<P>Although these messages use <CODE>document *pDoc</CODE>, to ensure 
compatibility with future releases of Scintilla you should treat 
<CODE>pDoc</CODE> as an opaque <CODE>void*</CODE>. That is, you can use and 
store the pointer as described in this section but you should not dereference 
it.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETDOCPOINTER">SCI_GETDOCPOINTER</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETDOCPOINTER">SCI_SETDOCPOINTER(&lt;unused&gt;, 
document *pDoc)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_CREATEDOCUMENT">SCI_CREATEDOCUMENT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ADDREFDOCUMENT">SCI_ADDREFDOCUMENT(&lt;unused&gt;, 
document *pDoc)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_RELEASEDOCUMENT">SCI_RELEASEDOCUMENT(&lt;unused&gt;, 
document *pDoc)</A><BR></CODE>
<P><B id=SCI_GETDOCPOINTER>SCI_GETDOCPOINTER</B><BR>This returns a pointer to 
the document currently in use by the window. It has no other effect.</P>
<P><B id=SCI_SETDOCPOINTER>SCI_SETDOCPOINTER(&lt;unused&gt;, document 
*pDoc)</B><BR>This message does the following:<BR>1. It removes the current 
window from the list held by the current document.<BR>2. It reduces the 
reference count of the current document by 1.<BR>3. If the reference count 
reaches 0, the document is deleted.<BR>4. <CODE>pDoc</CODE> is set as the new 
document for the window.<BR>5. If <CODE>pDoc</CODE> was 0, a new, empty document 
is created and attached to the window.</P>6. If <CODE>pDoc</CODE> was not 0, its 
reference count is increased by 1.
<P></P>
<P><B id=SCI_CREATEDOCUMENT>SCI_CREATEDOCUMENT</B><BR>This message creates a 
new, empty document and returns a pointer to it. This document is not selected 
into the editor and starts with a reference count of 1. This means that you have 
ownership of it and must either reduce its reference count by 1 after using 
<CODE>SCI_SETDOCPOINTER</CODE> so that the Scintilla window owns it or you must 
make sure that you reduce the reference count by 1 with 
<CODE>SCI_RELEASEDOCUMENT</CODE> before you close the application to avoid 
memory leaks.</P>
<P><B id=SCI_ADDREFDOCUMENT>SCI_ADDREFDOCUMENT(&lt;unused&gt;, document 
*pDoc)</B><BR>This increases the reference count of a document by 1. If you want 
to replace the current document in the Scintilla window and take ownership of 
the current document, for example if you are editing many documents in one 
window, do the following:<BR>1. Use <CODE>SCI_GETDOCPOINTER</CODE> to get a 
pointer to the document, <CODE>pDoc</CODE>.<BR>2. Use 
<CODE>SCI_ADDREFDOCUMENT(0, pDoc)</CODE> to increment the reference count.<BR>3. 
Use <CODE>SCI_SETDOCPOINTER(0, pNewDoc)</CODE> to set a different document or 
<CODE>SCI_SETDOCPOINTER(0, 0)</CODE> to set a new, empty document.</P>
<P><B id=SCI_RELEASEDOCUMENT>SCI_RELEASEDOCUMENT(&lt;unused&gt;, document 
*pDoc)</B><BR>This message reduces the reference count of the document 
identified by <CODE>pDoc</CODE>. pDoc must be the result of 
<CODE>SCI_GETDOCPOINTER</CODE> or <CODE>SCI_CREATEDOCUMENT</CODE> and must point 
at a document that still exists. If you call this on a document with a reference 
count of 1 that is still attached to a Scintilla window, bad things will happen. 
To keep the world spinning in its orbit you must balance each call to 
<CODE>SCI_CREATEDOCUMENT</CODE> or <CODE>SCI_ADDREFDOCUMENT</CODE> with a call 
to <CODE>SCI_RELEASEDOCUMENT</CODE>.</P>
<H2 id=Folding>Folding</H2>
<P>The fundamental operation in folding is making lines invisible or visible. 
Line visibility is a property of the view rather than the document so each view 
may be displaying a different set of lines. From the point of view of the user, 
lines are hidden and displayed using fold points. Generally, the fold points of 
a document are based on the hierarchical structure of the document contents. In 
Python, the hierarchy is determined by indentation and in C++ by brace 
characters. This hierarchy can be represented within a Scintilla document object 
by attaching a numeric "fold level" to each line. The fold level is most easily 
set by a lexer, but you can also set it with messages.</P>
<P>It is up to your code to set the connection between user actions and folding 
and unfolding. The best way to see how this is done is to search the SciTE 
source code for the messages used in this section of the documentation and see 
how they are used. You will also need to use markers and a folding margin to 
complete your folding implementation. The <CODE>"fold"</CODE> property should be 
set to <CODE>"1"</CODE> with <CODE>SCI_SETPROPERTY("fold", "1")</CODE> to enable 
folding. </P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_VISIBLEFROMDOCLINE">SCI_VISIBLEFROMDOCLINE(int 
docLine)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_DOCLINEFROMVISIBLE">SCI_DOCLINEFROMVISIBLE(int 
displayLine)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SHOWLINES">SCI_SHOWLINES(int 
lineStart, int lineEnd)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_HIDELINES">SCI_HIDELINES(int 
lineStart, int lineEnd)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLINEVISIBLE">SCI_GETLINEVISIBLE(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETFOLDLEVEL">SCI_SETFOLDLEVEL(int 
line, int level)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETFOLDLEVEL">SCI_GETFOLDLEVEL(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETFOLDFLAGS">SCI_SETFOLDFLAGS(int 
flags)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLASTCHILD">SCI_GETLASTCHILD(int 
line, int level)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETFOLDPARENT">SCI_GETFOLDPARENT(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETFOLDEXPANDED">SCI_SETFOLDEXPANDED(int 
line, bool expanded)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETFOLDEXPANDED">SCI_GETFOLDEXPANDED(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_TOGGLEFOLD">SCI_TOGGLEFOLD(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ENSUREVISIBLE">SCI_ENSUREVISIBLE(int 
line)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ENSUREVISIBLEENFORCEPOLICY">SCI_ENSUREVISIBLEENFORCEPOLICY(int 
line)</A><BR></CODE>
<P><B id=SCI_VISIBLEFROMDOCLINE>SCI_VISIBLEFROMDOCLINE(int docLine)</B><BR>When 
some lines are folded, then a particular line in the document may be displayed 
at a different position to its document position. If no lines are folded, this 
message returns <CODE>docLine</CODE>. Otherwise, this returns the display line 
(counting the very first visible line as 0). The display line of an invisible 
line is the same as the previous visible line. The display line number of the 
first line in the document is 0. If there is folding and <CODE>docLine</CODE> is 
outside the range of lines in the document, the return value is -1. Lines can 
occupy more than one display line if they wrap.</P>
<P><B id=SCI_DOCLINEFROMVISIBLE>SCI_DOCLINEFROMVISIBLE(int 
displayLine)</B><BR>When some lines are hidden, then a particular line in the 
document may be displayed at a different position to its document position. This 
message returns the document line number that corresponds to a display line 
(counting the display line of the first line in the document as 0). If 
<CODE>displayLine</CODE> is less than or equal to 0, the result is 0. If 
<CODE>displayLine</CODE> is greater than or equal to the number of displayed 
lines, the result is the number of lines in the document.</P>
<P><B id=SCI_SHOWLINES>SCI_SHOWLINES(int lineStart, int lineEnd)</B><BR><B 
id=SCI_HIDELINES>SCI_HIDELINES(int lineStart, int lineEnd)</B><BR><B 
id=SCI_GETLINEVISIBLE>SCI_GETLINEVISIBLE(int line)</B><BR>The first two messages 
mark a range of lines as visible or invisible and then redraw the display. The 
third message reports on the visible state of a line and returns 1 if it is 
visible and 0 if it is not visible. These messages have no effect on fold levels 
or fold flags.</P>
<P><B id=SCI_SETFOLDLEVEL>SCI_SETFOLDLEVEL(int line, int level)</B><BR><B 
id=SCI_GETFOLDLEVEL>SCI_GETFOLDLEVEL(int line)</B><BR>These two messages set and 
get a 32-bit value that contains the fold level of a line and some flags 
associated with folding. The fold level is a number in the range 0 to 
<CODE>SC_FOLDLEVELNUMBERMASK</CODE> (4095). However, the initial fold level is 
set to <CODE>SC_FOLDLEVELBASE</CODE> (1024) to allow unsigned arithmetic on 
folding levels. There are two addition flag bits. 
<CODE>SC_FOLDLEVELWHITEFLAG</CODE> indicates that the line is blank and allows 
it to be treated slightly different then its level may indicate. For example, 
blank lines should generally not be fold points and will be considered part of 
the preceding section even though they may have a lesser fold level. 
<CODE>SC_FOLDLEVELHEADERFLAG</CODE> indicates that the line is a header (fold 
point).</P>
<P>Use <CODE>SCI_GETFOLDLEVEL(line) &amp; SC_FOLDLEVELNUMBERMASK</CODE> to get 
the fold level of a line. Likewise, use <CODE>SCI_GETFOLDLEVEL(line) &amp; 
SC_FOLDLEVEL*FLAG</CODE> to get the state of the flags. To set the fold level 
you must or in the associated flags. For instance, to set the level to 
<CODE>thisLevel</CODE> and mark a line as being a fold point use: 
<CODE>SCI_SETFOLDLEVEL(line, thisLevel | SC_FOLDLEVELHEADERFLAG)</CODE>.</P>If 
you use a lexer, you should not need to use <CODE>SCI_SETFOLDLEVEL</CODE> as 
this is far better handled by the lexer. You will need to use 
<CODE>SCI_GETFOLDLEVEL</CODE> to decide how to handle user folding requests. If 
you do change the fold levels, the folding margin will update to match your 
changes. 
<P><B id=SCI_SETFOLDFLAGS>SCI_SETFOLDFLAGS(int flags)</B><BR>In addition to 
showing markers in the folding margin, you can indicate folds to the user by 
drawing lines in the text area. The lines are drawn in the foreground colour set 
for <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition"><CODE>STYLE_DEFAULT</CODE></A>. 
Bits set in <CODE>flags</CODE> determine where folding lines are drawn:<BR></P>
<TABLE cellSpacing=2 cellPadding=1 summary="Fold flags" border=0>
  <TBODY>
  <TR>
    <TH align=middle>Value</TH>
    <TH align=left>Effect</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=middle>1</TD>
    <TD align=left>Experimental - draw boxes if expanded</TD></TR>
  <TR>
    <TD align=middle>2</TD>
    <TD align=left>Draw above if expanded</TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=left>Draw above if not expanded</TD></TR>
  <TR>
    <TD align=middle>8</TD>
    <TD align=left>Draw below if expanded</TD></TR>
  <TR>
    <TD align=middle>16</TD>
    <TD align=left>Draw below if not expanded</TD></TR>
  <TR>
    <TD align=middle>64</TD>
    <TD align=left>display hexadecimal fold levels in line margin to aid 
      debugging of folding. This feature needs to be redesigned to be 
    sensible.</TD></TR></TBODY></TABLE>
<P>This message causes the display to redraw.</P>
<P><B id=SCI_GETLASTCHILD>SCI_GETLASTCHILD(int startLine, int level)</B><BR>This 
message searches for the next line after <CODE>startLine</CODE>, that has a 
folding level that is less than or equal to <CODE>level</CODE> and then returns 
the previous line number. If you set <CODE>level</CODE> to -1, 
<CODE>level</CODE> is set to the folding level of line <CODE>startLine</CODE>. 
If <CODE>from</CODE> is a fold point, <CODE>SCI_GETLASTCHILD(from, -1)</CODE> 
returns the last line that would be in made visible or hidden by toggling the 
fold state.</P>
<P><B id=SCI_GETFOLDPARENT>SCI_GETFOLDPARENT(int startLine)</B><BR>This message 
returns the line number of the first line before <CODE>startLine</CODE> that is 
marked as a fold point with <CODE>SC_FOLDLEVELHEADERFLAG</CODE> and has a fold 
level less than the <CODE>startLine</CODE>. If no line is found, or if the 
header flags and fold levels are inconsistent, the return value is -1.</P>
<P><B id=SCI_TOGGLEFOLD>SCI_TOGGLEFOLD(int line)</B><BR>Each fold point may be 
either expanded, displaying all its child lines, or contracted, hiding all the 
child lines. This message toggles the folding state of the given line as long as 
it has the <CODE>SC_FOLDLEVELHEADERFLAG</CODE> set. This message takes care of 
folding or expanding all the lines that depend on the line. The display updates 
after this message.</P>
<P><B id=SCI_SETFOLDEXPANDED>SCI_SETFOLDEXPANDED(int line, bool 
expanded)</B><BR><B id=SCI_GETFOLDEXPANDED>SCI_GETFOLDEXPANDED(int 
line)</B><BR>These messages set and get the expanded state of a single line. The 
set message has no effect on the visible state of the line or any lines that 
depend on it. It does change the markers in the folding margin. If you ask for 
the expansion state of a line that is outside the document, the result is 
<CODE>false</CODE> (0).</P>
<P>If you just want to toggle the fold state of one line and handle all the 
lines that are dependent on it, it is much easier to use 
<CODE>SCI_TOGGLEFOLD</CODE>. You would use the <CODE>SCI_SETFOLDEXPANDED</CODE> 
message to process many folds without updating the display until you had 
finished. See <CODE>SciTEBase::FoldAll()</CODE> and 
<CODE>SciTEBase::Expand()</CODE> for examples of the use of these messages.</P>
<P><B id=SCI_ENSUREVISIBLE>SCI_ENSUREVISIBLE(int line)</B><BR><B 
id=SCI_ENSUREVISIBLEENFORCEPOLICY>SCI_ENSUREVISIBLEENFORCEPOLICY(int 
line)</B><BR>A line may be hidden because more than one of its parent lines is 
contracted. Both these message travels up the fold hierarchy, expanding any 
contracted folds until they reach the top level. The line will then be visible. 
If you use <CODE>SCI_ENSUREVISIBLEENFORCEPOLICY</CODE>, the vertical caret 
policy set by <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETVISIBLEPOLICY"><CODE>SCI_SETVISIBLEPOLICY</CODE></A> 
is then applied.</P>
<H2 id=LineWrapping>Line wrapping</H2><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETWRAPMODE">SCI_SETWRAPMODE(int 
wrapMode)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETWRAPMODE">SCI_GETWRAPMODE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETWRAPVISUALFLAGS">SCI_SETWRAPVISUALFLAGS(int 
wrapVisualFlags)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETWRAPVISUALFLAGS">SCI_GETWRAPVISUALFLAGS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETWRAPSTARTINDENT">SCI_SETWRAPSTARTINDENT(int 
indent)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETWRAPSTARTINDENT">SCI_GETWRAPSTARTINDENT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETLAYOUTCACHE">SCI_SETLAYOUTCACHE(int 
cacheMode)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLAYOUTCACHE">SCI_GETLAYOUTCACHE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LINESSPLIT">SCI_LINESSPLIT(int 
pixelWidth)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LINESJOIN">SCI_LINESJOIN</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_WRAPCOUNT">SCI_WRAPCOUNT(int 
docLine)</A><BR></CODE>
<P>By default, Scintilla does not wrap lines of text. If you enable line 
wrapping, lines wider than the window width are continued on the following 
lines. Lines are broken after space or tab characters or between runs of 
different styles. If this is not possible because a word in one style is wider 
than the window then the break occurs after the last character that completely 
fits on the line. The horizontal scroll bar does not appear when wrap mode is 
on.</P>
<P>For wrapped lines Scintilla can draw visual flags (little arrows) at end of a 
a subline of a wrapped line and at begin of the next subline. These can be 
enabled individually, but if Scintilla draws the visual flag at begin of the 
next subline this subline will be indented by one char. Independent from drawing 
a visual flag at the begin the subline can have an indention.</P>
<P>Much of the time used by Scintilla is spent on laying out and drawing text. 
The same text layout calculations may be performed many times even when the data 
used in these calculations does not change. To avoid these unnecessary 
calculations in some circumstances, the line layout cache can store the results 
of the calculations. The cache is invalidated whenever the underlying data, such 
as the contents or styling of the document changes. Caching the layout of the 
whole document has the most effect, making dynamic line wrap as much as 20 times 
faster but this requires 7 times the memory required by the document contents 
plus around 80 bytes per line.</P>
<P>Wrapping is not performed immediately there is a change but is delayed until 
the display is redrawn. This delay improves peformance by allowing a set of 
changes to be performed and then wrapped and displayed once. Because of this, 
some operations may not occur as expected. If a file is read and the scroll 
position moved to a particular line in the text, such as occurs when a container 
tries to restore a previous editing session, then the scroll position will have 
been determined before wrapping so an unexpected range of text will be 
displayed. To scroll to the position correctly, delay the scroll until the 
wrapping has been performed by waiting for an initial <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_PAINTED">SCN_PAINTED</A> 
notification.</P>
<P><B id=SCI_SETWRAPMODE>SCI_SETWRAPMODE(int wrapMode)</B><BR><B 
id=SCI_GETWRAPMODE>SCI_GETWRAPMODE</B><BR>Set wrapMode to 
<CODE>SC_WRAP_WORD</CODE> (1) to enable wrapping on word boundaries, 
<CODE>SC_WRAP_CHAR</CODE> (2) to enable wrapping between any characters, and to 
<CODE>SC_WRAP_NONE</CODE> (0) to disable line wrapping. 
<CODE>SC_WRAP_CHAR</CODE> is preferred to <CODE>SC_WRAP_WORD</CODE> for Asian 
languages where there is no white space between words.</P>
<P><B id=SCI_SETWRAPVISUALFLAGS>SCI_SETWRAPVISUALFLAGS(int 
wrapVisualFlags)</B><BR><B 
id=SCI_GETWRAPVISUALFLAGS>SCI_GETWRAPVISUALFLAGS</B><BR>You can enable the 
drawing of visual flags to indicate a line is wrapped. Bits set in 
wrapVisualFlags determine which visual flags are drawn. 
<TABLE cellSpacing=2 cellPadding=1 summary="Wrap visual flags" border=0>
  <TBODY>
  <TR>
    <TH align=left>Symbol</TH>
    <TH>Value</TH>
    <TH align=left>Effect</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>SC_WRAPVISUALFLAG_NONE</CODE></TD>
    <TD align=middle>0</TD>
    <TD>No visual flags</TD></TR>
  <TR>
    <TD align=left><CODE>SC_WRAPVISUALFLAG_END</CODE></TD>
    <TD align=middle>1</TD>
    <TD>Visual flag at end of subline of a wrapped line.</TD></TR>
  <TR>
    <TD align=left><CODE>SC_WRAPVISUALFLAG_START</CODE></TD>
    <TD align=middle>2</TD>
    <TD>Visual flag at begin of subline of a wrapped line.<BR>Subline is 
      indented by at least 1 to make room for the flag.<BR></TD></TR></TBODY></TABLE>
<P><B id=SCI_SETWRAPVISUALFLAGSLOCATION>SCI_SETWRAPVISUALFLAGSLOCATION(int 
wrapVisualFlagsLocation)</B><BR><B 
id=SCI_GETWRAPVISUALFLAGSLOCATION>SCI_GETWRAPVISUALFLAGSLOCATION</B><BR>You can 
set wether the visual flags to indicate a line is wrapped are drawn near the 
border or near the text. Bits set in wrapVisualFlagsLocation set the location to 
near the text for the corresponding visual flag. 
<TABLE cellSpacing=2 cellPadding=1 summary="Wrap visual flags locations" 
border=0>
  <TBODY>
  <TR>
    <TH align=left>Symbol</TH>
    <TH>Value</TH>
    <TH align=left>Effect</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>SC_WRAPVISUALFLAGLOC_DEFAULT</CODE></TD>
    <TD align=middle>0</TD>
    <TD>Visual flags drawn near border</TD></TR>
  <TR>
    <TD align=left><CODE>SC_WRAPVISUALFLAGLOC_END_BY_TEXT</CODE></TD>
    <TD align=middle>1</TD>
    <TD>Visual flag at end of subline drawn near text</TD></TR>
  <TR>
    <TD align=left><CODE>SC_WRAPVISUALFLAGLOC_START_BY_TEXT</CODE></TD>
    <TD align=middle>2</TD>
    <TD>Visual flag at begin of subline drawn near 
text</TD></TR></TBODY></TABLE><BR>
<P><B id=SCI_SETWRAPSTARTINDENT>SCI_SETWRAPSTARTINDENT(int indent)</B><BR><B 
id=SCI_GETWRAPSTARTINDENT>SCI_GETWRAPSTARTINDENT</B><BR><CODE>SCI_SETWRAPSTARTINDENT</CODE> 
sets the size of indentation of sublines for wrapped lines in terms of the width 
of a space in <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition"><CODE>STYLE_DEFAULT</CODE></A>. 
There are no limits on indent sizes, but values less than 0 or large values may 
have undesirable effects.<BR>The indention of sublines is independent of visual 
flags, but if <CODE>SC_WRAPVISUALFLAG_START</CODE> is set an indent of at least 
1 is used. </P>
<P><B id=SCI_SETLAYOUTCACHE>SCI_SETLAYOUTCACHE(int cacheMode)</B><BR><B 
id=SCI_GETLAYOUTCACHE>SCI_GETLAYOUTCACHE</B><BR>You can set 
<CODE>cacheMode</CODE> to one of the symbols in the table:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Line caching styles" border=0>
  <TBODY>
  <TR>
    <TH align=left>Symbol</TH>
    <TH>Value</TH>
    <TH align=left>Layout cached for these lines</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>SC_CACHE_NONE</CODE></TD>
    <TD align=middle>0</TD>
    <TD>No lines are cached.</TD></TR>
  <TR>
    <TD align=left><CODE>SC_CACHE_CARET</CODE></TD>
    <TD align=middle>1</TD>
    <TD>The line containing the text caret. This is the default.</TD></TR>
  <TR>
    <TD align=left><CODE>SC_CACHE_PAGE</CODE></TD>
    <TD align=middle>2</TD>
    <TD>Visible lines plus the line containing the caret.</TD></TR>
  <TR>
    <TD align=left><CODE>SC_CACHE_DOCUMENT</CODE></TD>
    <TD align=middle>3</TD>
    <TD>All lines in the document.</TD></TR></TBODY></TABLE><BR>
<P><B id=SCI_LINESSPLIT>SCI_LINESSPLIT(int pixelWidth)</B><BR>Split a range of 
lines indicated by the target into lines that are at most pixelWidth wide. 
Splitting occurs on word boundaries wherever possible in a similar manner to 
line wrapping. When <CODE>pixelWidth</CODE> is 0 then the width of the window is 
used. </P>
<P><B id=SCI_LINESJOIN>SCI_LINESJOIN</B><BR>Join a range of lines indicated by 
the target into one line by removing line end characters. Where this would lead 
to no space between words, an extra space is inserted. </P>
<P><B id=SCI_WRAPCOUNT>SCI_WRAPCOUNT(int docLine)</B><BR>Document lines can 
occupy more than one display line if they wrap and this returns the number of 
display lines needed to wrap a document line.</P>
<H2 id=Zooming>Zooming</H2>
<P>Scintilla incorporates a "zoom factor" that lets you make all the text in the 
document larger or smaller in steps of one point. The displayed point size never 
goes below 2, whatever zoom factor you set. You can set zoom factors in the 
range -10 to +20 points.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ZOOMIN">SCI_ZOOMIN</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ZOOMOUT">SCI_ZOOMOUT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETZOOM">SCI_SETZOOM(int 
zoomInPoints)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETZOOM">SCI_GETZOOM</A><BR></CODE>
<P><B id=SCI_ZOOMIN>SCI_ZOOMIN</B><BR><B 
id=SCI_ZOOMOUT>SCI_ZOOMOUT</B><BR><CODE>SCI_ZOOMIN</CODE> increases the zoom 
factor by one point if the current zoom factor is less than 20 points. 
<CODE>SCI_ZOOMOUT</CODE> decreases the zoom factor by one point if the current 
zoom factor is greater than -10 points.</P>
<P><B id=SCI_SETZOOM>SCI_SETZOOM(int zoomInPoints)</B><BR><B 
id=SCI_GETZOOM>SCI_GETZOOM</B><BR>These messages let you set and get the zoom 
factor directly. There is no limit set on the factors you can set, so limiting 
yourself to -10 to +20 to match the incremental zoom functions is a good 
idea.</P>
<H2 id=LongLines>Long lines</H2>
<P>You can choose to mark lines that exceed a given length by drawing a vertical 
line or by colouring the background of characters that exceed the set 
length.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETEDGEMODE">SCI_SETEDGEMODE(int 
mode)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETEDGEMODE">SCI_GETEDGEMODE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETEDGECOLUMN">SCI_SETEDGECOLUMN(int 
column)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETEDGECOLUMN">SCI_GETEDGECOLUMN</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETEDGECOLOUR">SCI_SETEDGECOLOUR(int 
colour)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETEDGECOLOUR">SCI_GETEDGECOLOUR</A><BR></CODE>
<P><B id=SCI_SETEDGEMODE>SCI_SETEDGEMODE(int edgeMode)</B><BR><B 
id=SCI_GETEDGEMODE>SCI_GETEDGEMODE</B><BR>These two messages set and get the 
mode used to display long lines. You can set one of the values in the table:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Long line styles" border=0>
  <TBODY>
  <TR>
    <TH align=left>Symbol</TH>
    <TH>Value</TH>
    <TH align=left>Long line display mode</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>EDGE_NONE</CODE></TD>
    <TD align=middle>0</TD>
    <TD>Long lines are not marked. This is the default state.</TD></TR>
  <TR>
    <TD align=left><CODE>EDGE_LINE</CODE></TD>
    <TD align=middle>1</TD>
    <TD>A vertical line is drawn at the column number set by 
      <CODE>SCI_SETEDGECOLUMN</CODE>. This works well for monospaced fonts. The 
      line is drawn at a position based on the width of a space character in <A 
      class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#StyleDefinition"><CODE>STYLE_DEFAULT</CODE></A>, 
      so it may not work very well if your styles use proportional fonts or if 
      your style have varied font sizes or you use a mixture of bold, italic and 
      normal text. .</TD></TR>
  <TR>
    <TD align=left><CODE>EDGE_BACKGROUND</CODE></TD>
    <TD align=middle>2</TD>
    <TD>The background colour of characters after the column limit is changed 
      to the colour set by <CODE>SCI_SETEDGECOLOUR</CODE>. This is recommended 
      for proportional fonts.</TD></TR></TBODY></TABLE><BR><BR>
<P><B id=SCI_SETEDGECOLUMN>SCI_SETEDGECOLUMN(int column)</B><BR><B 
id=SCI_GETEDGECOLUMN>SCI_GETEDGECOLUMN</B><BR>These messages set and get the 
column number at which to display the long line marker. When drawing lines, the 
column sets a position in units of the width of a space character in 
<CODE>STYLE_DEFAULT</CODE>. When setting the background colour, the column is a 
character count (allowing for tabs) into the line.</P>
<P><B id=SCI_SETEDGECOLOUR>SCI_SETEDGECOLOUR(int <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#colour">colour</A>)</B><BR><B 
id=SCI_GETEDGECOLOUR>SCI_GETEDGECOLOUR</B><BR>These messages set and get the 
colour of the marker used to show that a line has exceeded the length set by 
<CODE>SCI_SETEDGECOLUMN</CODE>.</P>
<H2 id=Lexer>Lexer</H2>
<P>If you define the symbol <CODE>SCI_LEXER</CODE> when building Scintilla, 
(this is sometimes called the SciLexer version of Scintilla), lexing support for 
a wide range programming languages is included and the messages in this section 
are supported. If you want to set styling and fold points for an unsupported 
language you can either do this in the container or better still, write your own 
lexer following the pattern of one of the existing ones.</P>
<P>Scintilla also supports external lexers. These are DLLs (on Windows) or .so 
modules (on GTK+/Linux) that export four functions: <CODE>GetLexerCount</CODE>, 
<CODE>GetLexerName</CODE>, <CODE>Lex</CODE> and <CODE>Fold</CODE>. See 
<CODE>externalLexer.cxx</CODE> for more.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETLEXER">SCI_SETLEXER(int 
lexer)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLEXER">SCI_GETLEXER</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETLEXERLANGUAGE">SCI_SETLEXERLANGUAGE(&lt;unused&gt;, 
char *name)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LOADLEXERLIBRARY">SCI_LOADLEXERLIBRARY(&lt;unused&gt;, 
char *path)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_COLOURISE">SCI_COLOURISE(int 
start, int end)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETPROPERTY">SCI_SETPROPERTY(const 
char *key, const char *value)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETPROPERTY">SCI_GETPROPERTY(const 
char *key, char *value)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETPROPERTYEXPANDED">SCI_GETPROPERTYEXPANDED(const 
char *key, char *value)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETPROPERTYINT">SCI_GETPROPERTYINT(const 
char *key, int default)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETKEYWORDS">SCI_SETKEYWORDS(int 
keyWordSet, const char *keyWordList)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETSTYLEBITSNEEDED">SCI_GETSTYLEBITSNEEDED</A> 
<BR></CODE>
<P><B id=SCI_SETLEXER>SCI_SETLEXER(int lexer)</B><BR><B 
id=SCI_GETLEXER>SCI_GETLEXER</B><BR>You can select the lexer to use with an 
integer code from the <CODE>SCLEX_*</CODE> enumeration in 
<CODE>Scintilla.h</CODE>. There are two codes in this sequence that do not use 
lexers: <CODE>SCLEX_NULL</CODE> to select no lexing action and 
<CODE>SCLEX_CONTAINER</CODE> which sends the <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_STYLENEEDED">SCN_STYLENEEDED</A></CODE> 
notification to the container whenever a range of text needs to be styled. You 
cannot use the <CODE>SCLEX_AUTOMATIC</CODE> value; this identifies additional 
external lexers that Scintilla assigns unused lexer numbers to.</P>
<P><B id=SCI_SETLEXERLANGUAGE>SCI_SETLEXERLANGUAGE(&lt;unused&gt;, const char 
*name)</B><BR>This message lets you select a lexer by name, and is the only 
method if you are using an external lexer or if you have written a lexer module 
for a language of your own and do not wish to assign it an explicit lexer 
number. To select an existing lexer, set <CODE>name</CODE> to match the (case 
sensitive) name given to the module, for example "ada" or "python", not "Ada" or 
"Python". To locate the name for the built-in lexers, open the relevant 
<CODE>Lex*.cxx</CODE> file and search for <CODE>LexerModule</CODE>. The third 
argument in the <CODE>LexerModule</CODE> constructor is the name to use.</P>
<P>To test if your lexer assignment worked, use <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETLEXER"><CODE>SCI_GETLEXER</CODE></A> 
before and after setting the new lexer to see if the lexer number changed.</P>
<P><B id=SCI_LOADLEXERLIBRARY>SCI_LOADLEXERLIBRARY(&lt;unused&gt;, const char 
*path)</B><BR>Load a lexer implemented in a shared library. This is a .so file 
on GTK+/Linux or a .DLL file on Windows. </P>
<P><B id=SCI_COLOURISE>SCI_COLOURISE(int startPos, int endPos)</B><BR>This 
requests the current lexer or the container (if the lexer is set to 
<CODE>SCLEX_CONTAINER</CODE>) to style the document between 
<CODE>startPos</CODE> and <CODE>endPos</CODE>. If <CODE>endPos</CODE> is -1, the 
document is styled from <CODE>startPos</CODE> to the end. If the 
<CODE>"fold"</CODE> property is set to <CODE>"1"</CODE> and your lexer or 
container supports folding, fold levels are also set. This message causes a 
redraw.</P>
<P><B id=SCI_SETPROPERTY>SCI_SETPROPERTY(const char *key, const char 
*value)</B><BR>You can communicate settings to lexers with keyword:value string 
pairs. There is no limit to the number of keyword pairs you can set, other than 
available memory. <CODE>key</CODE> is a case sensitive keyword, 
<CODE>value</CODE> is a string that is associated with the keyword. If there is 
already a value string associated with the keyword, it is replaced. If you pass 
a zero length string, the message does nothing. Both <CODE>key</CODE> and 
<CODE>value</CODE> are used without modification; extra spaces at the beginning 
or end of <CODE>key</CODE> are significant.</P>
<P>The <CODE>value</CODE> string can refer to other keywords. For example, 
<CODE>SCI_SETPROPERTY("foldTimes10", "$(fold)0")</CODE> stores the string 
<CODE>"$(fold)0"</CODE>, but when this is accessed, the <CODE>$(fold)</CODE> is 
replaced by the value of the <CODE>"fold"</CODE> keyword (or by nothing if this 
keyword does not exist).</P>
<P>Currently the "fold" property is defined for most of the lexers to set the 
fold structure if set to "1". <CODE>SCLEX_PYTHON</CODE> understands 
<CODE>"tab.timmy.whinge.level"</CODE> as a setting that determines how to 
indicate bad indentation. Most keywords have values that are interpreted as 
integers. Search the lexer sources for <CODE>GetPropertyInt</CODE> to see how 
properties are used.</P>
<P><B id=SCI_GETPROPERTY>SCI_GETPROPERTY(const char *key, char 
*value)</B><BR>Lookup a keyword:value pair using the specified key; if found, 
copy the value to the user-supplied buffer and return the length (not including 
the terminating 0). If not found, copy an empty string to the buffer and return 
0.</P>
<P>Note that "keyword replacement" as described in <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETPROPERTY"><CODE>SCI_SETPROPERTY</CODE></A> 
will not be performed.</P>
<P>If the value argument is 0 then the length that should be allocated to store 
the value is returned; again, the terminating 0 is not included.</P>
<P><B id=SCI_GETPROPERTYEXPANDED>SCI_GETPROPERTYEXPANDED(const char *key, char 
*value)</B><BR>Lookup a keyword:value pair using the specified key; if found, 
copy the value to the user-supplied buffer and return the length (not including 
the terminating 0). If not found, copy an empty string to the buffer and return 
0.</P>
<P>Note that "keyword replacement" as described in <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETPROPERTY"><CODE>SCI_SETPROPERTY</CODE></A> 
will be performed.</P>
<P>If the value argument is 0 then the length that should be allocated to store 
the value (including any indicated keyword replacement) is returned; again, the 
terminating 0 is not included.</P>
<P><B id=SCI_GETPROPERTYINT>SCI_GETPROPERTYINT(const char *key, int 
default)</B><BR>Lookup a keyword:value pair using the specified key; if found, 
interpret the value as an integer and return it. If not found (or the value is 
an empty string) then return the supplied default. If the keyword:value pair is 
found but is not a number, then return 0.</P>
<P>Note that "keyword replacement" as described in <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETPROPERTY"><CODE>SCI_SETPROPERTY</CODE></A> 
will be performed before any numeric interpretation.</P>
<P><B id=SCI_SETKEYWORDS>SCI_SETKEYWORDS(int keyWordSet, const char 
*keyWordList)</B><BR>You can set up to 9 lists of keywords for use by the 
current lexer. This was increased from 6 at revision 1.50. 
<CODE>keyWordSet</CODE> can be 0 to 8 (actually 0 to 
<CODE>KEYWORDSET_MAX</CODE>) and selects which keyword list to replace. 
<CODE>keyWordList</CODE> is a list of keywords separated by spaces, tabs, 
<CODE>"\n"</CODE> or <CODE>"\r"</CODE> or any combination of these. It is 
expected that the keywords will be composed of standard ASCII printing 
characters, but there is nothing to stop you using any non-separator character 
codes from 1 to 255 (except common sense).</P>
<P>How these keywords are used is entirely up to the lexer. Some languages, such 
as HTML may contain embedded languages, VBScript and JavaScript are common for 
HTML. For HTML, key word set 0 is for HTML, 1 is for JavaScript and 2 is for 
VBScript, 3 is for Python, 4 is for PHP and 5 is for SGML and DTD keywords. 
Review the lexer code to see examples of keyword list. A fully conforming lexer 
sets the fourth argument of the <CODE>LexerModule</CODE> constructor to be a 
list of strings that describe the uses of the keyword lists.</P>
<P>Alternatively, you might use set 0 for general keywords, set 1 for keywords 
that cause indentation and set 2 for keywords that cause unindentation. Yet 
again, you might have a simple lexer that colours keywords and you could change 
languages by changing the keywords in set 0. There is nothing to stop you 
building your own keyword lists into the lexer, but this means that the lexer 
must be rebuilt if more keywords are added.</P>
<P><B id=SCI_GETSTYLEBITSNEEDED>SCI_GETSTYLEBITSNEEDED</B><BR>Retrieve the 
number of bits the current lexer needs for styling. This should normally be the 
argument to <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSTYLEBITS">SCI_SETSTYLEBITS</A>. 
</P>
<H2 id=Notifications>Notifications</H2>
<P>Notifications are sent (fired) from the Scintilla control to its container 
when an event has occurred that may interest the container. Notifications are 
sent using the <CODE>WM_NOTIFY</CODE> message on Windows and the "notify" signal 
on GTK+. The container is passed a <CODE>SCNotification</CODE> structure 
containing information about the event.</P><PRE id=SCNotification>struct NotifyHeader {   // This matches the Win32 NMHDR structure
    void *hwndFrom;     // environment specific window handle/pointer
    uptr_t idFrom;	// CtrlID of the window issuing the notification
    unsigned int code;  // The SCN_* notification code
};

struct SCNotification {
    struct NotifyHeader nmhdr;
    int position;
    // SCN_STYLENEEDED, SCN_MODIFIED, SCN_DWELLSTART,
    // SCN_DWELLEND, SCN_CALLTIPCLICK,
    // SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK
    int ch;             // SCN_CHARADDED, SCN_KEY
    int modifiers;      // SCN_KEY, SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK
    int modificationType; // SCN_MODIFIED
    const char *text;   // SCN_MODIFIED, SCN_USERLISTSELECTION, SCN_AUTOCSELECTION
    int length;         // SCN_MODIFIED
    int linesAdded;     // SCN_MODIFIED
    int message;        // SCN_MACRORECORD
    uptr_t wParam;      // SCN_MACRORECORD
    sptr_t lParam;      // SCN_MACRORECORD
    int line;           // SCN_MODIFIED
    int foldLevelNow;   // SCN_MODIFIED
    int foldLevelPrev;  // SCN_MODIFIED
    int margin;         // SCN_MARGINCLICK
    int listType;       // SCN_USERLISTSELECTION, SCN_AUTOCSELECTION
    int x;              // SCN_DWELLSTART, SCN_DWELLEND
    int y;              // SCN_DWELLSTART, SCN_DWELLEND
};
</PRE>
<P>The notification messages that your container can choose to handle and the 
messages associated with them are:</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_STYLENEEDED">SCN_STYLENEEDED</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_CHARADDED">SCN_CHARADDED</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_SAVEPOINTLEFT">SCN_SAVEPOINTLEFT</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MODIFYATTEMPTRO">SCN_MODIFYATTEMPTRO</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_KEY">SCN_KEY</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_DOUBLECLICK">SCN_DOUBLECLICK</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_UPDATEUI">SCN_UPDATEUI</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MODIFIED">SCN_MODIFIED</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MACRORECORD">SCN_MACRORECORD</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MARGINCLICK">SCN_MARGINCLICK</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_NEEDSHOWN">SCN_NEEDSHOWN</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_PAINTED">SCN_PAINTED</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_USERLISTSELECTION">SCN_USERLISTSELECTION</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_URIDROPPED">SCN_URIDROPPED</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_DWELLSTART">SCN_DWELLSTART</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_DWELLEND">SCN_DWELLEND</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_ZOOM">SCN_ZOOM</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_HOTSPOTCLICK">SCN_HOTSPOTCLICK</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_HOTSPOTDOUBLECLICK">SCN_HOTSPOTDOUBLECLICK</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_CALLTIPCLICK">SCN_CALLTIPCLICK</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_AUTOCSELECTION">SCN_AUTOCSELECTION</A><BR></CODE>
<P>The following <CODE>SCI_*</CODE> messages are associated with these 
notifications:</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMODEVENTMASK">SCI_SETMODEVENTMASK(int 
eventMask)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMODEVENTMASK">SCI_GETMODEVENTMASK</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMOUSEDWELLTIME">SCI_SETMOUSEDWELLTIME</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMOUSEDWELLTIME">SCI_GETMOUSEDWELLTIME</A><BR></CODE>
<P>The following additional notifications are sent using the 
<CODE>WM_COMMAND</CODE> message on Windows and the "Command" signal on GTK+. 
This emulates the Windows Edit control. Only the lower 16 bits of the control's 
ID is passed in these notifications.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCEN_CHANGE">SCEN_CHANGE</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCEN_SETFOCUS">SCEN_SETFOCUS</A><BR><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCEN_KILLFOCUS">SCEN_KILLFOCUS</A><BR></CODE>
<P><B id=SCN_STYLENEEDED>SCN_STYLENEEDED</B><BR>If you used <CODE><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETLEXER">SCI_SETLEXER</A>(SCLEX_CONTAINER)</CODE> 
to make the container act as the lexer, you will receive this notification when 
Scintilla is about to display or print text that requires styling. You are 
required to style the text from the line that contains the position returned by 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETENDSTYLED"><CODE>SCI_GETENDSTYLED</CODE></A> 
up to the position passed in <CODE>SCNotification.position</CODE>. Symbolically, 
you need code of the form:</P><PRE>    startPos = <A class=message href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETENDSTYLED">SCI_GETENDSTYLED</A>()
    lineNumber = <A class=message href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION</A>(startPos);
    startPos = <A class=message href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE</A>(lineNumber);
    MyStyleRoutine(startPos, SCNotification.position);
</PRE>
<P><B id=SCN_CHARADDED>SCN_CHARADDED</B><BR>This is sent when the user types an 
ordinary text character (as opposed to a command character) that is entered into 
the text. The container can use this to decide to display a <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#CallTips">call tip</A> 
or an <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Autocompletion">auto 
completion list</A>. The character is in <CODE>SCNotification.ch</CODE>. This 
notification is sent before the character has been styled so processing that 
depends on styling should instead be performed in the SCN_UPDATEUI 
notification.</P>
<P><B id=SCN_SAVEPOINTREACHED>SCN_SAVEPOINTREACHED</B><BR><B 
id=SCN_SAVEPOINTLEFT>SCN_SAVEPOINTLEFT</B><BR>Sent to the container when the 
save point is entered or left, allowing the container to display a "document 
dirty" indicator and change its menus.<BR>See also: <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETSAVEPOINT"><CODE>SCI_SETSAVEPOINT</CODE></A>, 
<A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_GETMODIFY"><CODE>SCI_GETMODIFY</CODE></A></P>
<P><B id=SCN_MODIFYATTEMPTRO>SCN_MODIFYATTEMPTRO</B><BR>When in read-only mode, 
this notification is sent to the container if the user tries to change the text. 
This can be used to check the document out of a version control system. You can 
set the read-only state of a document with <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETREADONLY">SCI_SETREADONLY</A></CODE>.</P>
<P><B id=SCN_KEY>SCN_KEY</B><BR>Reports all keys pressed but not consumed by 
Scintilla. Used on GTK+ because of some problems with keyboard focus and is not 
sent by the Windows version. <CODE>SCNotification.ch</CODE> holds the key code 
and <CODE>SCNotification.modifiers</CODE> holds the modifiers. This notification 
is sent if the modifiers include <CODE>SCMOD_ALT</CODE> or 
<CODE>SCMOD_CTRL</CODE> and the key code is less than 256.</P>
<P><B id=SCN_DOUBLECLICK>SCN_DOUBLECLICK</B><BR>The mouse button was double 
clicked in editor. There is no additional information.</P>
<P><B id=SCN_UPDATEUI>SCN_UPDATEUI</B><BR>Either the text or styling of the 
document has changed or the selection range has changed. Now would be a good 
time to update any container UI elements that depend on document or view state. 
This was previously called <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_CHECKBRACE">SCN_CHECKBRACE</A></CODE> 
because a common use is to check whether the caret is next to a brace and set 
highlights on this brace and its corresponding matching brace. This also 
replaces <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_POSCHANGED"><CODE>SCN_POSCHANGED</CODE></A>, 
which is now deprecated.</P>
<P><B id=SCN_MODIFIED>SCN_MODIFIED</B><BR>This notification is sent when the 
text or styling of the document changes or is about to change. You can set a 
mask for the notifications that are sent to the container with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMODEVENTMASK"><CODE>SCI_SETMODEVENTMASK</CODE></A>. 
The notification structure contains information about what changed, how the 
change occurred and whether this changed the number of lines in the document. No 
modifications may be performed while in a <CODE>SCN_MODIFIED</CODE> event. The 
<CODE>SCNotification</CODE> fields used are:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Modify notification types" 
  border=0><TBODY>
  <TR>
    <TH align=left>Field</TH>
    <TH align=left>Usage</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>modificationType</CODE></TD>
    <TD align=left>A set of flags that identify the change(s) made. See the 
      next table.</TD></TR>
  <TR>
    <TD align=left><CODE>position</CODE></TD>
    <TD align=left>Start position of a text or styling change. Set to 0 if not 
      used.</TD></TR>
  <TR>
    <TD align=left><CODE>length</CODE></TD>
    <TD align=left>Length of the change in cells or characters when the text 
      or styling changes. Set to 0 if not used.</TD></TR>
  <TR>
    <TD align=left><CODE>linesAdded</CODE></TD>
    <TD align=left>Number of added lines. If negative, the number of deleted 
      lines. Set to 0 if not used or no lines added or deleted.</TD></TR>
  <TR>
    <TD align=left><CODE>text</CODE></TD>
    <TD align=left>Valid for text changes, not for style changes. If we are 
      collecting undo information this holds a pointer to the text that is 
      handed to the Undo system, otherwise it is zero. For user performed 
      SC_MOD_BEFOREDELETE the text field is 0 and for user performed 
      SC_MOD_BEFOREINSERT the text field points to an array of cells, not bytes 
      and the length is the number of cells.</TD></TR>
  <TR>
    <TD align=left><CODE>line</CODE></TD>
    <TD align=left>The line number at which a fold level or marker change 
      occurred. This is 0 if unused and may be -1 if more than one line 
    changed.</TD></TR>
  <TR>
    <TD align=left><CODE>foldLevelNow</CODE></TD>
    <TD align=left>The new fold level applied to the line or 0 if this field 
      is unused.</TD></TR>
  <TR>
    <TD align=left><CODE>foldLevelPrev</CODE></TD>
    <TD align=left>The previous folding level of the line or 0 if this field 
      is unused.</TD></TR></TBODY></TABLE>
<P>The <CODE>SCNotification.modificationType</CODE> field has bits set to tell 
you what has been done. The <CODE>SC_MOD_*</CODE> bits correspond to actions. 
The <CODE>SC_PERFORMED_*</CODE> bits tell you if the action was done by the 
user, or the result of Undo or Redo of a previous action.</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Modify notification type flags" 
border=0>
  <TBODY>
  <TR>
    <TH align=left>Symbol</TH>
    <TH>Value</TH>
    <TH align=left>Meaning</TH>
    <TH align=left>SCNotification fields</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>SC_MOD_INSERTTEXT</CODE></TD>
    <TD align=middle>0x01</TD>
    <TD>Text has been inserted into the document.</TD>
    <TD><CODE>position, length, text, linesAdded</CODE></TD></TR>
  <TR>
    <TD align=left><CODE>SC_MOD_DELETETEXT</CODE></TD>
    <TD align=middle>0x02</TD>
    <TD>Text has been removed from the document.</TD>
    <TD><CODE>position, length, text, linesAdded</CODE></TD></TR>
  <TR>
    <TD align=left><CODE>SC_MOD_CHANGESTYLE</CODE></TD>
    <TD align=middle>0x04</TD>
    <TD>A style change has occurred.</TD>
    <TD><CODE>position, length</CODE></TD></TR>
  <TR>
    <TD align=left><CODE>SC_MOD_CHANGEFOLD</CODE></TD>
    <TD align=middle>0x08</TD>
    <TD>A folding change has occurred.</TD>
    <TD><CODE>line, foldLevelNow, foldLevelPrev</CODE></TD></TR>
  <TR>
    <TD align=left><CODE>SC_PERFORMED_USER</CODE></TD>
    <TD align=middle>0x10</TD>
    <TD>Information: the operation was done by the user.</TD>
    <TD>None</TD></TR>
  <TR>
    <TD align=left><CODE>SC_PERFORMED_UNDO</CODE></TD>
    <TD align=middle>0x20</TD>
    <TD>Information: this was the result of an Undo.</TD>
    <TD>None</TD></TR>
  <TR>
    <TD align=left><CODE>SC_PERFORMED_REDO</CODE></TD>
    <TD align=middle>0x40</TD>
    <TD>Information: this was the result of a Redo.</TD>
    <TD>None</TD></TR>
  <TR>
    <TD align=left><CODE>SC_MULTISTEPUNDOREDO</CODE></TD>
    <TD align=middle>0x80</TD>
    <TD>This is part of a multi-step Undo or Redo.</TD>
    <TD>None</TD></TR>
  <TR>
    <TD align=left><CODE>SC_LASTSTEPINUNDOREDO</CODE></TD>
    <TD align=middle>0x100</TD>
    <TD>This is the final step in an Undo or Redo.</TD>
    <TD>None</TD></TR>
  <TR>
    <TD align=left><CODE>SC_MOD_CHANGEMARKER</CODE></TD>
    <TD align=middle>0x200</TD>
    <TD>One or more markers has changed in a line.</TD>
    <TD><CODE>line</CODE></TD></TR>
  <TR>
    <TD align=left><CODE>SC_MOD_BEFOREINSERT</CODE></TD>
    <TD align=middle>0x400</TD>
    <TD>Text is about to be inserted into the document.</TD>
    <TD><CODE>position, if performed by user then text in cells, length in 
      cells</CODE></TD></TR>
  <TR>
    <TD align=left><CODE>SC_MOD_BEFOREDELETE</CODE></TD>
    <TD align=middle>0x800</TD>
    <TD>Text is about to be deleted from the document.</TD>
    <TD><CODE>position, length</CODE></TD></TR>
  <TR>
    <TD align=left><CODE>SC_MULTILINEUNDOREDO</CODE></TD>
    <TD align=middle>0x1000</TD>
    <TD>This is part of an Undo or Redo with multi-line changes.</TD>
    <TD>None</TD></TR>
  <TR>
    <TD align=left><CODE>SC_MODEVENTMASKALL</CODE></TD>
    <TD align=middle>0x1fff</TD>
    <TD>This is a mask for all valid flags. This is the default mask state set 
      by <A class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMODEVENTMASK"><CODE>SCI_SETMODEVENTMASK</CODE></A>.</TD>
    <TD>None</TD></TR></TBODY></TABLE>
<P><B id=SCEN_CHANGE>SCEN_CHANGE</B><BR><CODE>SCEN_CHANGE</CODE> (768) is fired 
when the text (not the style) of the document changes. This notification is sent 
using the <CODE>WM_COMMAND</CODE> message on Windows and the "Command" signal on 
GTK+ as this is the behavior of the standard Edit control 
(<CODE>SCEN_CHANGE</CODE> has the same value as the Windows Edit control 
<CODE>EN_CHANGE</CODE>). No other information is sent. If you need more detailed 
information use <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MODIFIED"><CODE>SCN_MODIFIED</CODE></A>. 
You can filter the types of changes you are notified about with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMODEVENTMASK"><CODE>SCI_SETMODEVENTMASK</CODE></A>.</P>
<P><B id=SCI_SETMODEVENTMASK>SCI_SETMODEVENTMASK(int eventMask)</B><BR><B 
id=SCI_GETMODEVENTMASK>SCI_GETMODEVENTMASK</B><BR>These messages set and get an 
event mask that determines which document change events are notified to the 
container with <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MODIFIED"><CODE>SCN_MODIFIED</CODE></A> 
and <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCEN_CHANGE"><CODE>SCEN_CHANGE</CODE></A>. 
For example, a container may decide to see only notifications about changes to 
text and not styling changes by calling 
<CODE>SCI_SETMODEVENTMASK(SC_MOD_INSERTTEXT|SC_MOD_DELETETEXT)</CODE>.</P>
<P>The possible notification types are the same as the 
<CODE>modificationType</CODE> bit flags used by <CODE>SCN_MODIFIED</CODE>: 
<CODE>SC_MOD_INSERTTEXT</CODE>, <CODE>SC_MOD_DELETETEXT</CODE>, 
<CODE>SC_MOD_CHANGESTYLE</CODE>, <CODE>SC_MOD_CHANGEFOLD</CODE>, 
<CODE>SC_PERFORMED_USER</CODE>, <CODE>SC_PERFORMED_UNDO</CODE>, 
<CODE>SC_PERFORMED_REDO</CODE>, <CODE>SC_MULTISTEPUNDOREDO</CODE>, 
<CODE>SC_LASTSTEPINUNDOREDO</CODE>, <CODE>SC_MOD_CHANGEMARKER</CODE>, 
<CODE>SC_MOD_BEFOREINSERT</CODE>, <CODE>SC_MOD_BEFOREDELETE</CODE>, 
<CODE>SC_MULTILINEUNDOREDO</CODE>, and <CODE>SC_MODEVENTMASKALL</CODE>.</P>
<P><B id=SCEN_SETFOCUS>SCEN_SETFOCUS</B><BR><B 
id=SCEN_KILLFOCUS>SCEN_KILLFOCUS</B><BR><CODE>SCEN_SETFOCUS</CODE> (512) is 
fired when Scintilla receives focus and <CODE>SCEN_KILLFOCUS</CODE> (256) when 
it loses focus. These notifications are sent using the <CODE>WM_COMMAND</CODE> 
message on Windows and the "Command" signal on GTK+ as this is the behavior of 
the standard Edit control. Unfortunately, these codes do not match the Windows 
Edit notification codes <CODE>EN_SETFOCUS</CODE> (256) and 
<CODE>EN_KILLFOCUS</CODE> (512). It is now too late to change the Scintilla 
codes as clients depend on the current values.</P>
<P><B id=SCN_MACRORECORD>SCN_MACRORECORD</B><BR>The <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STARTRECORD">SCI_STARTRECORD</A></CODE> 
and <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_STOPRECORD"><CODE>SCI_STOPRECORD</CODE></A> 
messages enable and disable macro recording. When enabled, each time a 
recordable change occurs, the <CODE>SCN_MACRORECORD</CODE> notification is sent 
to the container. It is up to the container to record the action. To see the 
complete list of <CODE>SCI_*</CODE> messages that are recordable, search the 
Scintilla source <CODE>Editor.cxx</CODE> for 
<CODE>Editor::NotifyMacroRecord</CODE>. The fields of 
<CODE>SCNotification</CODE> set in this notification are:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Macro record notification data" 
border=0>
  <TBODY>
  <TR>
    <TH align=left>Field</TH>
    <TH align=left>Usage</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>message</CODE></TD>
    <TD align=left>The <CODE>SCI_*</CODE> message that caused the 
    notification.</TD></TR>
  <TR>
    <TD align=left><CODE>wParam</CODE></TD>
    <TD align=left>The value of <CODE>wParam</CODE> in the <CODE>SCI_*</CODE> 
      message.</TD></TR>
  <TR>
    <TD align=left><CODE>lParam</CODE></TD>
    <TD align=left>The value of <CODE>lParam</CODE> in the <CODE>SCI_*</CODE> 
      message.</TD></TR></TBODY></TABLE>
<P><B id=SCN_MARGINCLICK>SCN_MARGINCLICK</B><BR>This notification tells the 
container that the mouse was clicked inside a <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Margins">margin</A> 
that was marked as sensitive (see <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMARGINSENSITIVEN"><CODE>SCI_SETMARGINSENSITIVEN</CODE></A>). 
This can be used to perform folding or to place breakpoints. The following 
<CODE>SCNotification</CODE> fields are used:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Margin click notification" 
  border=0><TBODY>
  <TR>
    <TH align=left>Field</TH>
    <TH align=left>Usage</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>modifiers</CODE></TD>
    <TD align=left>The appropriate combination of <CODE>SCI_SHIFT</CODE>, 
      <CODE>SCI_CTRL</CODE> and <CODE>SCI_ALT</CODE> to indicate the keys that 
      were held down at the time of the margin click.</TD></TR>
  <TR>
    <TD align=left><CODE>position</CODE></TD>
    <TD align=left>The position of the start of the line in the document that 
      corresponds to the margin click.</TD></TR>
  <TR>
    <TD align=left><CODE>margin</CODE></TD>
    <TD align=left>The margin number that was clicked.</TD></TR></TBODY></TABLE>
<P><B id=SCN_NEEDSHOWN>SCN_NEEDSHOWN</B><BR>Scintilla has determined that a 
range of lines that is currently invisible should be made visible. An example of 
where this may be needed is if the end of line of a contracted fold point is 
deleted. This message is sent to the container in case it wants to make the line 
visible in some unusual way such as making the whole document visible. Most 
containers will just ensure each line in the range is visible by calling <A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_ENSUREVISIBLE"><CODE>SCI_ENSUREVISIBLE</CODE></A>. 
The <CODE>position</CODE> and <CODE>length</CODE> fields of 
<CODE>SCNotification</CODE> indicate the range of the document that should be 
made visible. The container code will be similar to the following code 
skeleton:</P><PRE>firstLine = SCI_LINEFROMPOSITION(scn.position)
lastLine = SCI_LINEFROMPOSITION(scn.position+scn.length-1)
for line = lineStart to lineEnd do SCI_ENSUREVISIBLE(line) next
</PRE>
<P><B id=SCN_PAINTED>SCN_PAINTED</B><BR>Painting has just been done. Useful when 
you want to update some other widgets based on a change in Scintilla, but want 
to have the paint occur first to appear more responsive. There is no other 
information in <CODE>SCNotification</CODE>.</P>
<P><B id=SCN_USERLISTSELECTION>SCN_USERLISTSELECTION</B><BR>The user has 
selected an item in a <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#UserLists">user 
list</A>. The <CODE>SCNotification</CODE> fields used are:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="User list notification" border=0>
  <TBODY>
  <TR>
    <TH align=left>Field</TH>
    <TH align=left>Usage</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>wParam</CODE></TD>
    <TD align=left>This is set to the <CODE>listType</CODE> parameter from the 
      <A class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_USERLISTSHOW"><CODE>SCI_USERLISTSHOW</CODE></A> 
      message that initiated the list.</TD></TR>
  <TR>
    <TD align=left><CODE>text</CODE></TD>
    <TD align=left>The text of the selection.</TD></TR></TBODY></TABLE><BR><BR>
<P><B id=SCN_URIDROPPED>SCN_URIDROPPED</B><BR>Only on the GTK+ version. 
Indicates that the user has dragged a URI such as a file name or Web address 
onto Scintilla. The container could interpret this as a request to open the 
file. The <CODE>text</CODE> field of <CODE>SCNotification</CODE> points at the 
URI text.</P>
<P><B id=SCN_DWELLSTART>SCN_DWELLSTART</B><BR><B 
id=SCN_DWELLEND>SCN_DWELLEND</B><BR><CODE>SCN_DWELLSTART</CODE> is generated 
when the user keeps the mouse in one position for the dwell period (see <CODE><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETMOUSEDWELLTIME">SCI_SETMOUSEDWELLTIME</A></CODE>). 
<CODE>SCN_DWELLEND</CODE> is generated after a <CODE>SCN_DWELLSTART</CODE> and 
the mouse is moved or other activity such as key press indicates the dwell is 
over. Both notifications set the same fields in <CODE>SCNotification</CODE>:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Mouse dwell notification" 
  border=0><TBODY>
  <TR>
    <TH align=left>Field</TH>
    <TH align=left>Usage</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>position</CODE></TD>
    <TD align=left>This is the nearest position in the document to the 
      position where the mouse pointer was lingering.</TD></TR>
  <TR>
    <TD align=left><CODE>x, y</CODE></TD>
    <TD align=left>Where the pointer lingered. The <CODE>position</CODE> field 
      is set to <CODE><A class=message 
      href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE</A>(x, 
      y)</CODE>.</TD></TR></TBODY></TABLE><BR><BR>
<P><B id=SCI_SETMOUSEDWELLTIME>SCI_SETMOUSEDWELLTIME</B><BR><B 
id=SCI_GETMOUSEDWELLTIME>SCI_GETMOUSEDWELLTIME</B><BR>These two messages set and 
get the time the mouse must sit still, in milliseconds, to generate a <CODE><A 
class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_DWELLSTART">SCN_DWELLSTART</A></CODE> 
notification. If set to <CODE>SC_TIME_FOREVER</CODE>, the default, no dwell 
events are generated.</P>
<P><B id=SCN_ZOOM>SCN_ZOOM</B><BR>This notification is generated when the user 
zooms the display using the keyboard or the <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_SETZOOM">SCI_SETZOOM</A></CODE> 
method is called. This notification can be used to recalculate positions, such 
as the width of the line number margin to maintain sizes in terms of characters 
rather than pixels. <CODE>SCNotification</CODE> has no additional 
information.</P>
<P><B id=SCN_HOTSPOTCLICK>SCN_HOTSPOTCLICK</B><BR><B 
id=SCN_HOTSPOTDOUBLECLICK>SCN_HOTSPOTDOUBLECLICK</B><BR>These notifications are 
generated when the user clicks or double clicks on text that is in a style with 
the hotspot attribute set. This notification can be used to link to variable 
definitions or web pages. The <CODE>position</CODE> field is set the text 
position of the click or double click and the <CODE>modifiers</CODE> field set 
to the key modifiers held down in a similar manner to <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_KEY">SCN_KEY</A>.</P>
<P><B id=SCN_CALLTIPCLICK>SCN_CALLTIPCLICK</B><BR>This notification is generated 
when the user clicks on a calltip. This notification can be used to display the 
next function prototype when a function name is overloaded with different 
arguments. The <CODE>position</CODE> field is set to 1 if the click is in an up 
arrow, 2 if in a down arrow, and 0 if elsewhere.</P>
<P><B id=SCN_AUTOCSELECTION>SCN_AUTOCSELECTION</B><BR>The user has selected an 
item in an <A class=jump 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#Autocompletion">autocompletion 
list</A>. The notification is sent before the selection is inserted. Automatic 
insertion can be cancelled by sending a <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</A></CODE> 
message before returning from the notification. The <CODE>SCNotification</CODE> 
fields used are:</P>
<TABLE cellSpacing=2 cellPadding=1 summary="Autocompletion list notification" 
border=0>
  <TBODY>
  <TR>
    <TH align=left>Field</TH>
    <TH align=left>Usage</TH></TR></TBODY>
  <TBODY vAlign=top>
  <TR>
    <TD align=left><CODE>lParam</CODE></TD>
    <TD align=left>The start position of the word being completed.</TD></TR>
  <TR>
    <TD align=left><CODE>text</CODE></TD>
    <TD align=left>The text of the selection.</TD></TR></TBODY></TABLE>
<H2 id=GTK>GTK+</H2>
<P>On GTK+, the following functions create a Scintilla widget, communicate with 
it and allow resources to be released after all Scintilla widgets hace been 
destroyed.</P><CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#scintilla_new">GtkWidget 
*scintilla_new()</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#scintilla_set_id">void 
scintilla_set_id(ScintillaObject *sci, uptr_t id)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#scintilla_send_message">sptr_t 
scintilla_send_message(ScintillaObject *sci,unsigned int iMessage, uptr_t 
wParam, sptr_t lParam)</A><BR><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#scintilla_release_resources">void 
scintilla_release_resources()</A><BR></CODE>
<P><B id=scintilla_new>GtkWidget *scintilla_new()</B></B><BR>Create a new 
Scintilla widget. The returned pointer can be added to a container and displayed 
in the same way as other widgets.</P>
<P><B id=scintilla_set_id>void scintilla_set_id(ScintillaObject *sci, uptr_t 
id)</B></B><BR>Set the control ID which will be used in the idFrom field of the 
NotifyHeader structure of all notifications for this instance. When an 
application creates multiple Scintilla widgets, this allows the source of each 
notification to be found. The value should be small, preferrably less than 16 
bits, rather than a pointer as some of the functions will only transmit 16 or 32 
bits.</P>
<P><B id=scintilla_send_message>sptr_t scintilla_send_message(ScintillaObject 
*sci,unsigned int iMessage, uptr_t wParam, sptr_t lParam)</B><BR>The main entry 
point allows sending any of the messages described in this document.</P>
<P><B id=scintilla_release_resources>void 
scintilla_release_resources()</B><BR>Call this to free any remaining resources 
after all the Scintilla widgets have been destroyed.</P>
<H2 id=DeprecatedMessages>Deprecated messages and notifications</H2>
<P>The following messages are currently supported to emulate existing Windows 
controls, but they will be removed in future versions of Scintilla. If you use 
these messages you should replace them with the Scintilla equivalent.</P><PRE>WM_GETTEXT(int length, char *text)
WM_SETTEXT(&lt;unused&gt;, const char *text)
EM_GETLINE(int line, char *text)
EM_REPLACESEL(&lt;unused&gt;, const char *text)
EM_SETREADONLY
EM_GETTEXTRANGE(&lt;unused&gt;, TEXTRANGE *tr)
WM_CUT
WM_COPY
WM_PASTE
WM_CLEAR
WM_UNDO
EM_CANUNDO
EM_EMPTYUNDOBUFFER
WM_GETTEXTLENGTH
EM_GETFIRSTVISIBLELINE
EM_GETLINECOUNT
EM_GETMODIFY
EM_SETMODIFY(bool isModified)
EM_GETRECT(RECT *rect)
EM_GETSEL(int *start, int *end)
EM_EXGETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_SETSEL(int start, int end)
EM_EXSETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_GETSELTEXT(&lt;unused&gt;, char *text)
EM_LINEFROMCHAR(int position)
EM_EXLINEFROMCHAR(int position)
EM_LINEINDEX(int line)
EM_LINELENGTH(int position)
EM_SCROLL(int line)
EM_LINESCROLL(int column, int line)
EM_SCROLLCARET()
EM_CANPASTE
EM_CHARFROMPOS(&lt;unused&gt;, POINT *location)
EM_POSFROMCHAR(int position, POINT *location)
EM_SELECTIONTYPE
EM_HIDESELECTION(bool hide)
EM_FINDTEXT(int flags, FINDTEXTEX *ft)
EM_FINDTEXTEX(int flags, FINDTEXTEX *ft)
EM_GETMARGINS
EM_SETMARGINS(EC_LEFTMARGIN or EC_RIGHTMARGIN or EC_USEFONTINFO, int val)
EM_FORMATRANGE
</PRE>
<P>The following are features that are only included if you define 
<CODE>INCLUDE_DEPRECATED_FEATURES</CODE> in <CODE>Scintilla.h</CODE>. To ensure 
future compatibility you should change them as indicated.</P>
<P><B id=SCN_POSCHANGED>SCN_POSCHANGED()</B> Deprecated<BR>Fired when the user 
moves the cursor to a different position in the text. Use <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_UPDATEUI"><CODE>SCN_UPDATEUI</CODE></A> 
instead.</P>
<P><B id=SCN_CHECKBRACE>SCN_CHECKBRACE</B> Deprecated<BR>Either the text or 
styling of the document has changed or the selection range has changed. This is 
replaced by <A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_UPDATEUI"><CODE>SCN_UPDATEUI</CODE></A>. 
You can also use <CODE><A class=message 
href="http://scintilla.sourceforge.net/ScintillaDoc.html#SCN_MODIFIED">SCN_MODIFIED</A></CODE> 
for more detailed information on text and styling changes,</P>
<H2 id=EditMessagesNeverSupportedByScintilla>Edit messages never supported by 
Scintilla</H2><PRE>EM_GETWORDBREAKPROC EM_GETWORDBREAKPROCEX
EM_SETWORDBREAKPROC EM_SETWORDBREAKPROCEX
EM_GETWORDWRAPMODE EM_SETWORDWRAPMODE
EM_LIMITTEXT EM_EXLIMITTEXT
EM_SETRECT EM_SETRECTNP
EM_FMTLINES
EM_GETHANDLE EM_SETHANDLE
EM_GETPASSWORDCHAR EM_SETPASSWORDCHAR
EM_SETTABSTOPS
EM_FINDWORDBREAK
EM_GETCHARFORMAT EM_SETCHARFORMAT
EM_GETOLEINTERFACE EM_SETOLEINTERFACE
EM_SETOLECALLBACK
EM_GETPARAFORMAT EM_SETPARAFORMAT
EM_PASTESPECIAL
EM_REQUESTRESIZE
EM_GETBKGNDCOLOR EM_SETBKGNDCOLOR
EM_STREAMIN EM_STREAMOUT
EM_GETIMECOLOR EM_SETIMECOLOR
EM_GETIMEOPTIONS EM_SETIMEOPTIONS
EM_GETOPTIONS EM_SETOPTIONS
EM_GETPUNCTUATION EM_SETPUNCTUATION
EM_GETTHUMB
EM_GETEVENTMASK
EM_SETEVENTMASK
EM_DISPLAYBAND
EM_SETTARGETDEVICE
</PRE>
<P>Scintilla tries to be a superset of the standard windows Edit and RichEdit 
controls wherever that makes sense. As it is not intended for use in a word 
processor, some edit messages can not be sensibly handled. Unsupported messages 
have no effect.</P>
<H2 id=BuildingScintilla>Building Scintilla</H2>
<P>To build Scintilla or SciTE, see the README file present in both the 
Scintilla and SciTE directories. For Windows, GCC 3.2, Borland C++ or Microsoft 
Visual Studio .NET can be used for building. There is a make file for building 
Scintilla but not SciTE with Visual C++ 6 at scintilla/win32/scintilla_vc6.mak. 
For GTK+, GCC 3.1 should be used. GTK+ 1.2x and 2.0x are supported. The version 
of GTK+ installed should be detected automatically. When both GTK+ 1 and GTK+ 2 
are present, building for GTK+ 1.x requires defining GTK1 on the command 
line.</P>
<H3>Static linking</H3>
<P>On Windows, Scintilla is normally used as a dynamic library as a .DLL file. 
If you want to link Scintilla directly into your application .EXE or .DLL file, 
then the <CODE>STATIC_BUILD</CODE> preprocessor symbol should be defined and 
<CODE>Scintilla_RegisterClasses</CODE> called. <CODE>STATIC_BUILD</CODE> 
prevents compiling the <CODE>DllMain</CODE> function which will conflict with 
any <CODE>DllMain</CODE> defined in your code. 
<CODE>Scintilla_RegisterClasses</CODE> takes the <CODE>HINSTANCE</CODE> of your 
application and ensures that the "Scintilla" window class is registered. To make 
sure that the right pointing arrow cursor used in the margin is displayed by 
Scintilla add the <CODE>scintilla/win32/Margin.cur</CODE> file to your 
application's resources with the ID <CODE>IDC_MARGIN</CODE> which is defined in 
<CODE>scintilla/win32/platfromRes.h</CODE> as 400.</P>
<H3>Ensuring lexers are linked into Scintilla</H3>
<P>Depending on the compiler and linker used, the lexers may be stripped out. 
This is most often caused when building a static library. To ensure the lexers 
are linked in, the <CODE>Scintilla_LinkLexers()</CODE> function may be 
called.</P>
<H3>Changing set of lexers</H3>
<P>To change the set of lexers in Scintilla, add and remove lexer source files 
(<CODE>Lex*.cxx</CODE>) from the <CODE>scintilla/src directory</CODE> and run 
the <CODE>src/LexGen.py</CODE> script from the <CODE>src</CODE> directory to 
update the make files and <CODE>KeyWords.cxx</CODE>. <CODE>LexGen.py</CODE> 
requires Python 2.1 or later. If you do not have access to Python, you can hand 
edit <CODE>KeyWords.cxx</CODE> in a simple-minded way, following the patterns of 
other lexers. The important thing is to include 
<CODE>LINK_LEXER(lmMyLexer);</CODE> to correspond with the <CODE>LexerModule 
lmMyLexer(...);</CODE> in your lexer source code.</P></BODY></HTML>
