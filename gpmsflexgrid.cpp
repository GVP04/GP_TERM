// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "GP_term.h"
#include "gpmsflexgrid.h"
#include "GP_TermView.h"

// Dispatch interfaces referenced by this interface
#include "GPOleFont.h"
#include "GPPicture.h"
#include "gprowcursor.h"
//#include "occimpl.h"


const UINT GPCMSFlexGrid::uNMethods=219;
const char *GPCMSFlexGrid::cArrMethods[]={
	"GetRows","SetRows","GetCols","SetCols","GetFixedRows",
	"SetFixedRows","GetFixedCols","SetFixedCols","GetVersion","GetFormatString",
	"SetFormatString","GetTopRow","SetTopRow","GetLeftCol","SetLeftCol",
	"GetRow","SetRow","GetCol","SetCol","GetRowSel",
	"SetRowSel","GetColSel","SetColSel","GetText","SetText",
	"GetBackColor","SetBackColor","GetForeColor","SetForeColor","GetBackColorFixed",
	"SetBackColorFixed","GetForeColorFixed","SetForeColorFixed","GetBackColorSel","SetBackColorSel",
	"GetForeColorSel","SetForeColorSel","GetBackColorBkg","SetBackColorBkg","GetWordWrap",
	"SetWordWrap","GetFont","SetFont","GetFontWidth","SetFontWidth",
	"GetCellFontName","SetCellFontName","GetCellFontSize","SetCellFontSize","GetCellFontBold",
	"SetCellFontBold","GetCellFontItalic","SetCellFontItalic","GetCellFontUnderline","SetCellFontUnderline",
	"GetCellFontStrikeThrough","SetCellFontStrikeThrough","GetCellFontWidth","SetCellFontWidth","GetTextStyle",
	"SetTextStyle","GetTextStyleFixed","SetTextStyleFixed","GetScrollTrack","SetScrollTrack",
	"GetFocusRect","SetFocusRect","GetHighLight","SetHighLight","GetRedraw",
	"SetRedraw","GetScrollBars","SetScrollBars","GetMouseRow","GetMouseCol",
	"GetCellLeft","GetCellTop","GetCellWidth","GetCellHeight","GetRowHeightMin",
	"SetRowHeightMin","GetFillStyle","SetFillStyle","GetGridLines","SetGridLines",
	"GetGridLinesFixed","SetGridLinesFixed","GetGridColor","SetGridColor","GetGridColorFixed",
	"SetGridColorFixed","GetCellBackColor","SetCellBackColor","GetCellForeColor","SetCellForeColor",
	"GetCellAlignment","SetCellAlignment","GetCellTextStyle","SetCellTextStyle","GetCellPictureAlignment",
	"SetCellPictureAlignment","GetClip","SetClip","SetSort","GetSelectionMode",
	"SetSelectionMode","GetMergeCells","SetMergeCells","GetAllowBigSelection","SetAllowBigSelection",
	"GetAllowUserResizing","SetAllowUserResizing","GetBorderStyle","SetBorderStyle","GetEnabled",
	"SetEnabled","GetAppearance","SetAppearance","GetMousePointer","SetMousePointer",
	"GetMouseIcon","SetMouseIcon","GetPictureType","SetPictureType","GetPicture",
	"GetCellPicture","SetCellPicture","GetTextArray","SetTextArray","GetColAlignment",
	"SetColAlignment","GetColWidth","SetColWidth","GetRowHeight","SetRowHeight",
	"GetMergeRow","SetMergeRow","GetMergeCol","SetMergeCol","SetColPosition",
	"GetRowData","SetRowData","GetColData","SetColData","GetTextMatrix",
	"SetTextMatrix","AddItem","RemoveItem","Clear","Refresh",
	"GetDataSource","SetDataSource","GetRowIsVisible","GetColIsVisible","GetRowPos",
	"GetColPos","GetGridLineWidth","SetGridLineWidth","GetFixedAlignment","SetFixedAlignment",
	"GetRightToLeft","SetRightToLeft","GetOLEDropMode","SetOLEDropMode","OLEDrag",
	"SetRowPosition","AddItems","AddItemEx","AddItemsEx","GetPosInfo",
	"GetColorInfo","GetSel","SetCellsText","GetCellRect","SetSel",
	"SetSelText","FindCell","FindCellExact","FindNextCell","SetFindPosition",
	"SetFindDirection","ReplaceCell","ReplaceCellExact","ReplaceNextCell","ReplaceAllCells",
	"ReplaceText","ReplaceTextExact","ReplaceNextText","ReplaceAllText","SetItemText",
	"SetItemsText","SetItemTextEx","SetItemsTextEx","AddColumn","RemoveColumn",
	"SaveListContents","SaveListContentsH","ReplaceFromSpr","AddFromSpr","FillFromSpr",
	"SetDefEditor","GetDefEditor","reserv","reserv","SetEditorPerColumn",
	"SetEditorPerRow","SetEditOnOff","SetEditCell","GetEditCell","GetEditResult",
	"SetAutoUpdate","SetEditPosParam","EnsureVisible","GetListContents","ClearRegion",
	"DeleteRow","DeleteCol","DeleteRows","DeleteCols","",
	"","","", "", "", 
	"","","","",
	};

const char *GPCMSFlexGrid::cArrMethodsParams[]={
	"","nRow","","nCol","",
	"nRow","","nCol","","",
	"FormatString","","TopRow","","LeftCol",
	"","Row","","Col","",
	"RowSel","","ColSel","","NewText",
	"","R,G,B","","R,G,B","",
	"R,G,B","","R,G,B","","R,G,B",
	"","R,G,B","","R,G,B","",
	"boolSet","","Font Description","","float newValue",
	"","Font Name","","float newValue","",
	"boolSet","","boolSet","","boolSet",
	"","boolSet","","float newValue","",
	"NewStyle","","NewStyle","","boolSet",
	"","nNewValue","","nNewValue","",
	"bNewValue","","nNewValue","","",
	"","","","","",
	"nNewValue","","nNewValue","","nNewValue",
	"","nNewValue","","R,G,B","",
	"R,G,B","","R,G,B","","R,G,B",
	"","nNewValue","","nNewValue","",
	"nNewValue","","lpszNewValue","nNewValue","",
	"nNewValue","","nNewValue","","bNewValue",
	"","nNewValue","","nNewValue","",
	"bNewValue","","nNewValue","","nNewValue",
	"","File name","","nNewValue","",
	"","File name","","index, lpszNewValue","index",
	"index,nNewValue","index","index, nNewValue","index","index,nNewValue",
	"index","index,bNewValue","index","index,bNewValue","index, nNewIndex",
	"index","index,nNewValue","index","index,nNewValue","Row,Col",
	"Row,Col,lpszNewValue","index,Item","index","","",
	"unrel","unrel","index","index","index",
	"index","","nNewValue","","index",
	"","nNewValue","","bNewValue","",
	"index,nNewIndex","nItemBefore,ItemsArr","nItemBefore,SubItemsArr","nItemBefore,ItemsSubItemsArr","",
	"","","RowStart,ColStart,RowEnd,ColEnd,Text","Row,Col","RowStart,ColStart,RowEnd,ColEnd",
	"Text","RowStart,ColStart,RowEnd,ColEnd,Direction,Text","RowStart,ColStart,RowEnd,ColEnd,Direction,Text","","Row,Col",
	"Direction","RowStart,ColStart,RowEnd,ColEnd,Direction,Text","RowStart,ColStart,RowEnd,ColEnd,Direction,Text","","RowStart,ColStart,RowEnd,ColEnd,Direction,Text",
	"RowStart,ColStart,RowEnd,ColEnd,Direction,TextChar(1)Replace","RowStart,ColStart,RowEnd,ColEnd,Direction,TextChar(1)Replace","","RowStart,ColStart,RowEnd,ColEnd,Direction,TextChar(1)Replace","nCol,TextArray",
	"nRow,TextArray","nRow,TextArray","nRow,nCol,TextArray2","nColumn","nColumn",
	"DELIMETER,nFile,Left,Top,Right,Bottom;ColN,ColNN,....","DELIMETER,nFile,Left,Top,Right,Bottom;ColN,ColNN,....","SprName,nField1^nField2^... ,nCol1^nCol2^...","SprName,nField1^nField2^... ,nCol1^nCol2^...","StartItem,EndItem,SprName1,nCodeCol1,nReplCol1,nFindField1,nTextField1,Prefix1^SprName2,nCodeCol2,nReplCol2,nFindField2,nTextField2,Prefix1...",
	"ObjId","","","","nCol,ObjId^ObjId^....",
	"nCol,ObjId^ObjId^....","onoff,verhor,skip,forback,lcbreak,delnext","nRow,nCol","","",
	"OnOff","nCol1^nCol2^nCol3^...","nRow,nCol","Left,Top,Right,Bottom","Left,Top,Right,Bottom;repltext",
	"nRow","nCol","nRowStart,nRowEnd","nColStart,nColEnd","",
	"","","", "", "", 
	"","","","",
	};



/////////////////////////////////////////////////////////////////////////////
// GPCMSFlexGrid

//IMPLEMENT_DYNCREATE(GPCMSFlexGrid, CWnd)

BEGIN_MESSAGE_MAP(GPCMSFlexGrid, CWnd)
	//{{AFX_MSG_MAP(GPCMSFlexGrid)
	ON_WM_SIZING()
	ON_WM_NCHITTEST()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_LBUTTONUP()
	ON_WM_MBUTTONUP()
	ON_WM_RBUTTONUP()
	ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// GPCMSFlexGrid properties

/////////////////////////////////////////////////////////////////////////////
// GPCMSFlexGrid operations
GPCMSFlexGrid::GPCMSFlexGrid()
{
	GPCMSFlexGridINIT(0);
}
GPCMSFlexGrid::GPCMSFlexGrid(UINT iUnitId)
{
	GPCMSFlexGridINIT(iUnitId);
}

void GPCMSFlexGrid::GPCMSFlexGridINIT(UINT iUnitId)
{
	m_DOSubItem=0;
	m_uLastMouseUpFlag=0;
	DefEditor=0;
	m_EditInProgr=0;
	AutoUpdate=FALSE;
	MayBeChangeEdit=FALSE;
	hti.x=hti.y=-1;
	lasthti.x=lasthti.y=-2;
	LastEditorID=0;
	EditorID=0;
	referGPU=NULL;
	UnitId=iUnitId;
	LastEditResult="";
	m_Sink=NULL;
	pCP = NULL;
	m_dwCookie=0;

	m_fgFindItem.iStartRow=1;
	m_fgFindItem.iStartCol=1;
	m_fgFindItem.iEndRow=-1;
	m_fgFindItem.iEndCol=-1;
	m_fgFindItem.iCurentRow=1;
	m_fgFindItem.iCurentCol=1;
	m_fgFindItem.csFindWhat="";
	m_fgFindItem.bbyRow=TRUE;
	m_fgFindItem.bForward=TRUE;
	m_fgFindItem.bExactly=FALSE;
	m_fgFindItem.csReplace="";
	m_fgFindItem.bReplace=FALSE;
	m_fgFindItem.bReplaceFull=TRUE;

	int i;
	for(i=0;i<50;i++)
		iArrPosExOut[i]=-1;
}

GPCMSFlexGrid::~GPCMSFlexGrid()
{
	if (pCP)
	{
		pCP->Unadvise(m_dwCookie);
		pCP->Release();
	}
	if (m_Sink!=NULL) delete m_Sink;
	m_Sink=NULL;
}

void GPCMSFlexGrid::ClearAllData()
{
	long nIt,i,idt;
	try{nIt=GetRows();}
	catch(...)
	{
		GPC.m_ErrReport.GPWriteErrorLog("GPCMSFlexGrid", "ClearAllData 206","");
		nIt=0;
	}
	for(i=0;i<nIt;i++)
	{
		idt=GetRowData(i);
		if (idt)
		{
			delete(FGITEMDATA *) idt;
			SetRowData(i,0);
		}
	}

	try{nIt=GetCols();}
	catch(...)
	{
		GPC.m_ErrReport.GPWriteErrorLog("GPCMSFlexGrid", "ClearAllData 222","");
		nIt=0;
	}
	for(i=0;i<nIt;i++)
	{
		idt=GetColData(i);
		if (idt)
		{
			delete(FGITEMDATA *) idt;
			SetColData(i,0);
		}
	}
}

UINT GPCMSFlexGrid::DoMethod(const char *iStr, char *oStr)
{
	char met[150];
	strncpy(met,iStr,145);met[145]=0;
	const char *pos=strchr(iStr,' ');
	if (pos++) *strchr(met,' ')=0;
	else		pos="";	

	int nfunc=0;

	int retint=-123456; 
	int atoipos=atoi(pos);
	
	if (*met>='0' && *met<='9') nfunc=atoi(met);
	else
	{
		static const char *sccArrMethods[sizeof(cArrMethods)/sizeof(char *)];
		static DWORD scdMethodsId[sizeof(cArrMethods)/sizeof(char *)];
		if (!*sccArrMethods)
		{
			DWORD i;
			for(i=0;i<uNMethods;i++)
			{
				sccArrMethods[i]=cArrMethods[i];
				scdMethodsId[i]=i;
			}
			qsCharILineAndDWORD(sccArrMethods, scdMethodsId, 0, uNMethods-1);
			scdMethodsId[i]=i;
		}
		nfunc=scdMethodsId[FindInSortArrayIC(met, sccArrMethods, uNMethods)];
	}
	try
	{
		switch(nfunc)
		{
		case 203: /**/
			break;
		case 202: /**/
			break;
		case 212: /*EnsureVisible*/
			{
				long nRow=0,nCol=0;
				m_LastScanf=sscanf(pos,"%d,%d",&nRow,&nCol);
				retint=EnsureVisible(nRow,nCol);
			}
			break;
		case 211: /*SetEditPosParam*/
			{
				int i;
				for(i=0;i<50;i++)	iArrPosExOut[i]=-1;
				const char *pos2=pos;
				
				for(i=0;i<50 && *pos2!=0;i++)	
				{
					iArrPosExOut[i]=atoi(pos2);
					while(*pos2!=0 && *pos2!=',' && *pos2!=GPC.DelimiterIn1 && *pos2!=';') pos2++;
					if (*pos2!=0) pos2++;
				}
			}
			break;
		case 210: /*SetAutoUpdate*/
			retint=AutoUpdate;
			AutoUpdate=atoipos;
			break;
		case 209: /*GetEditResult*/
			if (oStr!=NULL)	strcpy(oStr,(LPCSTR)LastEditResult);
			break;
		case 208: /*GetEditCell*/
			if (oStr!=NULL)	sprintf(oStr,"%d\x7F%d",hti.y,hti.x);
			break;
		case 207: /*SetEditCell*/
			{
				int iItem=0;
				UINT iSubItem=0;
				m_LastScanf=sscanf(pos,"%d,%d",&iItem,&iSubItem);
				if (iItem>=0 && iItem<GetRows())
				{ 
					hti.y=iItem;
					hti.x=iSubItem;
					EnsureVisible(iItem,iSubItem);
					SetEditRect();
					SetSelByEdit();
					Invalidate();
				}
			}
			break;
		case 206: /*SetEditOnOff*/
			{	//29,M,SetEditOnOff 1,0,1,0,1
				int onoff=0,verhor=0,forback=0,skip=0,lcbreak=0,delnext=0;
				m_LastScanf=sscanf(pos,"%d,%d,%d,%d,%d,%d",&onoff,&verhor,&skip,&forback,&lcbreak,&delnext);
				onoff%=2;verhor%=2;skip%=2;forback%=2;lcbreak%=2;delnext%=2;
				retint=m_EditInProgr;
				if (onoff>1)	m_EditInProgr=onoff;
				else			m_EditInProgr=onoff+verhor*2+skip*4+forback*8+lcbreak*16+delnext*32;
				if (onoff==0)
				{
					lasthti.y=-1;lasthti.x=-1;
					if (LastEditorID>0 && referGPU && LastEditorID<(*referGPU)->m_NGPUNIT && referGPU[LastEditorID] && referGPU[LastEditorID]->UnitHWND!=NULL)
						referGPU[LastEditorID]->GPSetProperty("DELSTYLE=WS_VISIBLE");
				}
				Invalidate();
			}
			break;
		case 205: /*SetEditorPerRow*/
		case 204: /*SetEditorPerColumn*/
			{
				int nItem=0;
				if (nfunc==205)	nItem=GetRows();
				else			nItem=GetCols();

				const char *edpos=strchr(pos,',');
				if (edpos++==NULL) edpos="";

				while(edpos && *edpos && atoipos<nItem)
				{
					PFGITEMDATA ptr=NULL;
					if (nfunc==205)	ptr=(PFGITEMDATA)GetRowData(atoipos);
					else			ptr=(PFGITEMDATA)GetColData(atoipos);

					if (ptr==NULL)
					{
						ptr=new FGITEMDATA;
						ptr->iValue=0;
						ptr->EditorId=0;
						ptr->cdValue=0;
						ptr->csValue="";
					}
					ptr->EditorId=atoi(edpos);

					if (ptr->EditorId==0 && ptr->csValue=="" && ptr->cdValue==0 && ptr->iValue==0)
					{
						delete ptr;
						ptr=NULL;
					}

					if (nfunc==205)	SetRowData(atoipos++,(long)ptr);
					else			SetColData(atoipos++,(long)ptr);
					

					while(*edpos && *edpos>='0' && *edpos<='9') edpos++;
					if (*edpos) edpos++;
				}
			}
			break;
		case 201: /*GetDefEditor*/
			retint=DefEditor;
			break;
		case 200: /*SetDefEditor*/
			retint=DefEditor;
			DefEditor=atoipos;
			break;
		case 199: /*FillFromSpr*/
		case 198: /*AddFromSpr*/
			{
				char *pos333=new char [(int)strlen(pos)+2];
				strcpy(pos333,pos);
				char *tmp=pos333,*tmp2;
				tmp2=strchr(tmp,',');
				if (tmp2!=NULL) *(tmp2++)=0;
				else tmp2="";
				CGPSpr *spr=GPC.m_SprArray.GetSpr(tmp);
				if (spr!=NULL) 
				{
					IUnknown*  pUnk;
					LPDISPATCH lpDisp;
					HRESULT    hr;
					pUnk = GetControlUnknown();
					if (pUnk)
					{
						hr = pUnk->QueryInterface(IID_IDispatch,(void**)&lpDisp);
						if (SUCCEEDED(hr))
						{
							retint=spr->FillObject(lpDisp,tmp2,nfunc==199?0:1);
							lpDisp->Release();
						}
					}
				}
				delete[] pos333;
			}
			break;
		case 197: /*ReplaceFromSpr*///"StartItem,EndItem,SprName1,nCodeCol1,nReplCol1,nFindField1,nTextField1,Prefix1^SprName2,nCodeCol2,nReplCol2,nFindField2,nTextField2,Prefix1...",
			{
				::SetFocus(m_hWnd);

				long StartItem=0,EndItem=-1;
				m_LastScanf=sscanf(pos,"%ld,%ld",&StartItem,&EndItem);
				const char *tmp=pos;
				while(*tmp!=0 && *tmp!=',') tmp++;
				if (*tmp!=0) tmp++;
				if (*tmp!=0)
					while(*tmp!=0 && *tmp!=',') tmp++;
				if (*tmp!=0) tmp++;

				IUnknown*  pUnk;
				LPDISPATCH lpDisp;
				HRESULT    hr;
				pUnk = GetControlUnknown();
				if (pUnk)
				{
					hr = pUnk->QueryInterface(IID_IDispatch,(void**)&lpDisp);
					if (SUCCEEDED(hr))
					{
						retint=GPC.m_SprArray.ReplaceOblectEx(lpDisp,StartItem,EndItem,tmp);
						lpDisp->Release();
					}
				}
			}
			break;
		case 196: /*SaveListContentsH*/
		case 195: /*SaveListContents*/
			retint=-1;
			if (*pos!=0)
			{
				char *postmpcc=new char [(int)strlen(pos)+10];
				strcpy(postmpcc,pos);

				int nFile=0;
				int i,j,nItem=GetRows();
				int nCol=GetCols();
				int Left,Right,Top,Bottom;
				Left=Right=Top=Bottom=-1;
				char *pos2=strchr(postmpcc+1,',');
				if (pos2!=NULL) *(pos2++)=0; else pos2="";
				m_LastScanf=sscanf(pos2,"%d,%d,%d,%d,%d",&nFile,&Left,&Top,&Right,&Bottom);

				if (nFile>=0 && nFile<GP_NFILES &&GPC.m_View->aGP_File[nFile]!=NULL)
				{
					char *poscol=strchr(pos2,';');
					char *buff=new char [10000];
					int *colarr=NULL,nOutCol=0;

					if (Left<0) Left=0;
					if (Right<Left || Right>=nCol ) Right=nCol-1;
					if (Top<0) Top=0;
					if (Bottom<Top || Bottom>=nItem ) Bottom=nItem-1;

					if (poscol!=NULL)
					{
						nOutCol=CountOccurence(poscol,",");
						if (nOutCol>0 && nOutCol<10000)
						{
							colarr=new int [nOutCol+5];

							for(i=0;i<nOutCol && poscol!=NULL;i++)
							{
								if ((colarr[i]=atoi(++poscol))<0 || colarr[i]>=nCol || colarr[i]<Left || colarr[i]>Right)
									{nOutCol--,i--;}
								poscol=strchr(poscol,';');
							}

							if (nOutCol<=0) {delete[] colarr; colarr=NULL;}
						}
					}
					UINT tmpConvON=GPC.m_View->aGP_File[nFile]->ConvON;
					if ((tmpConvON&1)==1)GPC.m_View->aGP_File[nFile]->ConvON^=1;
					retint=0;

					if (nfunc==196) /*SaveListContentsH*/
					{
						int nFRow=GetFixedRows();

						int cc;
						for(cc=0;cc<nFRow;cc++)
						{
							if (colarr!=NULL)
								for(j=0;j<nOutCol;j++)
								{
									if (j!=0)GPC.m_View->aGP_File[nFile]->GPWriteBlock(postmpcc);
									strcpy(buff,GetTextMatrix(cc,colarr[j]));
									if (*buff!=0)
										GPC.m_View->aGP_File[nFile]->GPWriteBlock(buff);
								}
							else
								for(j=Left;j<=Right;j++)
								{
									if (j!=Left)GPC.m_View->aGP_File[nFile]->GPWriteBlock(postmpcc);
									strcpy(buff,GetTextMatrix(cc,j));
									if (*buff!=0)
										GPC.m_View->aGP_File[nFile]->GPWriteBlock(buff);
								}
							GPC.m_View->aGP_File[nFile]->GPPutStr("");
						}
					}
		
					for(i=(Top==0 && nfunc==196)?Top+GetFixedRows()-1:Top;i<=Bottom;i++,retint++)
					{
						if (colarr!=NULL)
							for(j=0;j<nOutCol;j++)
							{
								if (j!=0)GPC.m_View->aGP_File[nFile]->GPWriteBlock(postmpcc);
								strcpy(buff,GetTextMatrix(i,colarr[j]));
								if (*buff!=0)
									GPC.m_View->aGP_File[nFile]->GPWriteBlock(buff);
							}
						else
							for(j=Left;j<=Right;j++)
							{
								if (j!=Left)GPC.m_View->aGP_File[nFile]->GPWriteBlock(postmpcc);
								strcpy(buff,GetTextMatrix(i,j));
								if (*buff!=0)
									GPC.m_View->aGP_File[nFile]->GPWriteBlock(buff);
							}
						GPC.m_View->aGP_File[nFile]->GPPutStr("");
					}

					if ((tmpConvON&1)==1)GPC.m_View->aGP_File[nFile]->ConvON^=1;
					if (colarr!=NULL) delete[] colarr;
					if (buff!=NULL) delete[] buff;
				}
				delete[] postmpcc;
			}
			break;

		case 194: /*RemoveColumn*/
			{
				int nCols=GetCols();
				if (atoipos>=0 && atoipos<nCols && GetFixedCols()<nCols+1)
				{
					if (atoipos<--nCols) SetColPosition(atoipos,nCols);
					SetCols(nCols);
				}
			}
			break;
		case 193: /*AddColumn*/
			{
				int nCols=GetCols();
				if (atoipos<0) atoipos=0;
				if (atoipos>nCols) atoipos=nCols;
				SetCols(nCols+1);
				if (atoipos<nCols) SetColPosition(nCols,atoipos);
			}
			break;
		case 192: /*SetItemsTextEx*/
		case 190: /*SetItemsText*/
			{
				char *postmpcc=new char [(int)strlen(pos)+10];
				strcpy(postmpcc,pos);

				char *pos2=strchr(postmpcc,',');
				if (pos2++==NULL) pos2="";
				int StartCol=0;
				if (nfunc==192)
				{
					StartCol=atoi(pos2);
					pos2=strchr(pos2,',');
					if (pos2++==NULL) pos2="";
				}

				int nRow=GetRows();
				int nCol=GetCols();

				while(pos2!=NULL && atoipos<nRow && atoipos>=0)
				{
					char *pos3=strchr(pos2,GPC.DelimiterIn1);
					if (pos3!=NULL) *(pos3++)=0;

					int col=StartCol;
					while(pos2!=NULL && col<nCol)
					{
						char *pos4=strchr(pos2,GPC.DelimiterIn2);
						if (pos4!=NULL) *(pos4++)=0;
						TranslateText(atoipos,col++,pos2);	
						pos2=pos4;
					}
					pos2=pos3;
					atoipos++;
				}
				delete[] postmpcc;
			}
			break;
		case 191: /*SetItemTextEx*/
		case 189: /*SetItemText*/
			if (GetRows()>atoipos && atoipos>=0)
			{
				char *postmpcc=new char [(int)strlen(pos)+10];
				strcpy(postmpcc,pos);
				char *pos2=strchr(postmpcc,',');
				if (pos2++==NULL) pos2="";
				int col=0;
				if (nfunc==191)
				{
					col=atoi(pos2);
					pos2=strchr(pos2,',');
					if (pos2++==NULL) pos2="";
				}

				int nCol=GetCols();
				while(pos2!=NULL && col<nCol)
				{
					char *pos3=strchr(pos2,GPC.DelimiterIn1);
					if (pos3!=NULL) *(pos3++)=0;
					TranslateText(atoipos,col++,pos2);	
					pos2=pos3;
				}
				delete[] postmpcc;
			}
			break;
		case 180: /*SetFindDirection*/
			m_fgFindItem.bForward=(atoipos&1)!=0;
			m_fgFindItem.bbyRow=(atoipos&2)!=0;
			break;
		case 179: /*SetFindPosition*/ 
			m_LastScanf=sscanf(pos,"%d,%d",&m_fgFindItem.iCurentRow,&m_fgFindItem.iCurentCol);
			if (m_fgFindItem.iCurentRow<0) m_fgFindItem.iCurentRow=GetRows()-1;
			if (m_fgFindItem.iCurentCol<0) m_fgFindItem.iCurentCol=GetCols()-1;
			break;
		case 188: /*ReplaceAllText*/
		case 187: /*ReplaceNextText*/
		case 186: /*ReplaceTextExact*/
		case 185: /*ReplaceText*/
		case 184: /*ReplaceAllCells*/
		case 183: /*ReplaceNextCell*/
		case 182: /*ReplaceCellExact*/
		case 181: /*ReplaceCell*/
		case 178: /*FindNextCell*/ 
		case 177: /*FindCellExact*/ 
		case 176: /*FindCell*/ 
			{
				int nCol=GetCols();
				int nRow=GetCols();
				switch(nfunc)
				{
				case 188: /*ReplaceAllText*/
				case 186: /*ReplaceTextExact*/
				case 185: /*ReplaceText*/
				case 184: /*ReplaceAllCells*/
				case 182: /*ReplaceCellExact*/
				case 181: /*ReplaceCell*/
				case 177: /*FindCellExact*/ 
				case 176: /*FindCell*/ 
					{
						char *tmpstr=new char [(int)strlen(pos)+10];
						*tmpstr=0;
						m_LastScanf=sscanf(pos,"%d,%d,%d,%d,%d,%s",
							&m_fgFindItem.iStartRow,	&m_fgFindItem.iStartCol,
							&m_fgFindItem.iEndRow,		&m_fgFindItem.iEndCol,
							&atoipos,					tmpstr				);

						char *posreplace=strchr(tmpstr,1);
						if (posreplace) *(posreplace++)=0;
						else posreplace="";

						m_fgFindItem.csFindWhat=tmpstr;
						m_fgFindItem.csReplace=posreplace;

						m_fgFindItem.bForward=(atoipos&1)!=0;
						m_fgFindItem.bbyRow=(atoipos&2)!=0;

						if (m_fgFindItem.iEndRow<0) m_fgFindItem.iEndRow=nRow-1;
						if (m_fgFindItem.iEndCol<0) m_fgFindItem.iEndCol=nCol-1;
						m_fgFindItem.iCurentRow=m_fgFindItem.bForward?m_fgFindItem.iEndRow:m_fgFindItem.iStartRow;
						m_fgFindItem.iCurentCol=m_fgFindItem.bForward?m_fgFindItem.iEndCol:m_fgFindItem.iStartCol;
					}
					break;
				}

				switch(nfunc)
				{
				case 188: /*ReplaceAllText*/
					m_fgFindItem.bReplaceFull=FALSE;
					m_fgFindItem.bReplace=TRUE;
					break;
				case 186: /*ReplaceTextExact*/
					m_fgFindItem.bReplaceFull=FALSE;
					m_fgFindItem.bExactly=TRUE,
					m_fgFindItem.bReplace=TRUE;
					break;
				case 185: /*ReplaceText*/
					m_fgFindItem.bReplaceFull=FALSE;
					m_fgFindItem.bExactly=FALSE,
					m_fgFindItem.bReplace=TRUE;
					break;
				case 184: /*ReplaceAllCells*/
					m_fgFindItem.bReplaceFull=TRUE;
					m_fgFindItem.bReplace=TRUE;
					break;
				case 182: /*ReplaceCellExact*/
					m_fgFindItem.bReplaceFull=TRUE;
					m_fgFindItem.bExactly=TRUE,
					m_fgFindItem.bReplace=TRUE;
					break;
				case 181: /*ReplaceCell*/
					m_fgFindItem.bReplaceFull=TRUE;
					m_fgFindItem.bExactly=FALSE,
					m_fgFindItem.bReplace=TRUE;
					break;
				case 177: /*FindCellExact*/ 
					m_fgFindItem.bExactly=TRUE,
					m_fgFindItem.bReplace=FALSE;
					break;
				case 176: /*FindCell*/ 
					m_fgFindItem.bExactly=FALSE,
					m_fgFindItem.bReplace=FALSE;
					break;
				}

				switch(nfunc)
				{
				case 188: /*ReplaceAllText*/
				case 184: /*ReplaceAllCells*/
					retint=FindReplaceAllItem(m_fgFindItem);
					break;
				case 187: /*ReplaceNextText*/
				case 186: /*ReplaceTextExact*/
				case 185: /*ReplaceText*/
				case 183: /*ReplaceNextCell*/
				case 182: /*ReplaceCellExact*/
				case 181: /*ReplaceCell*/
				case 178: /*FindNextCell*/ 
				case 177: /*FindCellExact*/ 
				case 176: /*FindCell*/ 
					retint=FindNextItem();
					break;
				}

				if (retint>=0 && oStr!=NULL)
					sprintf(oStr,"%d\x7F%d\x7F%s",retint/nCol,retint%nCol,(LPCSTR)GetTextMatrix(retint/nCol,retint%nCol));
			}
			break;
		case 175:	/*SetSelText*/	
			{
				int Row1=GetRow(), Row2=GetRowSel(), Col1=GetCol(), Col2=GetColSel();
				int i,j;
				for(i=Row1;i<=Row2;i++)
					for(j=Col1;j<=Col2;j++)
						TranslateText(i,j,pos);
			}
		case 174:	/*SetSel*/	
			{
				int Row1=0, Row2=-1, Col1=0, Col2=-1;
				m_LastScanf=sscanf(pos,"%d,%d,%d,%d",&Row1,&Col1,&Row2,&Col2);
				SetRow(Row1);
				SetCol(Col1);
				SetRowSel(Row2<0?GetRows()-1:Row2);
				SetColSel(Col2<0?GetCols()-1:Col2);
			}
			break;
		case 173:	/*GetCellRect*/	
			if (oStr)
			{
				int Row=-1, Col=-1;
				m_LastScanf=sscanf(pos,"%d,%d",&Row,&Col);
				if (Row<0) Row=GetRow();
				if (Col<0) Col=GetCol();
				CRect re=GetCellRect(Row,Col);
				sprintf(oStr,"%d\x7F%d\x7F%d\x7F%d",re.top,re.left,re.bottom,re.right);
			}
			break;
		case 172:	/*SetCellsText*/
			{
				int Row1=0, Row2=0, Col1=0, Col2=0;
				char *tmpstr=new char [(int)strlen(pos)+20];
				m_LastScanf=sscanf(pos,"%d,%d,%d,%d,%s",&Row1,&Col1,&Row2,&Col2,tmpstr);
				int i,j;
				if (Row1<0) Row1=0;
				if (Col1<0) Col1=0;
				if (Row2>=(i=GetRows())) Row2=i;
				if (Col2>=(i=GetCols())) Col2=i;
				if (Row2<0) Row2=GetRows()-1;
				if (Col2<0) Col2=GetCols()-1;
				if (Row1>Row2) Row1=Row2;
				if (Col1>Col2) Col1=Col2;

				for(i=Row1;i<=Row2;i++)
					for(j=Col1;j<=Col2;j++)
						TranslateText(i,j,tmpstr);
				delete[] tmpstr;
			}
		case 171:	/*GetSel*/
			if (oStr!=NULL)
			{
				int Row1=GetRow();
				int Row2=GetRowSel();
				int Col1=GetCol();
				int Col2=GetColSel();
				int i,j;
				if (Row1>Row2) {i=Row1;Row1=Row2;Row2=i;}
				if (Col1>Col2) {i=Col1;Col1=Col2;Col2=i;}
				sprintf(oStr,"%d\x7F%d\x7F%d\x7F%d\x7F",Row1,Col1,Row2,Col2);
				CString str;
				for(i=Row1;i<Row2;i++)
				{
					str="";
					for(j=Col1;j<Col2;j++)
						if (j==Col2-1)	str+=GetTextMatrix(i,j);
						else			str+=GetTextMatrix(i,j)+"\x7";
					strcat(oStr,str);
					if (i!=Row2)	strcat(oStr,"\x7F");
				}
			}
			break;
		case 170:	/*GetColorInfo*/
			if (oStr!=NULL)
			{
				UINT uBackColor		=GetBackColor();
				UINT uForeColor		=GetForeColor();
				UINT uBackColorFixed=GetBackColorFixed();
				UINT uForeColorFixed=GetForeColorFixed();
				UINT uBackColorSel	=GetBackColorSel();
				UINT uForeColorSel	=GetForeColorSel();
				UINT uBackColorBkg	=GetBackColorBkg();
				UINT uGridColor		=GetGridColor();
				UINT uGridColorFixed=GetGridColorFixed();
				UINT uCellBackColor	=GetCellBackColor();
				UINT uCellForeColor	=GetCellForeColor();

				sprintf(oStr,"%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F%d\x7%d\x7%d\x7F",
					GetRValue(uBackColor),GetGValue(uBackColor),GetBValue(uBackColor),
					GetRValue(uForeColor),GetGValue(uForeColor),GetBValue(uForeColor),
					GetRValue(uBackColorFixed),GetGValue(uBackColorFixed),GetBValue(uBackColorFixed),
					GetRValue(uForeColorFixed),GetGValue(uForeColorFixed),GetBValue(uForeColorFixed),
					GetRValue(uBackColorSel),GetGValue(uBackColorSel),GetBValue(uBackColorSel),
					GetRValue(uForeColorSel),GetGValue(uForeColorSel),GetBValue(uForeColorSel),
					GetRValue(uBackColorBkg),GetGValue(uBackColorBkg),GetBValue(uBackColorBkg),
					GetRValue(uGridColor),GetGValue(uGridColor),GetBValue(uGridColor),
					GetRValue(uGridColorFixed),GetGValue(uGridColorFixed),GetBValue(uGridColorFixed),
					GetRValue(uCellBackColor),GetGValue(uCellBackColor),GetBValue(uCellBackColor),
					GetRValue(uCellForeColor),GetGValue(uCellForeColor),GetBValue(uCellForeColor));
			}
			break;
		case 169:	/*GetPosInfo*/
			if (oStr!=NULL)
			{
				sprintf(oStr,"%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F",
				GetRows(),			GetCols(),
				GetFixedRows(),		GetFixedCols(),
				GetTopRow(),		GetLeftCol(),
				GetRow(),			GetCol(),
				GetRowSel(),		GetColSel(),
				GetMouseRow(),		GetMouseCol());
			}
			break;
		case   0:	/*GetRows*/				retint=GetRows();		break;
		case   1:	/*SetRows*/				SetRows(atoipos);		break;
		case   2:	/*GetCols*/				retint=GetCols();		break;
		case   3:	/*SetCols*/				SetCols(atoipos);		break;
		case   4:	/*GetFixedRows*/		retint=GetFixedRows();	break;
		case   5:	/*SetFixedRows*/		SetFixedRows(atoipos);break;
		case   6:	/*GetFixedCols*/		retint=GetFixedCols();	break;
		case   7:	/*SetFixedCols*/		SetFixedCols(atoipos);break;
		case   8:	/*GetVersion*/			retint=GetVersion();	break;
		case   9:	/*GetFormatString*/	
			if (oStr!=NULL)	strcpy(oStr,GetFormatString());
			break;
		case  10:	/*SetFormatString*/		SetFormatString(pos);	break;
		case  11:	/*GetTopRow*/			retint=GetTopRow();		break;
		case  12:	/*SetTopRow*/			SetTopRow(atoipos);	break;
		case  13:	/*GetLeftCol*/			retint=GetLeftCol();	break;
		case  14:	/*SetLeftCol*/			SetLeftCol(atoipos);	break;
		case  15:	/*GetRow*/				retint=GetRow();		break;
		case  16:	/*SetRow*/				SetRow(atoipos);		break;
		case  17:	/*GetCol*/				retint=GetCol();		break;
		case  18:	/*SetCol*/				SetCol(atoipos);		break;
		case  19:	/*GetRowSel*/			retint=GetRowSel();		break;
		case  20:	/*SetRowSel*/			SetRowSel(atoipos);	break;
		case  21:	/*GetColSel*/			retint=GetColSel();		break;
		case  22:	/*SetColSel*/			SetColSel(atoipos);	break;
		case  23:	/*GetText*/
			if (oStr!=NULL)	strcpy(oStr,(LPCTSTR)GetText());
			break;
		case  24:	/*SetText*/
			TranslateText(-1,-1,pos);
			break;
		case  25:	/*GetBackColor*/
		case  27:	/*GetForeColor*/	
		case  29:	/*GetBackColorFixed*/	
		case  31:	/*GetForeColorFixed*/
		case  33:	/*GetBackColorSel*/
		case  35:	/*GetForeColorSel*/
		case  37:	/*GetBackColorBkg*/
		case  87:	/*GetGridColor*/
		case  89:	/*GetGridColorFixed*/
		case  91:	/*GetCellBackColor*/
		case  93:	/*GetCellForeColor*/
			if (oStr!=NULL)
			{
				switch(nfunc)
				{
				case  25:	/*GetBackColor*/		retint= GetBackColor();			break;
				case  27:	/*GetForeColor*/		retint= GetForeColor();			break;
				case  29:	/*GetBackColorFixed*/	retint= GetBackColorFixed();	break;
				case  31:	/*GetForeColorFixed*/	retint= GetForeColorFixed();	break;
				case  33:	/*GetBackColorSel*/		retint= GetBackColorSel();		break;
				case  35:	/*GetForeColorSel*/		retint= GetForeColorSel();		break;
				case  37:	/*GetBackColorBkg*/		retint= GetBackColorBkg();		break;
				case  87:	/*GetGridColor*/		retint= GetGridColor();			break;
				case  89:	/*GetGridColorFixed*/	retint= GetGridColorFixed();	break;
				case  91:	/*GetCellBackColor*/	retint= GetCellBackColor();		break;
				case  93:	/*GetCellForeColor*/	retint= GetCellForeColor();		break;
				}
				sprintf(oStr,"%d\x07%d\x07%d",GetRValue(retint),GetGValue(retint),GetBValue(retint));
			}
			break;
		case  26:	/*SetBackColor*/
		case  28:	/*SetForeColor*/
		case  30:	/*SetBackColorFixed*/
		case  32:	/*SetForeColorFixed*/
		case  34:	/*SetBackColorSel*/
		case  36:	/*SetForeColorSel*/
		case  38:	/*SetBackColorBkg*/
		case  90:	/*SetGridColorFixed*/
		case  88:	/*SetGridColor*/
		case  92:	/*SetCellBackColor*/
		case  94:	/*SetCellForeColor*/
			{
				UINT r=0,g=0,b=0;
				m_LastScanf=sscanf(pos,"%d,%d,%d",&r,&g,&b);
				UINT nc=RGB(r,g,b);
				switch(nfunc)
				{
				case  26:	/*SetBackColor*/		SetBackColor(nc);		break;
				case  28:	/*SetForeColor*/		SetForeColor(nc);		break;
				case  30:	/*SetBackColorFixed*/	SetBackColorFixed(nc);	break;
				case  32:	/*SetForeColorFixed*/	SetForeColorFixed(nc);	break;
				case  34:	/*SetBackColorSel*/		SetBackColorSel(nc);	break;
				case  36:	/*SetForeColorSel*/		SetForeColorSel(nc);	break;
				case  38:	/*SetBackColorBkg*/		SetBackColorBkg(nc);	break;
				case  90:	/*SetGridColorFixed*/	SetGridColorFixed(nc);	break;
				case  88:	/*SetGridColor*/		SetGridColor(nc);		break;
				case  92:	/*SetCellBackColor*/	SetCellBackColor(nc);	break;
				case  94:	/*SetCellForeColor*/	SetCellForeColor(nc);	break;
				}
			}
			break;
		case  39:	/*GetWordWrap*/					retint=GetWordWrap();				break;
		case  40:	/*SetWordWrap*/					SetWordWrap(atoipos);				break;
		case  43:	/*GetFontWidth*/				if (oStr!=NULL)	sprintf(oStr,"%g",GetFontWidth());		break;
		case  44:	/*SetFontWidth*/				SetFontWidth((float)atof(pos));		break;
		case  45:	/*GetCellFontName*/				if (oStr!=NULL)	strcpy(oStr,GetCellFontName());			break;
		case  46:	/*SetCellFontName*/				SetCellFontName(pos);				break;
		case  47:	/*GetCellFontSize*/				if (oStr!=NULL)	sprintf(oStr,"%g",GetCellFontSize());	break;
		case  48:	/*SetCellFontSize*/				SetCellFontSize((float)atof(pos));	break;
		case  49:	/*GetCellFontBold*/				retint=GetCellFontBold();			break;
		case  50:	/*SetCellFontBold*/				SetCellFontBold(atoipos);			break;
		case  51:	/*GetCellFontItalic*/			retint=GetCellFontItalic();			break;
		case  52:	/*SetCellFontItalic*/			SetCellFontItalic(atoipos);			break;
		case  53:	/*GetCellFontUnderline*/		retint=GetCellFontUnderline();		break;
		case  54:	/*SetCellFontUnderline*/		SetCellFontUnderline(atoipos);		break;
		case  55:	/*GetCellFontStrikeThrough*/	retint=GetCellFontStrikeThrough();	break;
		case  56:	/*SetCellFontStrikeThrough*/	SetCellFontStrikeThrough(atoipos);	break;
		case  57:	/*GetCellFontWidth*/			if (oStr!=NULL)	sprintf(oStr,"%g",GetCellFontWidth());	break;
		case  58:	/*SetCellFontWidth*/			SetCellFontWidth((float)atof(pos));	break;
			//flexTextFlat 0 
			//flexTextRaised 1
			//flexTextInset 2
			//flexTextRaisedLight 3
			//flexTextInsetLight 4
		case  59:	/*GetTextStyle*/		retint=GetTextStyle();		break;
		case  60:	/*SetTextStyle*/		SetTextStyle(atoipos);		break;
		case  61:	/*GetTextStyleFixed*/	retint=GetTextStyleFixed();	break;
		case  62:	/*SetTextStyleFixed*/	SetTextStyleFixed(atoipos);	break;
		case  97:	/*GetCellTextStyle*/	retint=GetCellTextStyle();	break;
		case  98:	/*SetCellTextStyle*/	SetCellTextStyle(atoipos);	break;
			// BOOL
		case  63:	/*GetScrollTrack*/		retint=GetScrollTrack();	break;
		case  64:	/*SetScrollTrack*/		SetScrollTrack(atoipos);	break;
		case  69:	/*GetRedraw*/			retint=GetRedraw();			break;
		case  70:	/*SetRedraw*/			SetRedraw(atoipos);			break;
		case 108:	/*GetAllowBigSelection*/	retint=GetAllowBigSelection();	break;
		case 109:	/*SetAllowBigSelection*/	SetAllowBigSelection(atoipos);	break;
		case 161:	/*SetRightToLeft*/			SetRightToLeft(atoipos);		break;

		case 135:	/*GetMergeRow*/				retint=GetMergeRow(atoipos);	break;
		case 137:	/*GetMergeCol*/				retint=GetMergeCol(atoipos);	break;
		case 142:	/*GetColData*/				
			{
				retint=GetColData(atoipos);		
				if (retint) retint=((FGITEMDATA *)retint)->iValue;
			}
			break;
		case 140:	/*GetRowData*/
			{
				retint=GetRowData(atoipos);		
				if (retint) retint=((FGITEMDATA *)retint)->iValue;
			}
			break;
		case 160:	/*GetRightToLeft*/			retint=GetRightToLeft();		break;
		case 138:	/*SetMergeCol*/
		case 136:	/*SetMergeRow*/
		case 132:	/*SetColWidth*/
		case 134:	/*SetRowHeight*/
		case 139:	/*SetColPosition*/
			{
				const char *pos2=strchr(pos,',');
				while(pos2 && *(pos2++))
				{
					switch(nfunc)
					{
					case 132:	/*SetColWidth*/		SetColWidth(atoipos++,atoi(pos2));	break;
					case 134:	/*SetRowHeight*/	SetRowHeight(atoipos++,atoi(pos2));	break;
					case 138:	/*SetMergeCol*/		SetMergeCol(atoipos++,atoi(pos2));	break;
					case 136:	/*SetMergeRow*/		SetMergeRow(atoipos++,atoi(pos2));	break;
					case 139:	/*SetColPosition*/	SetColPosition(atoipos++,atoi(pos2));	break;
					}
					while((*pos2>='0' && *pos2<='9') || *pos2==' ') pos2++;
				}
			}
			break;
		case 141:	/*SetRowData*/
			{
				long n=0,va=0;
				m_LastScanf=sscanf(pos,"%d,%d",&n,&va);
				if (n>=0 && n<GetRows())
				{
					long rd=GetRowData(n);		
					if (rd)((FGITEMDATA *)rd)->iValue=va;
					else 
					{
						FGITEMDATA *fid=new FGITEMDATA;
						fid->iValue=va;
						fid->EditorId=0;
						fid->cdValue=0;
						fid->csValue="";
						SetRowData(n,(long)fid);
					}
				}
			}
			break;
		case 143:	/*SetColData*/
			{
				long n=0,va=0;
				m_LastScanf=sscanf(pos,"%d,%d",&n,&va);
				if (n>=0 && n<GetCols())
				{
					long rd=GetColData(n);		
					if (rd)((FGITEMDATA *)rd)->iValue=va;
					else 
					{
						FGITEMDATA *fid=new FGITEMDATA;
						fid->iValue=va;
						SetColData(n,(long)fid);
					}
				}
			}
			break;
			//flexFocusNone 0
			//flexFocusLight 1
			//flexFocusHeavy 2
		case  65:	/*GetFocusRect*/		retint=GetFocusRect();		break;
		case  66:	/*SetFocusRect*/		SetFocusRect(atoipos);		break;
			//flexHighlightNever 0
			//flexHighlightAlways 1
			//flexHighlightWithFocus 2
		case  67:	/*GetHighLight*/		retint=GetHighLight();		break;
		case  68:	/*SetHighLight*/		SetHighLight(atoipos);		break;
			//flexScrollNone 0
			//flexScrollHorizontal 1
			//flexScrollVertical 2
			//flexScrollBoth 3
		case  71:	/*GetScrollBars*/		retint=GetScrollBars();		break;
		case  72:	/*SetScrollBars*/		SetScrollBars(atoipos);		break;

		case  73:	/*GetMouseRow*/			retint=GetMouseRow();		break;
		case  74:	/*GetMouseCol*/			retint=GetMouseCol();		break;
			// twips
		case  75:	/*GetCellLeft*/	
		case  76:	/*GetCellTop*/		
		case  77:	/*GetCellWidth*/	
		case  78:	/*GetCellHeight*/	
		case  79:	/*GetRowHeightMin*/	
		case 131:	/*GetColWidth*/		
		case 133:	/*GetRowHeight*/	
		case 154:	/*GetRowPos*/		
		case 155:	/*GetColPos*/		
			{
				switch(nfunc)
				{
				case  75:	/*GetCellLeft*/		retint=GetCellLeft();	break;
				case  76:	/*GetCellTop*/		retint=GetCellTop();	break;
				case  77:	/*GetCellWidth*/	retint=GetCellWidth();	break;
				case  78:	/*GetCellHeight*/	retint=GetCellHeight();	break;
				case  79:	/*GetRowHeightMin*/	retint=GetRowHeightMin();	break;
				case 131:	/*GetColWidth*/		retint=GetColWidth(atoipos);	break;
				case 133:	/*GetRowHeight*/	retint=GetRowHeight(atoipos);	break;
				case 154:	/*GetRowPos*/		retint=GetRowPos(atoipos);	break;
				case 155:	/*GetColPos*/		retint=GetColPos(atoipos);	break;
				}
				
				if (referGPU!=NULL && referGPU[0]!=NULL)
				{
					CRect re(retint,retint,retint,retint);
					MapDialogRect(referGPU[0]->UnitHWND,&re);
					switch(nfunc)
					{
					case  75:	/*GetCellLeft*/		retint=re.left*64/1444;	break;
					case  76:	/*GetCellTop*/		retint=re.top*64/1444;	break;
					case  77:	/*GetCellWidth*/	retint=re.left*64/1444;	break;
					case  78:	/*GetCellHeight*/	retint=re.top*64/1444;	break;
					case  79:	/*GetRowHeightMin*/	retint=re.top*64/1444;	break;
					case 131:	/*GetColWidth*/		retint=re.left*64/1444;	break;
					case 133:	/*GetRowHeight*/	retint=re.top*64/1444;	break;
					case 154:	/*GetRowPos*/		retint=re.top*64/1444;	break;
					case 155:	/*GetColPos*/		retint=re.left*64/1444;	break;
					}
				}
			}
			break;
			//flexFillSingle 0
			//flexFillRepeat 1
		case  80:	/*SetRowHeightMin*/	SetRowHeightMin(atoipos);	break;
		case  81:	/*GetFillStyle*/	retint=GetFillStyle();	break;
		case  82:	/*SetFillStyle*/	SetFillStyle(atoipos);	break;
			//flexGridNone 0
			//flexGridFlat 1
			//flexGridInset 2
			//flexGridRaised 3
		case  83:	/*GetGridLines*/		retint=GetGridLines();		break;
		case  84:	/*SetGridLines*/		SetGridLines(atoipos);		break;
		case  85:	/*GetGridLinesFixed*/	retint=GetGridLinesFixed();	break;
		case  86:	/*SetGridLinesFixed*/	SetGridLinesFixed(atoipos);	break;
			//flexAlignLeftTop 0
			//flexAlignLeftCenter 1
			//flexAlignLeftBottom 2
			//flexAlignCenterTop 3
			//flexAlignCenterCenter 4
			//flexAlignCenterBottom 5
			//flexAlignRightTop 6
			//flexAlignRightCenter 7
			//flexAlignRightBottom 8
			//flexAlignGeneral 9
		case  95:	/*GetCellAlignment*/	retint=GetCellAlignment();	break;
		case  96:	/*SetCellAlignment*/	SetCellAlignment((short)atoipos);	break;
		case 129:	/*GetColAlignment*/		retint=GetColAlignment(atoipos);	break;
		case 130:	/*SetColAlignment*/
			{
				long n=0,va=0;
				m_LastScanf=sscanf(pos,"%d',%d",&n,&va);
				switch(nfunc)
				{
				case 130:	/*SetColAlignment*/	SetColAlignment(n,(short)va);	break;
				}
			}
			break;
			//flexAlignLeftTop 0
			//flexAlignLeftCenter 1
			//flexAlignLeftBottom 2
			//flexAlignCenterTop 3
			//flexAlignCenterCenter 4
			//flexAlignCenterBottom 5
			//flexAlignRightTop 6
			//flexAlignRightCenter 7
			//flexAlignRightBottom 8
		case  99:	/*GetCellPictureAlignment*/	retint=GetCellPictureAlignment();	break;
		case 100:	/*SetCellPictureAlignment*/	SetCellPictureAlignment((short)atoipos);	break;
			// TEXT
		case 101:	/*GetClip*/						if (oStr!=NULL)	strcpy(oStr,GetClip());	break;
		case 102:	/*SetClip*/						SetClip(pos);	break;
			//flexSortNone 0
			//flexSortGenericAscending 1
			//flexSortGenericDescending 2
			//flexSortNumericAscending 3
			//flexSortNumericDescending 4
			//flexSortStringNoCaseAsending 5
			//flexSortNoCaseDescending 6
			//flexSortStringAscending 7
			//flexSortStringDescending 8
			//flexSortCustom 9
		case 103:	/*SetSort*/
			m_sortType=atoipos;
			if (m_sortType<100) SetSort((short)m_sortType);
			else	
			{
				m_SortCol=GetCol();
				SetSort(9);
			}
			break;
			//flexSelectionFree 0
			//flexSelectionByRow 1
			//flexSelectionByColumn 2
		case 104:	/*GetSelectionMode*/	retint=GetSelectionMode();	break;
		case 105:	/*SetSelectionMode*/	SetSelectionMode(atoipos);	break;
			//flexMergeNever 0
			//flexMergeFree 1
			//flexMergeRestrictRows 2
			//flexMergeRestrictColumns 3
			//flexMergeRestrictBoth 4
		case 106:	/*GetMergeCells*/	retint=GetMergeCells();	break;
		case 107:	/*SetMergeCells*/	SetMergeCells(atoipos);	break;
			//flexResizeNone 0
			//flexResizeColumns 1
			//flexResizeRows 2
			//flexResizeBoth 3
		case 110:	/*GetAllowUserResizing*/	retint=GetAllowUserResizing();	break;
		case 111:	/*SetAllowUserResizing*/	SetAllowUserResizing(atoipos);	break;

		case 112:	/*GetBorderStyle*/	retint=GetBorderStyle();	break;
		case 113:	/*SetBorderStyle*/	SetBorderStyle(atoipos);	break;
		case 114:	/*GetEnabled*/		retint=GetEnabled();		break;
		case 115:	/*SetEnabled*/		SetEnabled(atoipos);		break;
		case 116:	/*GetAppearance*/	retint=GetAppearance();		break;
		case 117:	/*SetAppearance*/	SetAppearance(atoipos);		break;
		case 118:	/*GetMousePointer*/	retint=GetMousePointer();	break;
		case 119:	/*SetMousePointer*/	SetMousePointer(atoipos);	break;
			//flexPictureColor 0
			//flexPictureMonochrome 1
		case 122:	/*GetPictureType*/	retint=GetPictureType();	break;
		case 123:	/*SetPictureType*/	SetPictureType(atoipos);	break;

		case 127:	/*GetTextArray*/	if (oStr!=NULL)	strcpy(oStr,GetTextArray(atoipos));		break;
		case 128:	/*SetTextArray*/	
			{
				const char *pos2=strchr(pos,',');
				if (pos2++==NULL) pos2="";
				int nCols=GetCols();
				TranslateText(atoipos/nCols,atoipos%nCols,pos2);
			}
			break;
		case 144:	/*GetTextMatrix*/
			if (oStr!=NULL)
			{
				long x=0,y=0;
				m_LastScanf=sscanf(pos,"%d,%d",&x,&y);
				strcpy(oStr,GetTextMatrix(x,y));
			}
			break;
		case 145:	/*SetTextMatrix*/
			{
				long x=0,y=0;
				m_LastScanf=sscanf(pos,"%d,%d",&x,&y);
				const char *pos2=strchr(pos,',');
				if (pos2++==NULL) pos2="";
				pos2=strchr(pos2,',');
				if (pos2++==NULL) pos2="";
				TranslateText(y,x,pos2);
			}
			break;
		case 146:	/*AddItem*/
			{
				const char *pos2=strchr(pos,',');
				if (pos2++==NULL) pos2="";
				int nRow=GetRows();
				if (atoipos>nRow) atoipos=nRow;
				COleVariant nLines((long)atoipos,VT_I4);
				AddItem("",nLines);
				SetRow(atoipos);
				TranslateText(atoipos,0,pos2);
			}
			break;
		case 166:	/*AddItems*/
			{
				char *postmpcc=new char [(int)strlen(pos)+10];
				strcpy(postmpcc,pos);

				char *pos2=strchr(postmpcc,',');
				if (pos2++==NULL) pos2="";
				int nRow=GetRows();
				if (atoipos>nRow) atoipos=nRow;

				while(pos2!=NULL)
				{
					COleVariant nLines((long)atoipos,VT_I4);
					char *pos3=strchr(pos2,GPC.DelimiterIn1);
					if (pos3!=NULL) *(pos3++)=0;
					AddItem("",nLines);	
					TranslateText(atoipos++,0,pos2);
					pos2=pos3;
				}
				SetRow(--atoipos);
				delete[] postmpcc;
			}
			break;
		case 167:	/*AddItemEx*/
			{
				char *postmpcc=new char [(int)strlen(pos)+10];
				strcpy(postmpcc,pos);

				char *pos2=strchr(postmpcc,',');
				if (pos2++==NULL) pos2="";
				char *pos3=strchr(pos2,GPC.DelimiterIn1);
				if (pos3!=NULL) *(pos3++)=0;
				int nRow=GetRows();
				if (atoipos>nRow) atoipos=nRow;

				COleVariant nLines((long)atoipos,VT_I4);
				AddItem("",nLines);	
				SetRow(atoipos);
				TranslateText(atoipos,0,pos2);
				pos2=pos3;
				int nCol=GetCols();
				int col=0;
				while(pos2!=NULL && ++col<nCol)
				{
					SetCol(col);
					pos3=strchr(pos2,GPC.DelimiterIn1);
					if (pos3!=NULL) *(pos3++)=0;
					TranslateText(-1,-1,pos2);	
					pos2=pos3;
				}
				delete[] postmpcc;
			}
			break;
		case 168:	/*AddItemsEx*/
			{
				char *postmpcc=new char [(int)strlen(pos)+10];
				strcpy(postmpcc,pos);

				char *pos2=strchr(postmpcc,',');
				if (pos2++==NULL) pos2="";
				int nRow=GetRows();
				if (atoipos>nRow) atoipos=nRow;
				int nCol=GetCols();

				while(pos2!=NULL)
				{
					COleVariant nLines((long)atoipos,VT_I4);
					char *pos3=strchr(pos2,GPC.DelimiterIn1);
					if (pos3!=NULL) *(pos3++)=0;
					char *pos4=strchr(pos2,GPC.DelimiterIn2);
					if (pos4!=NULL) *(pos4++)=0;

					AddItem("",nLines);	
					SetRow(atoipos);
					TranslateText(atoipos++,0,pos2);

					int col=0;
					while((pos2=pos4)!=NULL && ++col<nCol)
					{
						SetCol(col);
						pos4=strchr(pos2,GPC.DelimiterIn2);
						if (pos4!=NULL) *(pos4++)=0;
						TranslateText(-1,-1,pos2);
					}
					pos2=pos3;
				}
				delete[] postmpcc;
			}
			break;
		case 147:	/*RemoveItem*/
			{
				const char *pos2=pos;
				while(pos2!=NULL && *pos2!=0)
				{
					RemoveItem(atoi(pos2));	
					pos2=strchr(pos2,',');
					if (pos2!=NULL) pos2++;
					else
					{
						pos2=strchr(pos2,',');
						if (pos2!=NULL) pos2++;
					}
				}
			}
			break;
		case 148:	/*Clear*/		Clear();				break;
		case 149:	/*Refresh*/		Refresh();				break;
		case 152:	/*GetRowIsVisible*/	retint=GetRowIsVisible(atoipos);	break;
		case 153:	/*GetColIsVisible*/	retint=GetColIsVisible(atoipos);	break;
		case 156:	/*GetGridLineWidth*/	retint=GetGridLineWidth();	break;
		case 157:	/*SetGridLineWidth*/	SetGridLineWidth((short)atoipos);	break;
			//flexAlignLeftTop 0
			//flexAlignLeftCenter 1
			//flexAlignLeftBottom 2
			//flexAlignCenterTop 3
			//flexAlignCenterCenter 4
			//flexAlignCenterBottom 5
			//flexAlignRightTop 6
			//flexAlignRightCenter 7
			//flexAlignRightBottom 8
		case 158:	/*GetFixedAlignment*/	retint=GetFixedAlignment(atoipos);	break;
		case 159:	/*SetFixedAlignment*/
			{
				long iIndex=0,y=0;
				m_LastScanf=sscanf(pos,"%d,%d",&iIndex,&y);
				SetFixedAlignment(iIndex,(short)y);
			}
			break;
		case 165:	/*SetRowPosition*/
			{
				long iIndex=0,y=0;
				m_LastScanf=sscanf(pos,"%d,%d",&iIndex,&y);
				SetRowPosition(iIndex,y);
			}
			break;
		case 162:	/*GetOLEDropMode*/	retint=GetOLEDropMode();	break;
		case 163:	/*SetOLEDropMode*/	SetOLEDropMode(atoipos);	break;
		case 164:	/*OLEDrag*/			OLEDrag();	break;
		case  42:	/*SetFont*/
			{
				GPCOleFont gpo;
				gpo.AttachDispatch(GetFont(),FALSE);
				gpo.SetFontFromString(pos);
				SetRefFont(gpo);	
				gpo.DetachDispatch();
			}
			break;
		case  41:	/*GetFont*/	if (oStr!=NULL) strcpy(oStr,GetFont().GetFontDescription());	break;
		case 121:	/*SetMouseIcon*/
		case 126:	/*SetCellPicture*/
			{
				char *pos333=new char [(int)strlen(pos)+2];
				strcpy(pos333,pos);
				char *pos2=pos333+(int)strlen(pos333);
				while(pos2!=pos333 && *pos2!='\\') pos2--;
				if (*pos2=='\\') *(pos2++)=0;
				

				IStorage* pStg = 0;
				HRESULT hr;
				hr = ::StgOpenStorage(CString(pos333==pos2?"":pos333).AllocSysString(), NULL, STGM_SHARE_EXCLUSIVE|STGM_READ, NULL, 0, &pStg);
				if (SUCCEEDED(hr))
				{
					IStream* pStream = 0;
					hr = pStg->OpenStream(CString(pos2).AllocSysString(), NULL, STGM_SHARE_EXCLUSIVE|STGM_READ, 0, &pStream);
					if (SUCCEEDED(hr))
					{
						IDispatch* pDispatch;
						hr = ::OleLoadPicture(pStream, 0, TRUE, IID_IDispatch,(void**)&pDispatch);
						if (SUCCEEDED(hr))
						{
							switch(nfunc)
							{
							case 121:	/*SetMouseIcon*/	SetRefMouseIcon(pDispatch);		break;
							case 126:	/*SetCellPicture*/	SetRefCellPicture(pDispatch);	break;
							}
							pDispatch->Release();
						}
						pStream->Release();
					}
					pStg->Release();
				}
				delete[] pos333;
			}
			break;
		case 213: /*GetListContents*/
		case 214: /*ClearRegion*/
			if (oStr!=NULL || nfunc==95)
			{
				char *pos333=new char [(int)strlen(pos)+2];
				strcpy(pos333,pos);
				int i,j,CurLen=0,nItem=GetRows();
				int nCol=GetCols();
				int Left,Right,Top,Bottom;
				Left=Right=Top=Bottom=-1;
				char *repltext=strchr(pos333,';');
				if (repltext++==NULL) repltext="";

				m_LastScanf=sscanf(pos333,"%d,%d,%d,%d",&Left,&Top,&Right,&Bottom);
				if (Left<0) Left=0;
				if (Right<Left || Right>nCol ) Right=nCol;
				if (Top<0) Top=0;
				if (Bottom<Top || Bottom>=nItem ) Bottom=nItem-1;

				for(i=Top;i<=Bottom;i++)
				{
					if (nfunc==213 && i!=Top) oStr[CurLen++]=127;
					for(j=Left;j<=Right;j++)
					{
						if (nfunc==213)
						{
							if (j!=Left) oStr[CurLen++]=7;
							CurLen+=sprintf(oStr+CurLen,"%s",(LPCSTR)GetTextMatrix(i,j));
							if (oStr[CurLen]!=0)
								oStr[CurLen]=0;
						}
						else	SetTextMatrix(i,j,repltext);
					}
				}
				delete[] pos333;
			}
			break;
		case 215: /*DeleteRow*/
			{
				int nRow=GetRows();
				if (atoipos>=GetFixedRows() && atoipos>=0 && atoipos<nRow)
				{
					SetRowPosition(atoipos,--nRow);
					SetRows(nRow);
				}
			}
			break;
		case 216: /*DeleteCol*/
			{
				int nCol=GetCols();
				if (atoipos>=GetFixedCols() && atoipos>=0 && atoipos<nCol)
				{
					SetColPosition(atoipos,--nCol);
					SetCols(nCol);
				}
			}
			break;
		case 217: /*DeleteRows*/
			{
				int nRow=GetRows();
				int nRowStart=0,nRowEnd=0;
				m_LastScanf=sscanf(pos,"%d,%d",&nRowStart,&nRowEnd);
				if (nRowStart<nRowEnd && nRowStart>=GetFixedRows() && nRowEnd<nRow)
				{
					int i;
					for(i=nRowEnd;i>=nRowStart;i--)
					{
						SetRowPosition(i,--nRow);
						SetRows(nRow);
					}
				}
			}
			break;
		case 218: /*DeleteCols*/
			{
				int nCol=GetCols();
				int nColStart=0,nColEnd=0;
				m_LastScanf=sscanf(pos,"%d,%d",&nColStart,&nColEnd);
				if (nColStart<nColEnd && nColStart>=GetFixedCols() && nColEnd<nCol)
				{
					int i;
					for(i=nColEnd;i>=nColStart;i--)
					{
						SetColPosition(i,--nCol);
						SetCols(nCol);
					}
				}
			}
			break;




		case 150:	/*GetDataSource*/	
		case 151:	/*SetDataSource*/	
		case 120:	/*GetMouseIcon*/	
		case 124:	/*GetPicture*/		
		case 125:	/*GetCellPicture*/	
			if (oStr!=NULL) strcpy(oStr,"method unsupported");
			break;
	#ifdef fffffjkj
		case 150:	/*GetDataSource*/	GetDataSource();	break;
		case 151:	/*SetDataSource*/	SetDataSource();	break;
		case 120:	/*GetMouseIcon*/	GetMouseIcon();		break;
		case 124:	/*GetPicture*/		GetPicture();		break;
		case 125:	/*GetCellPicture*/	GetCellPicture();	break;
	#endif

		default: if (oStr!=NULL)	sprintf(oStr,ErrObjSub,met);nfunc=0xFFFFFFFFL;break;
		}
	}catch(...)
	{
		char *str=new char [200+(int)strlen(pos)];
		#ifdef RUS
			sprintf(str,"Ошибка выполнения метода %s %s",met,pos);
			MessageBox(str,"Ошибка метода");
		#else
			sprintf(str,"Error execution of method %s %s",met,pos);
			MessageBox(str,"Error execution");
		#endif
		GPC.m_ErrReport.GPWriteErrorLog("GPCMSFlexGrid", "DoMethod",iStr);

		if (oStr!=NULL) strcpy(oStr,str);
		nfunc=0xFFFFFFFFL;
		delete[] str;
	}

	if (oStr!=NULL && *oStr==0 && retint!=-123456) sprintf(oStr,"%d",retint);
	return nfunc;
}

UINT GPCMSFlexGrid::GPSetProperty(char *iStr)
{
	char *iValue=new char [(int)strlen(iStr)+5];
	strcpy(iValue,iStr);
	UINT ret=1;
	char *pos=strchr(iValue,'=');

	if (pos!=NULL && m_hWnd)
	{
		char *prop[]={ "ADDSTYLE", "DELSTYLE","STYLE", };
		int propnum;
		*(pos++)=0;
		for(propnum=0;propnum<3 && strcmp(prop[propnum],iValue)!=0;propnum++); 
		if (propnum>=3) ret=2;
		else
		{
			ret=3;
			switch(propnum)
			{
			case 0: // ADDSTYLE
			case 1: // DELSTYLE
			case 2: // STYLE
				break;
			default: /* end */
				ret=2;
				break;
			}

		}
		*(--pos)='=';
	}

	delete[] iValue;
	return ret;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
long GPCMSFlexGrid::GetRows()
{
	long result;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetRows(long nNewValue)
{
	if (nNewValue>0)
	{
		long nRow=0;
		if (nNewValue<(nRow=GetRows()))
		{
			long i;
			for(i=nNewValue-1;i<nRow;i++)
			{
				long cdt=GetRowData(i);
				if (cdt!=NULL) 
				{
					delete(FGITEMDATA *) cdt;
					SetRowData(i,0);
				}
			}
		}
		static BYTE parms[] =		VTS_I4;
		InvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,	 nNewValue);
	}
}

long GPCMSFlexGrid::GetCols()
{
	long result;
	InvokeHelper(0x5, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCols(long nNewValue)
{
	if (nNewValue>0)
	{
		long nCol=0;
		if (nNewValue<(nCol=GetCols()))
		{
			long i;
			for(i=nNewValue-1;i<nCol;i++)
			{
				long cdt=GetColData(i);
				if (cdt!=NULL)
				{
					delete(FGITEMDATA *) cdt;
					SetColData(i,0);
				}
			}
		}
		static BYTE parms[] =	VTS_I4;
		InvokeHelper(0x5, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms, nNewValue);
	}
}

long GPCMSFlexGrid::GetFixedRows()
{
	long result;
	InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetFixedRows(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetFixedCols()
{
	long result;
	InvokeHelper(0x7, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetFixedCols(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x7, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short GPCMSFlexGrid::GetVersion()
{
	short result;
	InvokeHelper(0x1, DISPATCH_PROPERTYGET, VT_I2,(void*)&result, NULL);
	return result;
}

CString GPCMSFlexGrid::GetFormatString()
{
	CString result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_BSTR,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetFormatString(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long GPCMSFlexGrid::GetTopRow()
{
	long result;
	InvokeHelper(0x8, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetTopRow(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x8, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetLeftCol()
{
	long result;
	InvokeHelper(0x9, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetLeftCol(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x9, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetRow()
{
	long result;
	InvokeHelper(0xa, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetRow(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xa, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetCol()
{
	long result;
	InvokeHelper(0xb, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCol(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xb, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetRowSel()
{
	long result;
	InvokeHelper(0xc, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetRowSel(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xc, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetColSel()
{
	long result;
	InvokeHelper(0xd, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetColSel(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString GPCMSFlexGrid::GetText()
{
	CString result;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetText(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

unsigned long GPCMSFlexGrid::GetBackColor()
{
	unsigned long result;
	InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetBackColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long GPCMSFlexGrid::GetForeColor()
{
	unsigned long result;
	InvokeHelper(DISPID_FORECOLOR, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetForeColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_FORECOLOR, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long GPCMSFlexGrid::GetBackColorFixed()
{
	unsigned long result;
	InvokeHelper(0xe, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetBackColorFixed(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long GPCMSFlexGrid::GetForeColorFixed()
{
	unsigned long result;
	InvokeHelper(0xf, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetForeColorFixed(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long GPCMSFlexGrid::GetBackColorSel()
{
	unsigned long result;
	InvokeHelper(0x10, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetBackColorSel(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x10, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long GPCMSFlexGrid::GetForeColorSel()
{
	unsigned long result;
	InvokeHelper(0x11, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetForeColorSel(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long GPCMSFlexGrid::GetBackColorBkg()
{
	unsigned long result;
	InvokeHelper(0x12, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetBackColorBkg(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x12, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

BOOL GPCMSFlexGrid::GetWordWrap()
{
	BOOL result;
	InvokeHelper(0x13, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetWordWrap(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x13, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

GPCOleFont GPCMSFlexGrid::GetFont()
{
	LPDISPATCH pDispatch;
	InvokeHelper(DISPID_FONT, DISPATCH_PROPERTYGET, VT_DISPATCH,(void*)&pDispatch, NULL);
	return GPCOleFont(pDispatch);
}

void GPCMSFlexGrid::SetRefFont(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(DISPID_FONT, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,
		 newValue);
}

float GPCMSFlexGrid::GetFontWidth()
{
	float result;
	InvokeHelper(0x54, DISPATCH_PROPERTYGET, VT_R4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetFontWidth(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x54, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

CString GPCMSFlexGrid::GetCellFontName()
{
	CString result;
	InvokeHelper(0x4d, DISPATCH_PROPERTYGET, VT_BSTR,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellFontName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x4d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

float GPCMSFlexGrid::GetCellFontSize()
{
	float result;
	InvokeHelper(0x4e, DISPATCH_PROPERTYGET, VT_R4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellFontSize(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x4e, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

BOOL GPCMSFlexGrid::GetCellFontBold()
{
	BOOL result;
	InvokeHelper(0x4f, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellFontBold(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x4f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL GPCMSFlexGrid::GetCellFontItalic()
{
	BOOL result;
	InvokeHelper(0x50, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellFontItalic(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x50, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL GPCMSFlexGrid::GetCellFontUnderline()
{
	BOOL result;
	InvokeHelper(0x51, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellFontUnderline(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x51, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL GPCMSFlexGrid::GetCellFontStrikeThrough()
{
	BOOL result;
	InvokeHelper(0x52, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellFontStrikeThrough(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x52, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

float GPCMSFlexGrid::GetCellFontWidth()
{
	float result;
	InvokeHelper(0x53, DISPATCH_PROPERTYGET, VT_R4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellFontWidth(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x53, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

long GPCMSFlexGrid::GetTextStyle()
{
	long result;
	InvokeHelper(0x14, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetTextStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetTextStyleFixed()
{
	long result;
	InvokeHelper(0x15, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetTextStyleFixed(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL GPCMSFlexGrid::GetScrollTrack()
{
	BOOL result;
	InvokeHelper(0x16, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetScrollTrack(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x16, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long GPCMSFlexGrid::GetFocusRect()
{
	long result;
	InvokeHelper(0x17, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetFocusRect(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x17, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetHighLight()
{
	long result;
	InvokeHelper(0x18, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetHighLight(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL GPCMSFlexGrid::GetRedraw()
{
	BOOL result;
	InvokeHelper(0x19, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetRedraw(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x19, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long GPCMSFlexGrid::GetScrollBars()
{
	long result;
	InvokeHelper(0x1a, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetScrollBars(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetMouseRow()
{
	long result;
	InvokeHelper(0x1b, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

long GPCMSFlexGrid::GetMouseCol()
{
	long result;
	InvokeHelper(0x1c, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

long GPCMSFlexGrid::GetCellLeft()
{
	long result;
	InvokeHelper(0x1d, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

long GPCMSFlexGrid::GetCellTop()
{
	long result;
	InvokeHelper(0x1e, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

long GPCMSFlexGrid::GetCellWidth()
{
	long result;
	InvokeHelper(0x1f, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

long GPCMSFlexGrid::GetCellHeight()
{
	long result;
	InvokeHelper(0x20, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

long GPCMSFlexGrid::GetRowHeightMin()
{
	long result;
	InvokeHelper(0x21, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetRowHeightMin(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x21, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetFillStyle()
{
	long result;
	InvokeHelper(0xfffffe01, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetFillStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xfffffe01, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetGridLines()
{
	long result;
	InvokeHelper(0x22, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetGridLines(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x22, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetGridLinesFixed()
{
	long result;
	InvokeHelper(0x23, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetGridLinesFixed(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x23, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

unsigned long GPCMSFlexGrid::GetGridColor()
{
	unsigned long result;
	InvokeHelper(0x24, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetGridColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x24, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long GPCMSFlexGrid::GetGridColorFixed()
{
	unsigned long result;
	InvokeHelper(0x25, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetGridColorFixed(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x25, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long GPCMSFlexGrid::GetCellBackColor()
{
	unsigned long result;
	InvokeHelper(0x26, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellBackColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x26, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long GPCMSFlexGrid::GetCellForeColor()
{
	unsigned long result;
	InvokeHelper(0x27, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellForeColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x27, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

short GPCMSFlexGrid::GetCellAlignment()
{
	short result;
	InvokeHelper(0x28, DISPATCH_PROPERTYGET, VT_I2,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellAlignment(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x28, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetCellTextStyle()
{
	long result;
	InvokeHelper(0x29, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellTextStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x29, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short GPCMSFlexGrid::GetCellPictureAlignment()
{
	short result;
	InvokeHelper(0x2b, DISPATCH_PROPERTYGET, VT_I2,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetCellPictureAlignment(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x2b, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString GPCMSFlexGrid::GetClip()
{
	CString result;
	InvokeHelper(0x2d, DISPATCH_PROPERTYGET, VT_BSTR,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetClip(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x2d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

void GPCMSFlexGrid::SetSort(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x2e, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetSelectionMode()
{
	long result;
	InvokeHelper(0x2f, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetSelectionMode(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x2f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetMergeCells()
{
	long result;
	InvokeHelper(0x30, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetMergeCells(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x30, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL GPCMSFlexGrid::GetAllowBigSelection()
{
	BOOL result;
	InvokeHelper(0x33, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetAllowBigSelection(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x33, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long GPCMSFlexGrid::GetAllowUserResizing()
{
	long result;
	InvokeHelper(0x34, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetAllowUserResizing(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x34, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetBorderStyle()
{
	long result;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetBorderStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetHWnd()
{
	long result;
	InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

BOOL GPCMSFlexGrid::GetEnabled()
{
	BOOL result;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetEnabled(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long GPCMSFlexGrid::GetAppearance()
{
	long result;
	InvokeHelper(DISPID_APPEARANCE, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetAppearance(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_APPEARANCE, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long GPCMSFlexGrid::GetMousePointer()
{
	long result;
	InvokeHelper(0x35, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetMousePointer(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x35, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

GPCPicture GPCMSFlexGrid::GetMouseIcon()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x36, DISPATCH_PROPERTYGET, VT_DISPATCH,(void*)&pDispatch, NULL);
	return GPCPicture(pDispatch);
}

void GPCMSFlexGrid::SetRefMouseIcon(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x36, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,
		 newValue);
}

long GPCMSFlexGrid::GetPictureType()
{
	long result;
	InvokeHelper(0x32, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetPictureType(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x32, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

GPCPicture GPCMSFlexGrid::GetPicture()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x31, DISPATCH_PROPERTYGET, VT_DISPATCH,(void*)&pDispatch, NULL);
	return GPCPicture(pDispatch);
}

GPCPicture GPCMSFlexGrid::GetCellPicture()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x2a, DISPATCH_PROPERTYGET, VT_DISPATCH,(void*)&pDispatch, NULL);
	return GPCPicture(pDispatch);
}

void GPCMSFlexGrid::SetRefCellPicture(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x2a, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,
		 newValue);
}

CString GPCMSFlexGrid::GetTextArray(long index)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x37, DISPATCH_PROPERTYGET, VT_BSTR,(void*)&result, parms,
		index);
	return result;
}

void GPCMSFlexGrid::SetTextArray(long index, LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_BSTR;
	InvokeHelper(0x37, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, lpszNewValue);
}

short GPCMSFlexGrid::GetColAlignment(long index)
{
	short result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x38, DISPATCH_PROPERTYGET, VT_I2,(void*)&result, parms,
		index);
	return result;
}

void GPCMSFlexGrid::SetColAlignment(long index, short nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I2;
	InvokeHelper(0x38, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

long GPCMSFlexGrid::GetColWidth(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x39, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, parms,
		index);
	return result;
}

void GPCMSFlexGrid::SetColWidth(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x39, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

long GPCMSFlexGrid::GetRowHeight(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3a, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, parms,
		index);
	return result;
}

void GPCMSFlexGrid::SetRowHeight(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

BOOL GPCMSFlexGrid::GetMergeRow(long index)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3b, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, parms,
		index);
	return result;
}

void GPCMSFlexGrid::SetMergeRow(long index, BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_BOOL;
	InvokeHelper(0x3b, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, bNewValue);
}

BOOL GPCMSFlexGrid::GetMergeCol(long index)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3c, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, parms,
		index);
	return result;
}

void GPCMSFlexGrid::SetMergeCol(long index, BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_BOOL;
	InvokeHelper(0x3c, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, bNewValue);
}

void GPCMSFlexGrid::SetRowPosition(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

void GPCMSFlexGrid::SetColPosition(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3e, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

long GPCMSFlexGrid::GetRowData(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3f, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, parms,
		index);
	return result;
}

void GPCMSFlexGrid::SetRowData(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

long GPCMSFlexGrid::GetColData(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x40, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, parms,
		index);
	return result;
}

void GPCMSFlexGrid::SetColData(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x40, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

CString GPCMSFlexGrid::GetTextMatrix(long Row, long Col)
{
	CString result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x41, DISPATCH_PROPERTYGET, VT_BSTR,(void*)&result, parms,
		Row, Col);
	return result;
}

void GPCMSFlexGrid::SetTextMatrix(long Row, long Col, LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_BSTR;
	InvokeHelper(0x41, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 Row, Col, lpszNewValue);
}

void GPCMSFlexGrid::AddItem(LPCTSTR Item, const VARIANT& index)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x42, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Item, &index);
}

void GPCMSFlexGrid::RemoveItem(long index)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x43, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 index);
}

void GPCMSFlexGrid::Clear()
{
	InvokeHelper(0x44, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void GPCMSFlexGrid::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

GPCRowCursor GPCMSFlexGrid::GetDataSource()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x4c, DISPATCH_PROPERTYGET, VT_DISPATCH,(void*)&pDispatch, NULL);
	return GPCRowCursor(pDispatch);
}

void GPCMSFlexGrid::SetDataSource(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x4c, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

BOOL GPCMSFlexGrid::GetRowIsVisible(long index)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x55, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, parms,
		index);
	return result;
}

BOOL GPCMSFlexGrid::GetColIsVisible(long index)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x56, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, parms,
		index);
	return result;
}

long GPCMSFlexGrid::GetRowPos(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x57, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, parms,
		index);
	return result;
}

long GPCMSFlexGrid::GetColPos(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x58, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, parms,
		index);
	return result;
}

short GPCMSFlexGrid::GetGridLineWidth()
{
	short result;
	InvokeHelper(0x59, DISPATCH_PROPERTYGET, VT_I2,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetGridLineWidth(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x59, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short GPCMSFlexGrid::GetFixedAlignment(long index)
{
	short result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x5a, DISPATCH_PROPERTYGET, VT_I2,(void*)&result, parms,
		index);
	return result;
}

void GPCMSFlexGrid::SetFixedAlignment(long index, short nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I2;
	InvokeHelper(0x5a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

BOOL GPCMSFlexGrid::GetRightToLeft()
{
	BOOL result;
	InvokeHelper(0xfffffd9d, DISPATCH_PROPERTYGET, VT_BOOL,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetRightToLeft(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0xfffffd9d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long GPCMSFlexGrid::GetOLEDropMode()
{
	long result;
	InvokeHelper(0x60f, DISPATCH_PROPERTYGET, VT_I4,(void*)&result, NULL);
	return result;
}

void GPCMSFlexGrid::SetOLEDropMode(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x60f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

void GPCMSFlexGrid::OLEDrag()
{
	InvokeHelper(0x610, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void GPCMSFlexGrid::GPOnSizing(UINT fwSide, LPRECT pRect) 
{
	BOOL EnableSz=TRUE;
	UINT SizStyle=referGPU[UnitId&0xFFFF]->SizStyle;
	if ((SizStyle&0xFFFF)!=0)
	{
		CRect re;
		GetWindowRect(&re);
		switch(fwSide)
		{
		case WMSZ_BOTTOM:
			if ((SizStyle&GPUA_BOTTOM)!=GPUA_BOTTOM) EnableSz=FALSE;
			break;
		case WMSZ_BOTTOMLEFT:
			if ((SizStyle&GPUA_BOTTOM)!=GPUA_BOTTOM &&(SizStyle&GPUA_LEFT)!=GPUA_LEFT) EnableSz=FALSE;
			break;
		case WMSZ_BOTTOMRIGHT:
			if ((SizStyle&GPUA_BOTTOM)!=GPUA_BOTTOM &&(SizStyle&GPUA_RIGHT)!=GPUA_RIGHT) EnableSz=FALSE;
			break;
		case WMSZ_LEFT:
			if ((SizStyle&GPUA_LEFT)!=GPUA_LEFT) EnableSz=FALSE;
			break;
		case WMSZ_RIGHT:
			if ((SizStyle&GPUA_RIGHT)!=GPUA_RIGHT) EnableSz=FALSE;
			break;
		case WMSZ_TOP:
			if ((SizStyle&GPUA_TOP)!=GPUA_TOP) EnableSz=FALSE;
			break;
		case WMSZ_TOPLEFT:
			if ((SizStyle&GPUA_LEFT)!=GPUA_LEFT &&(SizStyle&GPUA_TOP)!=GPUA_TOP) EnableSz=FALSE;
			break;
		case WMSZ_TOPRIGHT:
			if ((SizStyle&GPUA_RIGHT)!=GPUA_RIGHT &&(SizStyle&GPUA_TOP)!=GPUA_TOP) EnableSz=FALSE;
			break;
		}
		if (EnableSz==FALSE)
		{
			pRect->top=re.top;
			pRect->left=re.left;
			pRect->right=re.right;
			pRect->bottom=re.bottom;
		}
		else
		{
			GetParent()->SendMessage(WM_SIZE);
		}
	}
	GetParent()->SendMessage(GPN_UPDATESIZE);
}

BOOL GPCMSFlexGrid::PreTranslateMessage(MSG* pMsg) 
{
	if (referGPU && referGPU[UnitId&0xFFFF])
	{
		referGPU[UnitId&0xFFFF]->m_CurPreMessage=pMsg;
		if (!referGPU[UnitId&0xFFFF]->DefPreTranslateMessage(pMsg)) return 0;
		if (referGPU[UnitId&0xFFFF]->GPMSG) 
		{
			UINT ret;
			if (pMsg->message!=WM_KEYDOWN || pMsg->wParam==VK_RETURN || pMsg->wParam==VK_TAB || pMsg->wParam==VK_CANCEL || pMsg->wParam==VK_ESCAPE || pMsg->wParam==VK_HELP)
			{
				if ((ret=referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjMessage(m_hWnd, UnitId, pMsg->message, pMsg->wParam, pMsg->lParam))>0) return ret;
				if (pMsg->message==WM_KEYDOWN && referGPU!=NULL && referGPU[UnitId&0xFFFF]->UnitHotkey && this->m_hWnd!=NULL && IsWindowEnabled()==TRUE && IsWindowVisible()==TRUE)
						if ((ret=referGPU[UnitId&0xFFFF]->UnitHotkey->SendHotkeyMessage(pMsg->message, pMsg->wParam,pMsg->lParam))>0) return ret;
			}
		}
	}	
	if (pMsg->message==WM_KEYDOWN &&(m_EditInProgr&0x1)!=0 && hti.y!=-1 && hti.x!=-1)
	{
		if (pMsg->wParam==13) PostMessage(GPM_NEXTCELL,0,0);
		else
		if (pMsg->wParam==27) PostMessage(GPM_ESCCELL,0,0);
		else
		if (pMsg->wParam==46 && /*pMsg->lParam==0x09530001 &&*/(m_EditInProgr&32)!=0 && EditorID!=0 && referGPU!=NULL && referGPU[EditorID]!=NULL && pMsg->hwnd==m_hWnd) 
		{
			PostMessage(GPM_ESCCELL,0,0);
			PostMessage(GPM_NEXTCELL,0,0);
			PostMessage(GPM_DELCELL,hti.y+hti.x*0x10000,0);
			SetTextMatrix(hti.y,hti.x,"");
			char str[50];
			sprintf(str,"%d\x7F%d",hti.y,hti.x);
			referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnClearSubItem",str);
		}

	}

	if (pMsg->message==GPM_DELCELL)
	{
		SetTextMatrix(pMsg->wParam&0xFFFF,pMsg->wParam/0x10000,"");
	}

	switch(pMsg->message)
	{
	case WM_SIZING:			GPOnSizing(pMsg->wParam,(LPRECT)pMsg->lParam);			break;
	case WM_PAINT:
		if (m_Sink==NULL)
		{
			ConnectSink();
		}
		break;
	case WM_KILLFOCUS: 		OnGPKillFocus(CWnd::FromHandle((HWND)pMsg->wParam));	break;
	case WM_RBUTTONDOWN:	
		break;
	}

	BOOL ret=CWnd::PreTranslateMessage(pMsg);

	WindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);

	return ret;
}

void GPCMSFlexGrid::ConnectSink()
{
	if (m_Sink==NULL)
	{
		m_Sink = new CMSFlexGridSink();
		m_Sink->SetGPMSFlex((void *)this);
		LPDISPATCH pUnkSink = m_Sink->GetIDispatch(FALSE);

		IConnectionPointContainer* pCPC = 0;
		IID iid;
		m_pCtrlSite->GetEventIID(&iid);
		HRESULT hr = GetControlUnknown( )/*m_pCtrlSite->m_pObject*/->QueryInterface(IID_IConnectionPointContainer,(void **)&pCPC);
		if (SUCCEEDED(hr))
		{
			hr=pCPC->FindConnectionPoint(iid,&pCP);
			if (SUCCEEDED(hr))
			{
				LPUNKNOWN punk;
				hr=pUnkSink->QueryInterface(IID_IUnknown,(void **)&punk);
				if (SUCCEEDED(hr))
					pCP->Advise(punk,&m_dwCookie );
			}
			pCPC->Release();
		}
	}
}

void GPCMSFlexGrid::OnClickMsflexgrid() 
{
	if (referGPU!=NULL)	
	{
		char str[300];
		POINT mPoint;
		GetCursorPos(&mPoint);
		ScreenToClient(&mPoint);
		int nCol=GetMouseCol();
		int nRow=GetMouseRow();

		sprintf(str,"%d\x7F%d\x7F%d\x7F%d\x7F",nCol,nRow,mPoint.x,mPoint.y);

		if ((m_uLastMouseUpFlag&MK_MBUTTON))		strcat(str,"MK_MBUTTON|");
		if ((m_uLastMouseUpFlag&MK_LBUTTON))		strcat(str,"MK_LBUTTON|");
		if ((m_uLastMouseUpFlag&MK_RBUTTON))		strcat(str,"MK_RBUTTON|");
		if ((m_uLastMouseUpFlag&MK_SHIFT))			strcat(str,"MK_SHIFT|");
		if ((m_uLastMouseUpFlag&MK_CONTROL))		strcat(str,"MK_CONTROL|");
		if ((m_uLastMouseUpFlag&MK_XBUTTON1))		strcat(str,"MK_XBUTTON1|");
		if ((m_uLastMouseUpFlag&MK_XBUTTON2))		strcat(str,"MK_XBUTTON2|");
		if ((GetAsyncKeyState(VK_MENU)&0xFF00)!=0)	strcat(str,"MK_MENU");

		if (GetFixedRows()>nRow)
			referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnColumnClick",str);

		if (GetFixedCols()>nCol)
			referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnRowClick",str);

		if (GetFixedCols()<=nCol && GetFixedRows()<=nRow)
			referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGClick",str);
	}

	if ((m_EditInProgr&0x1)!=0)
	{
		hti.y=GetRow();
		hti.x=GetCol();
		CRect re=GetCellRect(hti.y,hti.x);
		SetEditRect();
		InvalidateRect(&re);
		SetSelByEdit();
	}
}

void GPCMSFlexGrid::OnKeyDownMsflexgrid(short FAR* KeyCode, short Shift) 
{
	if (referGPU!=NULL)	
	{
		char str[200];
		sprintf(str,"%d\x7F%d\x7F%d\x7F%d",(int)(*KeyCode),(int)Shift,GetCol(),GetRow());
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGKeyDown",str);
	}
}

void GPCMSFlexGrid::OnDblClickMsflexgrid() 
{
	if (referGPU!=NULL)	
	{
		char str[200];
		POINT mPoint;
		GetCursorPos(&mPoint);
		ScreenToClient(&mPoint);
		sprintf(str,"%d\x7F%d\x7F%d\x7F%d",GetMouseCol(),GetMouseRow(),mPoint.x,mPoint.y);
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGDblClick",str);
	}
}


void GPCMSFlexGrid::OnKeyPressMsflexgrid(short FAR* KeyAscii) 
{
	if (referGPU!=NULL)	
	{
		char str[200];
		sprintf(str,"%d\x7F%d\x7F%d",(int)(*KeyAscii),GetCol(),GetRow());
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGKeyPress",str);
	}
}

void GPCMSFlexGrid::OnKeyUpMsflexgrid(short FAR* KeyCode, short Shift) 
{
	if (referGPU!=NULL)	
	{
		char str[200];
		sprintf(str,"%d\x7F%d\x7F%d\x7F%d",(int)(*KeyCode),(int)Shift,GetCol(),GetRow());
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGKeyUp",str);
	}
}

void GPCMSFlexGrid::OnMouseDownMsflexgrid(short Button, short Shift, long x, long y) 
{
	if (referGPU!=NULL)	
	{
		char str[200];
		sprintf(str,"%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d",(int)Button,(int)Shift,GetMouseCol(),GetMouseRow(),x,y);
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGMouseDown",str);
	}
}

void GPCMSFlexGrid::OnMouseMoveMsflexgrid(short Button, short Shift, long x, long y) 
{
	if (referGPU!=NULL && referGPU[UnitId&0xFFFF]->GPMSG->FindInActive("OnFGMouseMove"))	
	{
		char str[200];
		sprintf(str,"%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d",(int)Button,(int)Shift,GetMouseCol(),GetMouseRow(),x,y);
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGMouseMove",str);
	}
}

void GPCMSFlexGrid::OnMouseUpMsflexgrid(short Button, short Shift, long x, long y) 
{
	if (referGPU!=NULL)	
	{
		char str[200];
		sprintf(str,"%d\x7F%d\x7F%d\x7F%d\x7F%d\x7F%d",(int)Button,(int)Shift,GetMouseCol(),GetMouseRow(),x,y);
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGMouseUp",str);
	}
}

void GPCMSFlexGrid::OnSelChangeMsflexgrid() 
{
	if (referGPU!=NULL)	
	{
		char str[200];
		sprintf(str,"%d\x7F%d\x7F%d\x7F%d",GetRow(),GetCol(),GetRowSel(),GetColSel());
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGSelChange",str);
	}
}

void GPCMSFlexGrid::OnRowColChangeMsflexgrid() 
{
	if (referGPU!=NULL)	
	{
		char str[200];
		sprintf(str,"%d\x7F%d\x7F%d\x7F%d",GetRow(),GetCol(),GetRowSel(),GetColSel());
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGRowColChange",str);
	}
}

void GPCMSFlexGrid::OnEnterCellMsflexgrid() 
{
	if (referGPU!=NULL)	
	{
		CString str;
		str.Format("%d\x7F%d\x7F%s",GetRow(),GetCol(),(LPCSTR)GetText());
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGEnterCell",str);
	}
}

void GPCMSFlexGrid::OnLeaveCellMsflexgrid() 
{
	if (referGPU!=NULL)	
	{
		CString str;
		str.Format("%d\x7F%d\x7F%s",GetRow(),GetCol(),(LPCSTR)GetText());
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGLeaveCell",str);
	}
}

void GPCMSFlexGrid::OnScrollMsflexgrid() 
{
	if (referGPU!=NULL)	
	{
		char str[200];
		sprintf(str,"%d\x7F%d\x7F%d\x7F%d",GetTopRow(),GetLeftCol(),GetRow(),GetCol());
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGScroll",str);
	}
}

void GPCMSFlexGrid::OnCompareMsflexgrid(long Row1, long Row2, short FAR* Cmp) 
{
	switch(m_sortType)
	{
	case 100: //DateAsc
	case 101: //DateDesc
		{
			BOOL bpt1=Cmpd1.ParseDateTime(GetTextMatrix(Row1,m_SortCol));
			BOOL bpt2=Cmpd2.ParseDateTime(GetTextMatrix(Row2,m_SortCol));
			if (bpt1==FALSE && bpt2==FALSE) *Cmp=(short)_stricmp(GetTextMatrix(Row1,m_SortCol),GetTextMatrix(Row2,m_SortCol));
			else
				if (bpt1==FALSE) *Cmp=1;
				else
					if (bpt2==FALSE) *Cmp=-1;
					else
					{
						if (Cmpd1>Cmpd2) *Cmp=1;
						else if (Cmpd1<Cmpd2) *Cmp=-1;
					}
			if (m_sortType==101) *Cmp=(short)-*Cmp;
		}
		break;
	}



}

void GPCMSFlexGrid::OnOLEStartDragMsflexgrid(LPDISPATCH FAR* Data, long FAR* AllowedEffects) 
{
	if (referGPU!=NULL)	
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGOLEStartDrag","");
}

void GPCMSFlexGrid::OnOLEGiveFeedbackMsflexgrid(long FAR* Effect, BOOL FAR* DefaultCursors) 
{
	if (referGPU!=NULL)	
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGOLEGiveFeedback","");
}

void GPCMSFlexGrid::OnOLESetDataMsflexgrid(LPDISPATCH FAR* Data, short FAR* DataFormat) 
{
	if (referGPU!=NULL)	
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGOLESetData","");
}

void GPCMSFlexGrid::OnOLECompleteDragMsflexgrid(long FAR* Effect) 
{
	if (referGPU!=NULL)	
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGOLECompleteDrag","");
}

void GPCMSFlexGrid::OnOLEDragOverMsflexgrid(LPDISPATCH FAR* Data, long FAR* Effect, short FAR* Button, short FAR* Shift, float FAR* x, float FAR* y, short FAR* State) 
{
	if (referGPU!=NULL)	
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGOLEDragOver","");
}

void GPCMSFlexGrid::OnOLEDragDropMsflexgrid(LPDISPATCH FAR* Data, long FAR* Effect, short FAR* Button, short FAR* Shift, float FAR* x, float FAR* y) 
{
	if (referGPU!=NULL)	
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnFGOLEDragDrop","");
}

int GPCMSFlexGrid::FindItem(FGFINDITEM & FindItemStruct)
{
	m_fgFindItem=FindItemStruct;
	return FindNextItem();
}

int GPCMSFlexGrid::FindNextItem()
{
	int ret = -1;
	CString tmps;
	do
	{
		if (m_fgFindItem.bbyRow)
		{
			if (m_fgFindItem.bForward) 
			{
				if (++m_fgFindItem.iCurentCol>m_fgFindItem.iEndCol)
				{m_fgFindItem.iCurentRow++;m_fgFindItem.iCurentCol=m_fgFindItem.iStartCol;}
				if (m_fgFindItem.iCurentRow>m_fgFindItem.iEndRow) break;
			}
			else  
			{
				if (--m_fgFindItem.iCurentCol<m_fgFindItem.iStartCol)
				{m_fgFindItem.iCurentRow--;m_fgFindItem.iCurentCol=m_fgFindItem.iEndCol;}
				if (m_fgFindItem.iCurentRow<m_fgFindItem.iStartRow) break;
			}
		}
		else
		{
			if (m_fgFindItem.bForward) 
			{
				if (++m_fgFindItem.iCurentCol>m_fgFindItem.iEndCol)
				{m_fgFindItem.iCurentRow++;m_fgFindItem.iCurentCol=m_fgFindItem.iStartCol;}
				if (m_fgFindItem.iCurentRow>m_fgFindItem.iEndRow) break;
			}
			else  
			{
				if (--m_fgFindItem.iCurentCol<m_fgFindItem.iStartCol)
				{m_fgFindItem.iCurentRow--;m_fgFindItem.iCurentCol=m_fgFindItem.iEndCol;}
				if (m_fgFindItem.iCurentRow<m_fgFindItem.iStartRow) break;
			}
		}
		tmps=GetTextMatrix(m_fgFindItem.iCurentRow,m_fgFindItem.iCurentCol);
		BOOL IsFind=m_fgFindItem.bExactly?m_fgFindItem.csFindWhat==tmps:tmps.Find(m_fgFindItem.csFindWhat,0)>=0;
		if (IsFind)
		{
			ret=GetCols()*m_fgFindItem.iCurentRow+m_fgFindItem.iCurentCol;
			if (m_fgFindItem.bReplaceFull) TranslateText(m_fgFindItem.iCurentRow,m_fgFindItem.iCurentCol,m_fgFindItem.csReplace);
			else
				if (m_fgFindItem.bReplace)
				{
					tmps.Replace(m_fgFindItem.csFindWhat,m_fgFindItem.csReplace);
					TranslateText(m_fgFindItem.iCurentRow,m_fgFindItem.iCurentCol,tmps);
				}
			break;
		}
	}while(1);


	return ret;
}

int GPCMSFlexGrid::FindReplaceAllItem(FGFINDITEM & FindItemStruct)
{
	m_fgFindItem=FindItemStruct;
	int ret=0;
	while(FindNextItem()>=0) ret++;
	return ret;
}

void GPCMSFlexGrid::TranslateText(long iDestRow, long iDestCol, const char *ccpos)
{
	char *posbuff=new char [(int)strlen(ccpos)+100];
	strcpy(posbuff,ccpos);
	char *pos111=posbuff;
	char *pos2;
	BOOL bReloc=FALSE;
	long RelocCol=-1,RelocRow=-1;

	while((pos2=strchr(pos111,'&'))!=NULL)
	{
		BOOL bCopyNext=FALSE;
		char *nextpos=strchr(pos2,';');
		if (!bReloc)
		{
			bReloc=TRUE;
			if (iDestRow>=0 && iDestCol>=0)
			{
				RelocCol=GetRow();
				RelocCol=GetCol();
				if (RelocCol!=iDestCol) SetCol(iDestCol);
				if (RelocRow!=iDestRow) SetRow(iDestRow);
			}
		}

		switch(*(++pos2))
		{
		case 'F': // FONT
			if (pos2[2]=='=')
				switch(pos2[1])
				{
				case 'U': // UNDERLINE
					SetCellFontUnderline(atoi(pos2+3));
					bCopyNext=TRUE;
					break;
				case 'B': // BOLD
					SetCellFontBold(atoi(pos2+3));
					bCopyNext=TRUE;
					break;
				case 'I': // ITALIC
					SetCellFontItalic(atoi(pos2+3));
					bCopyNext=TRUE;
					break;
				case 'N': // NAME
					if (nextpos) *nextpos=0;
					SetCellFontName(pos2+3);
					if (nextpos) *nextpos=';';
					bCopyNext=TRUE;	
					break;
				case 'S': // SIZE
					SetCellFontSize((float)atof(pos2+3));
					bCopyNext=TRUE;
					break;
				case 'W': // WIDTH
					SetCellFontWidth((float)atof(pos2+3));
					bCopyNext=TRUE;
					break;
				case 'T': // STRIKE
					SetCellFontStrikeThrough(atoi(pos2+3));
					bCopyNext=TRUE;
					break;
				}
			break;
		case 'C': // COLOR
			if (pos2[2]=='=' &&(pos2[1]=='F' || pos2[1]=='B'))
			{
				int r=0,g=0,b=0;
				m_LastScanf=sscanf(pos2+3,"%d,%d,%d",&r,&g,&b);
				if (pos2[1]=='F')	SetCellForeColor(RGB(r,g,b));
				else				SetCellBackColor(RGB(r,g,b));
				bCopyNext=TRUE;
			}
			break;
		case 'A': // ALIGNMENT
			if (pos2[1]=='=')
			{
				SetCellAlignment((short)atoi(pos2+2));
				bCopyNext=TRUE;
			}
			break;
		case 'P': // PICTURE
			if (pos2[1]=='=')
			{
				SetCellPictureAlignment((short)atoi(pos2+2));
				bCopyNext=TRUE;
			}
			break;
		case 'S': // TEXTSTYLE
			if (pos2[1]=='=')
			{
				SetCellTextStyle(atoi(pos2+2));
				bCopyNext=TRUE;
			}
			break;
		}
		if (bCopyNext)
		{
			if (nextpos) strcpy(--pos2,++nextpos);
			else *(--pos2)=0;
		}
		pos111=pos2;
	}

	if (!bReloc)
	{
		if (iDestRow>=0 && iDestCol>=0) SetTextMatrix(iDestRow,iDestCol,posbuff);
		else SetText(posbuff);
	}
	else SetText(posbuff);

	if (bReloc && iDestRow>=0 && iDestCol>=0)
	{
		if (RelocCol!=iDestCol) SetCol(RelocCol);
		if (RelocRow!=iDestRow) SetRow(RelocRow);
	}
	delete[] posbuff;
}

void GPCMSFlexGrid::OnGPRButtonDown(UINT nFlags, CPoint point)
{
	RBhti.y=GetMouseRow();
	RBhti.x=GetMouseCol();

	if ((m_EditInProgr&0x1)!=0 && nFlags==MK_RBUTTON)
	{
		CRect re=GetCellRect(RBhti.y,RBhti.x);
		SetEditRect();
		InvalidateRect(&re);
		SetSelByEdit();
	}
}


void GPCMSFlexGrid::OnGPKillFocus(CWnd* pNewWnd) 
{
	MayBeChangeEdit=TRUE;
}


BOOL GPCMSFlexGrid::EnsureVisible(long iRow, long iCol)
{
	int nRow=GetRows();
	int nCol=GetCols();
	BOOL ret=FALSE;

	if (iRow<nRow && iCol<nCol)
	{
		int lcol=GetLeftCol();
		if (lcol>iCol)
			while(GetColIsVisible(iCol)==0 && lcol>1)
				{SetLeftCol(--lcol);ret=TRUE;}
		else
			while(iCol>lcol && GetColIsVisible(iCol)==0 && lcol>0)
				{SetLeftCol(++lcol);ret=TRUE;}


		int lRow=GetTopRow();
		if (lRow>iRow)
			while(GetRowIsVisible(iRow)==0 && lRow>1)
				{SetTopRow(--lRow);ret=TRUE;}
		else
			while(iRow>lRow && GetRowIsVisible(iRow)==0 && lRow>0)
				{SetTopRow(++lRow);ret=TRUE;}
	}
	return ret;
}

bool GPCMSFlexGrid::SetEditRect()
{
	if ((m_EditInProgr&0x1)!=0 && hti.x>=0 && hti.y>=0 && referGPU!=NULL)
	{
		UINT EdID=GetEditorID(hti.y,hti.x);

		CRect re,re2;
		GetWindowRect(&re2);

		if (EditorID!=0 && referGPU[EditorID]!=NULL && referGPU[EditorID]!=NULL && referGPU[EditorID]->UnitHWND!=NULL)
		{
			::GetWindowRect(referGPU[EditorID]->UnitHWND,&re);
		}

		if (EditorID!=(UnitId&0xFFFF)  && EditorID!=0 && EditorID!=EdID && referGPU[EditorID]!=NULL && referGPU[EditorID]!=NULL && referGPU[EditorID]->UnitHWND!=NULL)
			::SetWindowLong(referGPU[EditorID]->UnitHWND,GWL_STYLE,::GetWindowLong(referGPU[EditorID]->UnitHWND,GWL_STYLE)&(0xFFFFFFFF^WS_VISIBLE));

		re.top-=10;	re.left-=10;
		re.bottom+=10;	re.right+=10;
		re.OffsetRect(-re2.TopLeft());
//		InvalidateRect(re);
		Invalidate(FALSE);

		if (EdID!=(UnitId&0xFFFF) && EditorID!=EdID && referGPU[EdID]!=NULL && referGPU[EdID]->UnitHWND!=NULL)
		{
			LastEditorID=EditorID;
			EditorID=EdID;
			::SetWindowLong(referGPU[EditorID]->UnitHWND,GWL_STYLE,::GetWindowLong(referGPU[EditorID]->UnitHWND,GWL_STYLE)|WS_VISIBLE);
			::GetWindowRect(referGPU[EditorID]->UnitHWND,&re);
			re.top-=3;	re.left-=3;
			re.OffsetRect(-re2.TopLeft());
			CWnd::FromHandle(referGPU[EditorID]->UnitHWND)->Invalidate(FALSE);
			Invalidate(FALSE);
//			InvalidateRect(re);
		}
		else
		if (referGPU[EdID]==NULL || referGPU[EdID]->UnitHWND==NULL)
		{
			LastEditorID=EditorID;
			EditorID=0;
		}

		SetRow(hti.y);
		SetCol(hti.x);
		re=GetCellRect(hti.y,hti.x);
		re.top-=3;

		if (EditorID!=0 && EditorID!=(UnitId&0xFFFF))
		{
			CWnd::FromHandle(referGPU[EditorID]->UnitHWND)->MoveWindow(re,FALSE);
			re.top-=6;	re.left-=6;
			re.bottom+=6;	re.right+=6;
			Invalidate(FALSE);
//			InvalidateRect(re);
//			CWnd::FromHandle(referGPU[EditorID]->UnitHWND)->Invalidate();
		}
	}
	return TRUE;
}


void GPCMSFlexGrid::SetSelByEdit(UINT flg)
{
	if ((m_EditInProgr&0x1)!=0)
	{
		if ((lasthti.y!=hti.y || lasthti.x!=hti.x || flg!=0) && referGPU!=NULL)
		{
			CString str;
			str.Format("%d\x7F%d\x7F%d\x7F%d",lasthti.y,lasthti.x,hti.y,hti.x);
			referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnEditPos",(LPCSTR)str);
		}

		if ((lasthti.y!=hti.y || lasthti.x!=hti.x || flg!=0) && referGPU!=NULL)
		{
			char *oStr=new char [10000];
			referGPU[LastEditorID]->DoWindowMethod("GetWindowText",oStr);
			LastEditResult=oStr;
			delete[] oStr;
			CString str;
			CString Oldstr;
			if (AutoUpdate==TRUE && referGPU[LastEditorID]!=NULL && referGPU[LastEditorID]->UnitHWND!=NULL && lasthti.y>=0 && lasthti.x>=0)
				Oldstr=GetTextMatrix(lasthti.y,lasthti.x);
			if (AutoUpdate==TRUE &&((lasthti.y>=0 && lasthti.x>=0  && LastEditorID!=0 && MayBeChangeEdit==TRUE) || flg!=0) && referGPU[LastEditorID]!=NULL && referGPU[LastEditorID]->UnitHWND!=NULL)
	//		&& referGPU[LastEditorID]!=NULL && referGPU[LastEditorID]->UnitHWND!=NULL && LastEditorID!=0 && LastEditorID!=UnitId)
			{
				if (Oldstr!=LastEditResult) 
				{
					Oldstr=LastEditResult;
					SetTextMatrix(lasthti.y,lasthti.x,(LPCSTR)LastEditResult);
				}
			}
		
			MayBeChangeEdit=FALSE;
			str.Format("%d\x7F%d\x7F%d\x7F%d\x7F",lasthti.y,lasthti.x,hti.y,hti.x);
			str+=Oldstr+"\x7F";
			str+=GetTextMatrix(hti.y,hti.x)+"\x7F";
			int i;
			for(i=0;i<50;i++)
			{
				if (iArrPosExOut[i]>=0)
					str+=GetTextMatrix(lasthti.y,iArrPosExOut[i])+"\x7F";
			}

			referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnEditPosEx",(LPCSTR)str);
			lasthti=hti;
			LastEditorID=EditorID;
		}
		SetRow(hti.y);
		SetCol(hti.x);
		if (EditorID!=0 && EditorID!=UnitId && referGPU!=NULL && referGPU[EditorID]!=NULL && hti.y!=-1 && hti.x!=-1)
		{
			referGPU[EditorID]->GPSetProperty("VISIBLE=TRUE");
			CString str("TEXT=");
			str+=GetTextMatrix(hti.y, hti.x );
			referGPU[EditorID]->GPSetProperty((LPCSTR)str);
		}
	}
}

const CRect GPCMSFlexGrid::GetCellRect(int iRow, int iCol)
{
	CRect re(0,0,0,0);
	if (iRow>=0 && iCol>=0 && iRow<GetRows() && iCol<GetCols())
	{
		int OldRow=GetRow(),OldCol=GetCol();
		if (OldRow!=iRow) SetRow(iRow);
		if (OldCol!=iCol) SetRow(iCol);
		CRect rec;
		GetClientRect(&rec);

		re.left=GetCellLeft();
		re.top=GetCellTop();
		re.right=re.left+GetCellWidth();
		re.bottom=re.top+GetCellHeight();

		if (referGPU!=NULL && referGPU[0]!=NULL)
			MapDialogRect(referGPU[0]->UnitHWND,&re);
		re.left=re.left*64/1444;
		re.top=re.top*64/1550;
		re.right=re.right*64/1444;
		re.bottom=re.bottom*64/1550;

		if (OldRow!=iRow) SetRow(OldRow);
		if (OldCol!=iCol) SetRow(OldCol);
	}
	return re;
}

LRESULT GPCMSFlexGrid::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
	if (referGPU && referGPU[UnitId&0xFFFF])
	{
		referGPU[UnitId&0xFFFF]->m_CurMessage.message=message;
		referGPU[UnitId&0xFFFF]->m_CurMessage.wParam=wParam;
		referGPU[UnitId&0xFFFF]->m_CurMessage.lParam=lParam;
		referGPU[UnitId&0xFFFF]->DefWindowProc(message, wParam, lParam);
	}

	if (message==GPM_SETAUTOSIZE) 
		GetParent()->PostMessage(GPM_SETAUTOSIZE,wParam);

	if (message==GPN_UPDATESIZE) GetParent()->SendMessage(GPN_UPDATESIZE);
	
	if (referGPU && referGPU[UnitId&0xFFFF] && referGPU[UnitId&0xFFFF]->GPMSG) 
	{
		if (message==GPM_CLIENTKILLFOCUS || message==GPM_CLIENTSETFOCUS)
		{
			PGPUNITINFO ui=(PGPUNITINFO)lParam;
			if (ui)
				referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent
					(m_hWnd, UnitId,message==GPM_CLIENTSETFOCUS?"OnCSetFocus":"OnCKillFocus",GPUnit::UnitInfoToString2(ui,"\x7F"));
		}
		

		UINT ret;
		if ((ret=referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjMessage(m_hWnd, UnitId, message, wParam, lParam))>0) return ret;
		if (message==WM_KEYDOWN && referGPU!=NULL && referGPU[UnitId&0xFFFF]->UnitHotkey && this->m_hWnd!=NULL && IsWindowEnabled()==TRUE && IsWindowVisible()==TRUE)
				if ((ret=referGPU[UnitId&0xFFFF]->UnitHotkey->SendHotkeyMessage(message, wParam,lParam))>0) return ret;
		if (message==GPM_PROCHOTKEY)
		{
			if(referGPU[UnitId&0xFFFF]->UnitHotkey && (ret=referGPU[UnitId&0xFFFF]->UnitHotkey->SendHotkeyMessage(WM_KEYDOWN, wParam,lParam))>0) return ret;
			GetParent()->SendMessage(message, wParam,lParam);
		}
		else 
		if  (message==WM_KEYDOWN)
			GetParent()->SendMessage(GPM_PROCHOTKEY, wParam,lParam);
	}

	if (message==GPM_NEXTCELL &&(m_EditInProgr&0x1)!=0 && hti.x>=0 && hti.y>=0 && referGPU!=NULL)
	{
//		m_EditInProgr=onoff+verhor*2+skip*4+forback*8+lcbreak*16;
		UINT verhor=m_EditInProgr&2,skip=m_EditInProgr&4,forback=m_EditInProgr&8,lcbreak=m_EditInProgr&16;
		switch(wParam)
		{
		case VK_LEFT:	wParam=0;	verhor=0;		forback=1;	MayBeChangeEdit=TRUE;break;
		case VK_RIGHT:	wParam=0;	verhor=0;		forback=0;	MayBeChangeEdit=TRUE;break;
		case VK_DOWN:	wParam=0;	verhor=1;		forback=0;	MayBeChangeEdit=TRUE;break;
		case VK_UP:		wParam=0;	verhor=1;		forback=1;	MayBeChangeEdit=TRUE;break;
		}
		
		
		UINT nCol=GetCols();
		UINT nRow=GetRows();
		UINT ncurrent=hti.y*nCol+hti.x;
		UINT ncurrent2=ncurrent,nctmp=ncurrent;
		UINT nall=nCol*nRow;
		UINT EdID,n=0;

		do
		{
			if (verhor==0) // по горизонтали
			{
				if (forback==0)
				{
					nctmp++;
					if (lcbreak==0 &&(nctmp%nCol)==0 ) break;
					if (nctmp==nall) nctmp=0;
				}
				else
				{
					if (lcbreak==0 &&(nctmp%nCol)==0 ) break;
					if (nctmp==0) nctmp=nall;
					nctmp--;
				}
			}
			else	// по вертикали
			{
				if (forback==0)
				{
					nctmp+=nCol;
					if (lcbreak==0 && nctmp>=nall) break;
					if (nctmp>=nall) nctmp%=nCol;
				}
				else
				{
					if (lcbreak==0 && nctmp<nCol) break;
					if (nctmp<nCol) nctmp+=nall;
					nctmp-=nCol;
				}
			}
			

			if ((EdID=GetEditorID(nctmp/nCol,nctmp%nCol))>0	&& referGPU[EdID]!=NULL && referGPU[EdID]->UnitHWND!=NULL)
					{	ncurrent=nctmp;	break;	}
		}
		while(++n<nall);

		if (ncurrent2==ncurrent && nall>1)
			SetSelByEdit(1);


		if (ncurrent2!=ncurrent)
		{
			hti.y=ncurrent/nCol;
			hti.x=(ncurrent%nCol);

			if (ncurrent/nCol>ncurrent2/nCol)/*DOWN*/
			{
				int tRow=GetTopRow();
				while(hti.y>tRow && GetRowIsVisible(hti.y)==0 && tRow>0)
					SetTopRow(++tRow);
				SetEditRect();
			}
			else
			if (ncurrent/nCol<ncurrent2/nCol)/*UP*/
			{
				int tRow=GetTopRow();
				while(GetRowIsVisible(hti.y)==0 && tRow>1)
					SetTopRow(--tRow);
				SetEditRect();
			}

			if ((ncurrent%nCol)<(ncurrent2%nCol)) /*LEFT*/
			{
				int lcol=GetLeftCol();
				while(GetColIsVisible(hti.x)==0 && lcol>1)
					SetLeftCol(--lcol);
				SetEditRect();
			}
			else
			if ((ncurrent%nCol)>(ncurrent2%nCol)) /*RIGHT*/
			{
				int lcol=GetLeftCol();
				while(hti.x>lcol && GetColIsVisible(hti.x)==0)
					SetLeftCol(++lcol);
				SetEditRect();
			}

			if (GetColIsVisible(hti.x)==0)
			{
				int lcol=GetLeftCol();
				if (lcol>hti.x)
					while(GetColIsVisible(hti.x)==0 && lcol>1)
						SetLeftCol(--lcol);
				else
					while(hti.x>lcol && GetColIsVisible(hti.x)==0 && lcol>0)
						SetLeftCol(++lcol);
			}
			
			if (GetRowIsVisible(hti.y)==0)
			{
				int lRow=GetTopRow();
				if (lRow>hti.y)
					while(GetRowIsVisible(hti.y)==0 && lRow>1)
						SetTopRow(--lRow);
				else
					while(hti.y>lRow && GetRowIsVisible(hti.y)==0 && lRow>0)
						SetTopRow(++lRow);
			}

			SetRow(hti.y);
			SetCol(hti.x);
			
			SetEditRect();
			SetFocus();
			if ((wParam&0x1)==0) SetSelByEdit();
		}
	}


	if (message==GPM_ESCCELL &&(m_EditInProgr&0x1)!=0 && AutoUpdate==TRUE && lasthti.y>=0 && lasthti.x>=0 && EditorID!=0 && referGPU[EditorID]!=NULL && referGPU[EditorID]->UnitHWND!=NULL && hti.y!=-1 && hti.x!=-1)
	{
		CString str="TEXT=";
			str+=GetTextMatrix(hti.y,hti.x);
		referGPU[EditorID]->GPSetProperty((LPCSTR)str);
		SetFocus();
	}

	if (message==WM_KEYDOWN &&(m_EditInProgr&0x1)!=0 && hti.x>=0 && hti.y>=0) 
	{
		switch(wParam)
		{
		case 40:	/*DOWN*/
			if (hti.y<GetRows()-1)	
			{
				hti.y++;
				int tRow=GetTopRow();
				while(hti.y>tRow && GetRowIsVisible(hti.y)==0 && tRow>0)
					SetTopRow(++tRow);

				SetEditRect(); 
				SetSelByEdit();
			}
			return 0;
		case 38:	/*UP*/
			if (hti.y>0)	
			{
				hti.y--;
				int tRow=GetTopRow();
				while(GetRowIsVisible(hti.y)==0 && tRow>1)
					SetTopRow(--tRow);
				SetEditRect();
				SetSelByEdit();
			}
			return 0;
		case 37:	/*LEFT*/
			if (hti.x>0)
			{
				hti.x--;
				int lcol=GetLeftCol();
				while(GetColIsVisible(hti.x)==0 && lcol>1)
					SetLeftCol(--lcol);

				SetEditRect();
				SetSelByEdit();
			}
			return 0;
		case 39:	/*RIGHT*/
			if (hti.x<GetCols()-1) /*RIGHT*/ 
			{
				hti.x++;
				int lcol=GetLeftCol();
				while(hti.x>lcol && GetColIsVisible(hti.x)==0)
					SetLeftCol(++lcol);

				SetEditRect();
				SetSelByEdit();
			}
			return 0;
		case 36:	/*HOME*/
			{
				UINT skip=m_EditInProgr&4;

				if ((m_EditInProgr&4)!=0)
				{
					int nCol=GetCols()-1;
					UINT EdID;

					for(hti.x=0;hti.x<nCol;hti.x++)
					{
						if ((EdID=GetEditorID(hti.y,hti.x))>0
							&& referGPU[EdID]!=NULL && referGPU[EdID]->UnitHWND!=NULL)	break;
					}
				}
				else				
					hti.x=0;


				if (GetColIsVisible(hti.x)==0)
				{
					int lcol=GetLeftCol();
					if (lcol>hti.x)
						while(GetColIsVisible(hti.x)==0 && lcol>1)
							SetLeftCol(--lcol);
					else
						while(hti.x>lcol && GetColIsVisible(hti.x)==0 && lcol>0)
							SetLeftCol(++lcol);
				}

				SetEditRect();
				SetSelByEdit();
			}
			return 0;
		case 35:	/*END*/
			{

				UINT skip=m_EditInProgr&4;
				hti.x=GetCols()-1;
				if ((m_EditInProgr&4)!=0)
				{
					UINT EdID;
					for(;hti.x>0;hti.x--)
					{
						if ((EdID=GetEditorID(hti.y,hti.x))>0
							&& referGPU[EdID]!=NULL && referGPU[EdID]->UnitHWND!=NULL)	break;
					}
				}
				
				if (GetColIsVisible(hti.x)==0)
				{
					int lcol=GetLeftCol();
					if (lcol>hti.x)
						while(GetColIsVisible(hti.x)==0 && lcol>1)
							SetLeftCol(--lcol);
					else
						while(hti.x>lcol && GetColIsVisible(hti.x)==0 && lcol>0)
							SetLeftCol(++lcol);
				}
				SetEditRect();
				SetSelByEdit();
			}
			return 0;
		case 34:	/*PGDN*/
			{
				hti.y+=GetCountRowPerPage()*3/4;
				if (hti.y>=GetRows() ||(GetKeyState(VK_CONTROL)&0xFF00)!=0) hti.y=GetRows()-1;
				EnsureVisible(hti.y,FALSE);
				SetEditRect();
				SetSelByEdit();
			}
			return 0;
		case 33:	/*PGUP*/
			{
				hti.y-=GetCountRowPerPage( )*3/4;
				if (hti.y<0 ||(GetKeyState(VK_CONTROL)&0xFF00)!=0) hti.y=0;
				EnsureVisible(hti.y,FALSE);
				SetEditRect();
				SetSelByEdit();
			}
			return 0;
		}
	}

	if ((m_EditInProgr&0x1)!=0 &&(message==WM_KEYDOWN || message==WM_KEYUP || message==WM_CHAR)  && EditorID!=0 && hti.x>=0 && hti.y>=0 && referGPU!=NULL && referGPU[EditorID]!=NULL && referGPU[EditorID]->UnitHWND!=NULL && wParam!=13)
	{
		if (message==WM_KEYDOWN) ::SetFocus(referGPU[EditorID]->UnitHWND);
		if (message==WM_KEYUP || message==WM_CHAR || message==WM_KEYDOWN) 
			::SendMessage(referGPU[EditorID]->UnitHWND,message,wParam,lParam);  
	}
	
	switch(message)
	{
	case GPM_DRAGMOUSELEAVE:
		if (referGPU!=NULL)	referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent(m_hWnd, UnitId,"OnDragLeave","");
		break;
	case GPM_DRAGMOUSEMOVE:	
		OnMouseDragMove((PGPDRAGDROPSTRUCT)wParam,(LPPOINT)lParam);
		break;
	case GPM_DRAGMOUSEHOVER:
		OnDragMouseHover();
		break;
	case GPM_DROPITEMS:
		OnDragLButtonUp((PGPDRAGDROPSTRUCT)wParam,(LPPOINT)lParam);
		break;
	}

	LRESULT lpr=0;
	if (message==WM_SETCURSOR && GPC.m_bWaitCursor) lpr=FALSE;
//	else lpr=CWnd::WindowProc(message, wParam, lParam);


	if (message==WM_NOTIFY && referGPU!=NULL)
	{
		NMHDR* pNMHDR=(LPNMHDR) lParam;
		if (pNMHDR!=NULL)
			if (pNMHDR->code==HDN_ITEMCHANGED || pNMHDR->code==HDN_ENDDRAG)
			SetEditRect();
	}


	if (message==WM_SIZEPARENT && referGPU!=NULL)
	{
		UINT SizStyle=referGPU[UnitId&0xFFFF]->SizStyle;
		if ((SizStyle&0xFFFF0000)!=0)
		{
			AFX_SIZEPARENTPARAMS* lpLayout =(AFX_SIZEPARENTPARAMS*)lParam;

			CRect re;
			GetWindowRect(&re);
			MoveWindow(&re);
			switch((SizStyle&0xFFFF0000)/0x10000)
			{
			case GPUA_TOP:
				MoveWindow(lpLayout->rect.left,lpLayout->rect.top,lpLayout->rect.right-lpLayout->rect.left,re.Height());
				lpLayout->rect.top+=re.Height();
				break;
			case GPUA_BOTTOM:
				MoveWindow(lpLayout->rect.left,lpLayout->rect.bottom-re.Height(),lpLayout->rect.right-lpLayout->rect.left,re.Height());
				lpLayout->rect.bottom-=re.Height();
				break;
			case GPUA_LEFT:
				MoveWindow(lpLayout->rect.left,lpLayout->rect.top,re.Width(),lpLayout->rect.bottom-lpLayout->rect.top);
				lpLayout->rect.left+=re.Width();
				break;
			case GPUA_RIGHT:
				MoveWindow(lpLayout->rect.right-re.Width(),lpLayout->rect.top,re.Width(),lpLayout->rect.bottom-lpLayout->rect.top);
				lpLayout->rect.right-=re.Width();
				break;
			}
		}
	}

	return lpr;	
}

UINT GPCMSFlexGrid::GetEditorID(int nRow, int nCol)
{
	PFGITEMDATA ptrc=NULL,ptrr=NULL;
	UINT EdID=0;

	try
	{
		ptrr=(PFGITEMDATA)GetRowData(hti.y);
		ptrc=(PFGITEMDATA)GetColData(hti.x);
		if (ptrr)
			EdID=ptrr->EditorId;
		UINT EdTmp=0;
		if (ptrc)
			EdTmp=ptrc->EditorId;

		UINT op=EdID/0x10000;
		if (op==0) op=EdTmp/0x10000;
		switch(op)
		{
		case 0: if (EdID==0) EdID=EdTmp; break;
		case 1: EdID&=EdTmp; break;
		case 2: EdID|=EdTmp; break;
		case 4: EdID^=EdTmp; break;
		case 5: EdID&=(EdTmp^0xFFFF); break;
		}
		EdID&=0xFFFF;
	}
	catch(...)
	{
		GPC.m_ErrReport.GPWriteErrorLog("GPCMSFlexGrid", "GetEditorID","");
		EdID=0;
	}
	return EdID;
}

void GPCMSFlexGrid::RedrawItems(int Row1, int Row2)
{
	CRect re1=GetCellRect(Row1,0);
	CRect re2=GetCellRect(Row2,GetCols());
	re1.right=re2.right;
	re1.bottom=re2.bottom;
	InvalidateRect(re1);
}

int GPCMSFlexGrid::GetCountRowPerPage()
{
	int ret=1;
	int nRows=GetRows();
	int TopRow=GetTopRow()+1;
	while(TopRow<nRows && GetRowIsVisible(TopRow++)) ret++;

	return ret;
}

int GPCMSFlexGrid::GetCountColPerPage()
{
	int ret=1;
	int nCols=GetCols();
	int LeftCol=GetLeftCol()+1;
	while(LeftCol<nCols && GetColIsVisible(LeftCol++)) ret++;

	return ret;
}

BOOL GPCMSFlexGrid::InstallFlex()
{
	char str[1000];
	char fDest[1000];
	GetSystemDirectory(str,500);
	sprintf(fDest,"%s\\MSFLXGRD.OCX",str);
	CopyFile("ComInst\\MSFLXGRD.OCX",fDest,FALSE);
	sprintf(fDest,"%s\\MSFLXGRD.oca",str);
	CopyFile("ComInst\\MSFLXGRD.oca",fDest,FALSE);
	sprintf(fDest,"%s\\MSFLXGRD.DEP",str);
	CopyFile("ComInst\\MSFLXGRD.DEP",fDest,FALSE);
	_spawnlp(_P_WAIT,"regsvr32.exe","regsvr32.exe","MSFLXGRD.OCX",NULL);
	Sleep(2000);
	return TRUE;
}

void GPCMSFlexGrid::OnSizing(UINT fwSide, LPRECT pRect) 
{
	BOOL EnableSz=TRUE;
	UINT SizStyle=referGPU[UnitId&0xFFFF]->SizStyle;
	if ((SizStyle&0xFFFF)!=0)
	{
		CRect re;
		GetWindowRect(&re);
		switch(fwSide)
		{
		case WMSZ_BOTTOM:
			if ((SizStyle&GPUA_BOTTOM)!=GPUA_BOTTOM) EnableSz=FALSE;
			break;
		case WMSZ_BOTTOMLEFT:
			if ((SizStyle&GPUA_BOTTOM)!=GPUA_BOTTOM &&(SizStyle&GPUA_LEFT)!=GPUA_LEFT) EnableSz=FALSE;
			break;
		case WMSZ_BOTTOMRIGHT:
			if ((SizStyle&GPUA_BOTTOM)!=GPUA_BOTTOM &&(SizStyle&GPUA_RIGHT)!=GPUA_RIGHT) EnableSz=FALSE;
			break;
		case WMSZ_LEFT:
			if ((SizStyle&GPUA_LEFT)!=GPUA_LEFT) EnableSz=FALSE;
			break;
		case WMSZ_RIGHT:
			if ((SizStyle&GPUA_RIGHT)!=GPUA_RIGHT) EnableSz=FALSE;
			break;
		case WMSZ_TOP:
			if ((SizStyle&GPUA_TOP)!=GPUA_TOP) EnableSz=FALSE;
			break;
		case WMSZ_TOPLEFT:
			if ((SizStyle&GPUA_LEFT)!=GPUA_LEFT &&(SizStyle&GPUA_TOP)!=GPUA_TOP) EnableSz=FALSE;
			break;
		case WMSZ_TOPRIGHT:
			if ((SizStyle&GPUA_RIGHT)!=GPUA_RIGHT &&(SizStyle&GPUA_TOP)!=GPUA_TOP) EnableSz=FALSE;
			break;
		}
		if (EnableSz==FALSE)
		{
			pRect->top=re.top;
			pRect->left=re.left;
			pRect->right=re.right;
			pRect->bottom=re.bottom;
		}
		else
		{
			GetParent()->SendMessage(WM_SIZE);
		}
	}

	if (EnableSz) CWnd::OnSizing(fwSide, pRect);

	GetParent()->SendMessage(GPN_UPDATESIZE);
		
}

void GPCMSFlexGrid::OnDragMouseHover() 
{
	if (referGPU[UnitId&0xFFFF]->m_DropNamesArray && referGPU[UnitId&0xFFFF]->m_DropNamesArray->GetIdByVal(GPC.m_DragDrop.DragName)<0xFFFFFFFFL)
	{
		// Reset the timer.
		::SetTimer(GPC.m_DragDrop.hWndDrag,DRAG_TIMER_ID, referGPU[UnitId&0xFFFF]->m_nScrollInterval, NULL);

		// Get the current cursor position and window height.
		DWORD dwPos = ::GetMessagePos();
		CPoint point(LOWORD(dwPos), HIWORD(dwPos));
		ScreenToClient(&point);

		CRect rect;
		GetClientRect(rect);
		int cy = rect.Height();

		// Scroll the window if the cursor is near the top or bottom.
		if (point.y >= 0 && point.y <= referGPU[UnitId&0xFFFF]->m_nScrollMargin)
		{
			long iFirstVisible = GetTopRow();
			GPC.m_DragDrop.pImageList->DragShowNolock(FALSE);
			SendMessage(WM_VSCROLL, MAKEWPARAM(SB_LINEUP, 0), NULL);
			GPC.m_DragDrop.pImageList->DragShowNolock(TRUE);

			// Kill the timer if the window did not scroll, or redraw the drop target highlight if the window did scroll.
			if (GetTopRow() == iFirstVisible)
				::KillTimer(GPC.m_DragDrop.hWndDrag,DRAG_TIMER_ID);
				else 
					HighlightDropTarget(&GPC.m_DragDrop, point);
		}
		else
			if (point.y >= cy - referGPU[UnitId&0xFFFF]->m_nScrollMargin && point.y <= cy) 
			{
				long iFirstVisible = GetTopRow();
				GPC.m_DragDrop.pImageList->DragShowNolock(FALSE);
				SendMessage(WM_VSCROLL, MAKEWPARAM(SB_LINEDOWN, 0), NULL);
				GPC.m_DragDrop.pImageList->DragShowNolock(TRUE);

				// Kill the timer if the window did not scroll, or redraw the drop target highlight if the window did scroll.
				if (GetTopRow() == iFirstVisible) ::KillTimer(GPC.m_DragDrop.hWndDrag,DRAG_TIMER_ID);
				else 
					HighlightDropTarget(&GPC.m_DragDrop, point);
			}
			else ::KillTimer(GPC.m_DragDrop.hWndDrag,DRAG_TIMER_ID);
		
		CString tmps;
		int mCol=GetMouseCol();
		int mRow=GetMouseRow();
		tmps.Format("%d\x07%d\x07%s\x07%s",mRow,mCol,GetTextMatrix(mRow,0),GetTextMatrix(mRow,mCol));
		referGPU[UnitId&0xFFFF]->SendDropHoverEvent(tmps,&GPC.m_DragDrop,&point);
	}
}

void GPCMSFlexGrid::OnMouseDragMove(PGPDRAGDROPSTRUCT pDrDrStruct, LPPOINT point) 
{
	if (pDrDrStruct && pDrDrStruct->pImageList != NULL)
	{
		::ScreenToClient(m_hWnd,point);
		::KillTimer(pDrDrStruct->hWndDrag,DRAG_TIMER_ID);
		// Offset point
		if (referGPU && referGPU[UnitId&0xFFFF])	
			referGPU[UnitId&0xFFFF]->OffsetWndPoint(point);

		// Erase the old drag image and draw a new one.
		if (pDrDrStruct->hWndLast!=m_hWnd)
		{
			pDrDrStruct->pImageList->DragLeave(CWnd::FromHandle(pDrDrStruct->hWndLast));
			pDrDrStruct->hWndLast=m_hWnd;
			pDrDrStruct->pImageList->DragEnter(this, CPoint(*point));
		}
		pDrDrStruct->pImageList->DragMove(CPoint(*point));

		DWORD iItem=0xFFFFFFFF;
		BOOL mDrop=referGPU[UnitId&0xFFFF]->m_DropNamesArray && referGPU[UnitId&0xFFFF]->m_DropNamesArray->GetIdByVal(pDrDrStruct->DragName)<0xFFFFFFFFL;
		// Highlight the drop target if the cursor is over an item.
		if (mDrop)
			iItem = HighlightDropTarget(pDrDrStruct, CPoint(*point));
		// Modify the cursor to provide visual feedback to the user. Note: It's important to do this AFTER the call to DragMove.
		::SetCursor(iItem ==0xFFFFFFFF ?
			AfxGetApp()->LoadStandardCursor(IDC_NO) :
			(HCURSOR) ::GetClassLong(m_hWnd, GCL_HCURSOR));

		referGPU[UnitId&0xFFFF]->SendDropMoveEvent("",pDrDrStruct,point);
		
		if (mDrop)
			::SetTimer(pDrDrStruct->hWndDrag,DRAG_TIMER_ID, referGPU[UnitId&0xFFFF]->m_nDelayInterval, NULL);
	}
}

void GPCMSFlexGrid::OnDragLButtonUp(PGPDRAGDROPSTRUCT pDrDrStruct, LPPOINT point) 
{
	BOOL mDrop=referGPU[UnitId&0xFFFF]->m_DropNamesArray && referGPU[UnitId&0xFFFF]->m_DropNamesArray->GetIdByVal(pDrDrStruct->DragName)<0xFFFFFFFFL;
	if (pDrDrStruct && mDrop && referGPU)
	{
		::ScreenToClient(m_hWnd,point);

		CString tmps;
		int mCol=GetMouseCol();
		int mRow=GetMouseRow();
		tmps.Format("%d\x07%d\x07%s\x07%s",mRow,mCol,GetTextMatrix(mRow,0),GetTextMatrix(mRow,mCol));
		referGPU[UnitId&0xFFFF]->SendDropEvent(tmps,pDrDrStruct,point);
	}
}

DWORD GPCMSFlexGrid::HighlightDropTarget(PGPDRAGDROPSTRUCT pDrDrStruct, CPoint point)
{
	return 0;
}

LRESULT GPCMSFlexGrid::OnNcHitTest(CPoint point) 
{
	LRESULT ret=CWnd::OnNcHitTest(point);
	if (referGPU && referGPU[UnitId&0xFFFF])
		ret=referGPU[UnitId&0xFFFF]->GPNCHitTest(point,ret);
	return ret;
}

#include "GP_TermDoc.h"

void GPCMSFlexGrid::OnKillFocus(CWnd* pNewWnd) 
{
	CWnd::OnKillFocus(pNewWnd);
	GPUNITINFO ui;
	GPUNITINFO uiold;
	if (referGPU && referGPU[UnitId&0xFFFF])
		referGPU[UnitId&0xFFFF]->GetUnitInfo(ui);
	if (pNewWnd)
	{
		GPC.m_Document->FindObject(pNewWnd->m_hWnd,uiold);
		ui.hWnd2=uiold.hWnd;
		ui.IdDlg2=uiold.IdDlg;
		ui.IdObj2=uiold.IdObj;
	}
	if (referGPU && referGPU[UnitId&0xFFFF] && referGPU[UnitId&0xFFFF]->GPMSG) 
	{
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent
			(m_hWnd, UnitId,"OnKillFocus",GPUnit::UnitInfoToString2(&ui,"\x7F"));
	}

	::SendMessage(::GetParent(m_hWnd),GPM_CLIENTKILLFOCUS,(WPARAM)(pNewWnd?pNewWnd->m_hWnd:NULL),(LPARAM)&ui);

}

void GPCMSFlexGrid::OnSetFocus(CWnd* pOldWnd) 
{
	CWnd::OnSetFocus(pOldWnd);
	GPUNITINFO ui;
	GPUNITINFO uiold;
	if (referGPU && referGPU[UnitId&0xFFFF])
		referGPU[UnitId&0xFFFF]->GetUnitInfo(ui);
	if (pOldWnd)
	{
		GPC.m_Document->FindObject(pOldWnd->m_hWnd,uiold);
		ui.hWnd2=uiold.hWnd;
		ui.IdDlg2=uiold.IdDlg;
		ui.IdObj2=uiold.IdObj;
	}
	if (referGPU && referGPU[UnitId&0xFFFF] && referGPU[UnitId&0xFFFF]->GPMSG) 
		referGPU[UnitId&0xFFFF]->GPMSG->GPSendObjEvent
			(m_hWnd, UnitId,"OnSetFocus",GPUnit::UnitInfoToString2(&ui,"\x7F"));

	::SendMessage(::GetParent(m_hWnd),GPM_CLIENTSETFOCUS,(WPARAM)(pOldWnd?pOldWnd->m_hWnd:NULL),(LPARAM)&ui);
}

void GPCMSFlexGrid::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	
	if (m_hWnd)
	{
		if (referGPU!=NULL && referGPU[UnitId&0xFFFF])
			referGPU[UnitId&0xFFFF]->UpdateSizerSize();
	}
}

void GPCMSFlexGrid::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	CWnd::OnHScroll(nSBCode, nPos, pScrollBar);
	if (referGPU && referGPU[UnitId&0xFFFF]->m_SizerArray)	Invalidate();
}

void GPCMSFlexGrid::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	CWnd::OnVScroll(nSBCode, nPos, pScrollBar);
	if (referGPU && referGPU[UnitId&0xFFFF]->m_SizerArray)	Invalidate();
}

void GPCMSFlexGrid::OnLButtonUp(UINT nFlags, CPoint point) 
{
	m_uLastMouseUpFlag=nFlags;
	CWnd::OnLButtonUp(nFlags, point);
}

void GPCMSFlexGrid::OnMButtonUp(UINT nFlags, CPoint point) 
{
	m_uLastMouseUpFlag=nFlags;
	CWnd::OnMButtonUp(nFlags, point);
}

void GPCMSFlexGrid::OnRButtonUp(UINT nFlags, CPoint point) 
{
	m_uLastMouseUpFlag=nFlags;
	CWnd::OnRButtonUp(nFlags, point);
}

HBRUSH GPCMSFlexGrid::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
	HBRUSH hbr = NULL;
	if (referGPU && referGPU[UnitId&0xFFFF]->m_brBkgnd) 
	{
		hbr = (HBRUSH) *(referGPU[UnitId&0xFFFF]->m_brBkgnd);
	    RECT rc;
		::GetWindowRect(pWnd->m_hWnd, &rc);
		::MapWindowPoints(NULL, m_hWnd, (POINT *)&rc, 2);
		::SetBrushOrgEx(pDC->m_hDC, -rc.left, -rc.top, NULL);
	}

	if (pWnd && pDC && pWnd->m_hWnd && pDC->m_hDC)
		GPUnit::ChildCtlColor(referGPU, pDC->m_hDC, pWnd->m_hWnd, hbr, CWnd::OnCtlColor(pDC, pWnd, nCtlColor), nCtlColor);

	return hbr;
}

int GPCMSFlexGrid::AddChar(char iChar, DWORD iFlags)
{
	int ret=0;
	if (iChar)
	{

		int nItem=GetRows();
		CString text="";
		if (nItem) 
			text=GetTextMatrix(--nItem,m_DOSubItem);
		else 
		{
			nItem=0;
			SetRows(nItem+1);
		}

		if (iChar==10 && (iFlags&0x2))
		{
			text="";
			m_DOSubItem=0;
			SetRows(nItem);
			SetRows(nItem+1);
		}
		else 
		if (iChar==13 || (iChar==GPC.DelimiterIn1 && (iFlags&0x8)))
		{
			m_DOSubItem=0;
			SetRows(nItem+1);
		}
		else 
		if (iChar==8 && (iFlags&0x4))
		{
			int pos=text.GetLength();
			if (pos) text=text.Left(pos-1);
			SetTextMatrix(nItem,m_DOSubItem,text);
		}
		else 
		if ((iChar==9 && (iFlags&0x40)==0) || (iChar==GPC.DelimiterIn2 && (iFlags&0x10)))
		{
			m_DOSubItem++;
			if (m_DOSubItem>=GetCols()) 
			{
				m_DOSubItem=0;
				text="";
				SetTextMatrix(nItem,m_DOSubItem,text);
			}
		}
		else 
		if (iChar) 
		{
			text+=iChar;
			SetTextMatrix(nItem,m_DOSubItem,text);
		}
		ret=text.GetLength();
	}
	return ret;
}
